

GNU MP

The GNU Multiple Precision Arithmetic LibraryEdition 4.2.3

22 July 2008

by The GMP team This manual describes how to install and use the GNU multiple precision arithmetic library,version 4.2.3. Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,2006, 2007, 2008 Free Software Foundation, Inc. Permission is granted to copy, distribute and/or modify this document under the terms ofthe GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, with the Front-Cover Texts being "A GNUManual", and with the Back-Cover Texts being "You have freedom to copy and modify this GNU Manual, like GNU software". A copy of the license is included in Appendix C [GNU FreeDocumentation License], page 121.

i Table of Contents GNU MP Copying Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 Introduction to GNU MP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.1 How to use this Manual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

2 Installing GMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

2.1 Build Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32.2 ABI and ISA

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82.3 Notes for Package Builds

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112.4 Notes for Particular Systems

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122.5 Known Build Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142.6 Performance optimization

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

3 GMP Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3.1 Headers and Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163.2 Nomenclature and Types

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163.3 Function Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173.4 Variable Conventions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173.5 Parameter Conventions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183.6 Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193.7 Reentrancy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193.8 Useful Macros and Constants

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203.9 Compatibility with older versions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203.10 Demonstration programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203.11 Efficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213.12 Debugging

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233.13 Profiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253.14 Autoconf

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263.15 Emacs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

4 Reporting Bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

5 Integer Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

5.1 Initialization Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295.2 Assignment Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295.3 Combined Initialization and Assignment Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305.4 Conversion Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315.5 Arithmetic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325.6 Division Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325.7 Exponentiation Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345.8 Root Extraction Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355.9 Number Theoretic Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355.10 Comparison Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375.11 Logical and Bit Manipulation Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385.12 Input and Output Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395.13 Random Number Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

ii GNU MP 4.2.3

5.14 Integer Import and Export . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405.15 Miscellaneous Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425.16 Special Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

6 Rational Number Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

6.1 Initialization and Assignment Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446.2 Conversion Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456.3 Arithmetic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456.4 Comparison Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466.5 Applying Integer Functions to Rationals

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466.6 Input and Output Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

7 Floating-point Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

7.1 Initialization Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487.2 Assignment Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507.3 Combined Initialization and Assignment Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507.4 Conversion Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517.5 Arithmetic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527.6 Comparison Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537.7 Input and Output Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537.8 Miscellaneous Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

8 Low-level Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

8.1 Nails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

9 Random Number Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

9.1 Random State Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649.2 Random State Seeding

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659.3 Random State Miscellaneous

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

10 Formatted Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

10.1 Format Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6610.2 Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6810.3 C++ Formatted Output

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

11 Formatted Input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

11.1 Formatted Input Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7111.2 Formatted Input Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7311.3 C++ Formatted Input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

12 C++ Class Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

12.1 C++ Interface General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7512.2 C++ Interface Integers

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7612.3 C++ Interface Rationals

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7712.4 C++ Interface Floats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7912.5 C++ Interface Random Numbers

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8012.6 C++ Interface Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

13 Berkeley MP Compatible Functions . . . . . . . . . . . . . . . . . . . . . . . 83

iii 14 Custom Allocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

15 Language Bindings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 16 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

16.1 Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8916.1.1 Basecase Multiplication

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8916.1.2 Karatsuba Multiplication

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9016.1.3 Toom 3-Way Multiplication

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9116.1.4 FFT Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9316.1.5 Other Multiplication

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9416.2 Division Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9516.2.1 Single Limb Division

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9516.2.2 Basecase Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9516.2.3 Divide and Conquer Division

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9616.2.4 Exact Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9616.2.5 Exact Remainder

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9716.2.6 Small Quotient Division

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9816.3 Greatest Common Divisor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9816.3.1 Binary GCD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9816.3.2 Accelerated GCD

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9916.3.3 Extended GCD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9916.3.4 Jacobi Symbol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10016.4 Powering Algorithms

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10016.4.1 Normal Powering

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10016.4.2 Modular Powering

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10016.5 Root Extraction Algorithms

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10016.5.1 Square Root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10016.5.2 Nth Root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10116.5.3 Perfect Square

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10116.5.4 Perfect Power . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10216.6 Radix Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10216.6.1 Binary to Radix

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10216.6.2 Radix to Binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10316.7 Other Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10416.7.1 Prime Testing

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10416.7.2 Factorial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10416.7.3 Binomial Coefficients

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10516.7.4 Fibonacci Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10516.7.5 Lucas Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10616.7.6 Random Numbers

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10616.8 Assembly Coding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10616.8.1 Code Organisation

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10716.8.2 Assembly Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10716.8.3 Carry Propagation

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10716.8.4 Cache Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10816.8.5 Functional Units

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10816.8.6 Floating Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10916.8.7 SIMD Instructions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11016.8.8 Software Pipelining

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11016.8.9 Loop Unrolling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11016.8.10 Writing Guide

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

iv GNU MP 4.2.3 17 Internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

17.1 Integer Internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11217.2 Rational Internals

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11217.3 Float Internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11317.4 Raw Output Internals

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11517.5 C++ Interface Internals

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

Appendix A Contributors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

Appendix B References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

B.1 Books . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119B.2 Papers

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

Appendix C GNU Free Documentation License . . . . . . . . . . . 121

C.1 ADDENDUM: How to use this License for your documents . . . . . . . . . . . . . . . . . . . . . . 126

Concept Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127

Function and Type Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

GNU MP Copying Conditions 1 GNU MP Copying Conditions This library is free; this means that everyone is free to use it and free to redistribute it on a freebasis. The library is not in the public domain; it is copyrighted and there are restrictions on its distribution, but these restrictions are designed to permit everything that a good cooperatingcitizen would want to do. What is not allowed is to try to prevent others from further sharing any version of this library that they might get from you. Specifically, we want to make sure that you have the right to give away copies of the library,that you receive source code or else can get it if you want it, that you can change this library

or use pieces of it in new free programs, and that you know you can do these things. To make sure that everyone has such rights, we have to forbid you to deprive anyone else ofthese rights. For example, if you distribute copies of the GNU MP library, you must give the

recipients all the rights that you have. You must make sure that they, too, receive or can getthe source code. And you must tell them their rights.

Also, for our own protection, we must make certain that everyone finds out that there is nowarranty for the GNU MP library. If it is modified by someone else and passed on, we want their recipients to know that what they have is not what we distributed, so that any problemsintroduced by others will not reflect on our reputation.

The precise conditions of the license for the GNU MP library are found in the Lesser GeneralPublic License version 3 that accompanies the source code, see `

COPYING.LIB'. Certain demon-stration programs are provided under the terms of the plain General Public License version 3,

see `COPYING'.

2 GNU MP 4.2.3 1 Introduction to GNU MP GNU MP is a portable library written in C for arbitrary precision arithmetic on integers, rationalnumbers, and floating-point numbers. It aims to provide the fastest possible arithmetic for all applications that need higher precision than is directly supported by the basic C types. Many applications use just a few hundred bits of precision; but some applications may needthousands or even millions of bits. GMP is designed to give good performance for both, by

choosing algorithms based on the sizes of the operands, and by carefully keeping the overheadat a minimum.

The speed of GMP is achieved by using fullwords as the basic arithmetic type, by using sophis-ticated algorithms, by including carefully optimized assembly code for the most common inner loops for many different CPUs, and by a general emphasis on speed (as opposed to simplicityor elegance).

There is assembly code for these CPUs: ARM, DEC Alpha 21064, 21164, and 21264, AMD29000, AMD K6, K6-2, Athlon, and Athlon64, Hitachi SuperH and SH-2, HPPA 1.0, 1.1 and 2.0, Intel Pentium, Pentium Pro/II/III, Pentium 4, generic x86, Intel IA-64, i960, MotorolaMC68000, MC68020, MC88100, and MC88110, Motorola/IBM PowerPC 32 and 64, National NS32000, IBM POWER, MIPS R3000, R4000, SPARCv7, SuperSPARC, generic SPARCv8,UltraSPARC, DEC VAX, and Zilog Z8000. Some optimizations also for Cray vector systems, Clipper, IBM ROMP (RT), and Pyramid AP/XP. For up-to-date information on GMP, please see the GMP web pages at

http://gmplib.org/ The latest version of the library is available at

ftp://ftp.gnu.org/gnu/gmp Many sites around the world mirror `ftp.gnu.org', please use a mirror near you, see http://www.gnu.org/order/ftp.html for a full list.

There are three public mailing lists of interest. One for release announcements, one for generalquestions and discussions about usage of the GMP library and one for bug reports. For more

information, see

http://swox.com/mailman/listinfo/. The proper place for bug reports is gmp-bugs@swox.com. See Chapter 4 [Reporting Bugs],page 28 for information about reporting bugs.

1.1 How to use this Manual Everyone should read Chapter 3 [GMP Basics], page 16. If you need to install the libraryyourself, then read Chapter 2 [Installing GMP], page 3. If you have a system with multiple

ABIs, then read Section 2.2 [ABI and ISA], page 8, for the compiler options that must be usedon applications.

The rest of the manual can be used for later reference, although it is probably a good idea toglance through it.

Chapter 2: Installing GMP 3 2 Installing GMP GMP has an autoconf/automake/libtool based configuration system. On a Unix-like system abasic build can be done with

./configure make

Some self-tests can be run with

make check And you can install (under `/usr/local' by default) with

make install If you experience problems, please report them to gmp-bugs@swox.com. See Chapter 4 [Report-ing Bugs], page 28, for information on what to include in useful bug reports.

2.1 Build Options All the usual autoconf configure options are available, run `./configure --help' for a summary.The file `

INSTALL.autoconf' has some generic installation information too.

Tools `configure' requires various Unix-like tools. See Section 2.4 [Notes for ParticularSystems], page 12, for some options on non-Unix systems.

It might be possible to build without the help of `configure', certainly all the codeis there, but unfortunately you'll be on your own. Build DirectoryTo compile in a separate build directory,

cd to that directory, and prefix the configurecommand with the path to the GMP source directory. For example

cd /my/build/dir /my/sources/gmp-4.2.3/configure

Not all `make' programs have the necessary features (VPATH) to support this. Inparticular, SunOS and Slowaris

make have bugs that make them unable to build ina separate directory. Use GNU make instead.

`--prefix' and `--exec-prefix'The `

--prefix' option can be used in the normal way to direct GMP to installunder a particular tree. The default is `

/usr/local'.

`--exec-prefix' can be used to direct architecture-dependent files like `libgmp.a'to a different location. This can be used to share architecture-independent

parts like the documentation, but separate the dependent parts. Note howeverthat `

gmp.h' and `mp.h' are architecture-dependent since they encode certain as-pects of `

libgmp', so it will be necessary to ensure both `$prefix/include' and` $exec_prefix/include' are available to the compiler.

`--disable-shared', `--disable-static'By default both shared and static libraries are built (where possible), but one or

other can be disabled. Shared libraries result in smaller executables and permit codesharing between separate running processes, but on some CPUs are slightly slower, having a small cost on each function call. Native Compilation, `--build=CPU-VENDOR-OS'For normal native compilation, the system can be specified with `

--build'. Bydefault ` ./configure' uses the output from running `./config.guess'. On some

4 GNU MP 4.2.3

systems `./config.guess' can determine the exact CPU type, on others it will benecessary to give it explicitly. For example,

./configure --build=ultrasparc-sun-solaris2.7 In all cases the `OS' part is important, since it controls how libtool generates sharedlibraries. Running `

./config.guess' is the simplest way to see what it should be,if you don't know already.

Cross Compilation, `--host=CPU-VENDOR-OS'When cross-compiling, the system used for compiling is given by `

--build' and thesystem where the library will run is given by ` --host'. For example when using aFreeBSD Athlon system to build GNU/Linux m68k binaries,

./configure --build=athlon-pc-freebsd3.5 --host=m68k-mac-linux-gnu Compiler tools are sought first with the host system type as a prefix. For example m68k-mac-linux-gnu-ranlib is tried, then plain ranlib. This makes it possiblefor a set of cross-compiling tools to co-exist with native tools. The prefix is the

argument to `--host', and this can be an alias, such as `m68k-linux'. But notethat tools don't have to be setup this way, it's enough to just have a

PATH with asuitable cross-compiling cc etc.

Compiling for a different CPU in the same family as the build system is a form ofcross-compilation, though very possibly this would merely be special options on a

native compiler. In any case `./configure' avoids depending on being able to runcode on the build system, which is important when creating binaries for a newer CPU since they very possibly won't run on the build system. In all cases the compiler must be able to produce an executable (of whatever format)from a standard C

main. Although only object files will go to make up `libgmp',` ./configure' uses linking tests for various purposes, such as determining whatfunctions are available on the host system.

Currently a warning is given unless an explicit `--build' is used when cross-compiling, because it may not be possible to correctly guess the build system type if the PATH has only a cross-compiling cc. Note that the `--target' option is not appropriate for GMP. It's for use whenbuilding compiler tools, with `

--host' being where they will run, and `--target'what they'll produce code for. Ordinary programs or libraries like GMP are only

interested in the `--host' part, being where they'll run. (Some past versions ofGMP used `

--target' incorrectly.)

CPU types In general, if you want a library that runs as fast as possible, you should configure

GMP for the exact CPU type your system uses. However, this may mean the binarieswon't run on older members of the family, and might run slower on other members, older or newer. The best idea is always to build GMP for the exact machine typeyou intend to run it on.

The following CPUs have specific support. See `configure.in' for details of whatcode and compiler options they select.

* Alpha: `alpha', `alphaev5', `alphaev56', `alphapca56', `alphapca57',`

alphaev6', `alphaev67', `alphaev68' `alphaev7'*

Cray: `c90', `j90', `t90', `sv1'* HPPA: `hppa1.0', `hppa1.1', `hppa2.0', `hppa2.0n', `hppa2.0w', `hppa64'* IA-64: `ia64', `itanium', `itanium2'* MIPS: `mips', `mips3', `mips64'

Chapter 2: Installing GMP 5

* Motorola: `m68k', `m68000', `m68010', `m68020', `m68030', `m68040', `m68060',`

m68302', `m68360', `m88k', `m88110'*

POWER: `power', `power1', `power2', `power2sc'* PowerPC: `powerpc', `powerpc64', `powerpc401', `powerpc403', `powerpc405',`

powerpc505', `powerpc601', `powerpc602', `powerpc603', `powerpc603e',` powerpc604', `powerpc604e', `powerpc620', `powerpc630', `powerpc740',` powerpc7400', `powerpc7450', `powerpc750', `powerpc801', `powerpc821',` powerpc823', `powerpc860', `powerpc970'*

SPARC: `sparc', `sparcv8', `microsparc', `supersparc', `sparcv9',`

ultrasparc', `ultrasparc2', `ultrasparc2i', `ultrasparc3', `sparc64'*

x86 family: `i386', `i486', `i586', `pentium', `pentiummmx', `pentiumpro',`

pentium2', `pentium3', `pentium4', `k6', `k62', `k63', `athlon', `amd64',` viac3', `viac32'*

Other: `a29k', `arm', `clipper', `i960', `ns32k', `pyramid', `sh', `sh2', `vax',`

z8k'

CPUs not listed will use generic C code. Generic C BuildIf some of the assembly code causes problems, or if otherwise desired, the generic C

code can be selected with CPU `none'. For example,

./configure --host=none-unknown-freebsd3.5 Note that this will run quite slowly, but it should be portable and should at leastmake it possible to get something running if all else fails.

Fat binary, `--enable-fat'Using `

--enable-fat' selects a "fat binary" build on x86, where optimized lowlevel subroutines are chosen at runtime according to the CPU detected. This means

more code, but gives good performance on all x86 chips. (This option might becomeavailable for more architectures in the future.)

`ABI' On some systems GMP supports multiple ABIs (application binary interfaces),meaning data type sizes and calling conventions. By default GMP chooses the

best ABI available, but a particular ABI can be selected. For example

./configure --host=mips64-sgi-irix6 ABI=n32 See Section 2.2 [ABI and ISA], page 8, for the available choices on relevant CPUs,and what applications need to do.

`CC', `CFLAGS'By default the C compiler used is chosen from among some likely candidates, with

gcc normally preferred if it's present. The usual `CC=whatever' can be passed to`

./configure' to choose something different.

For various systems, default compiler flags are set based on the CPU and compiler.The usual `

CFLAGS="-whatever"' can be passed to `./configure' to use somethingdifferent or to set good flags for systems GMP doesn't otherwise know.

The `CC' and `CFLAGS' used are printed during `./configure', and can be foundin each generated `

Makefile'. This is the easiest way to check the defaults whenconsidering changing or adding something.

Note that when `CC' and `CFLAGS' are specified on a system supporting multipleABIs it's important to give an explicit `

ABI=whatever', since GMP can't determinethe ABI just from the flags and won't be able to select the correct assembly code.

If just `CC' is selected then normal default `CFLAGS' for that compiler will be used(if GMP recognises it). For example `

CC=gcc' can be used to force the use of GCC,with default flags (and default ABI).

6 GNU MP 4.2.3 `CPPFLAGS' Any flags like `

-D' defines or `-I' includes required by the preprocessor should beset in ` CPPFLAGS' rather than `CFLAGS'. Compiling is done with both `CPPFLAGS'and ` CFLAGS', but preprocessing uses just `CPPFLAGS'. This distinction is becausemost preprocessors won't accept all the flags the compiler does. Preprocessing is

done separately in some configure tests, and in the `ansi2knr' support for K&Rcompilers.

`CC_FOR_BUILD'Some build-time programs are compiled and run to generate host-specific data tables. `CC_FOR_BUILD' is the compiler used for this. It doesn't need to be in anyparticular ABI or mode, it merely needs to generate executables that can run. The default is to try the selected `CC' and some likely candidates such as `cc' and `gcc',looking for something that works.

No flags are used with `CC_FOR_BUILD' because a simple invocation like `cc foo.c'should be enough. If some particular options are required they can be included as for instance `CC_FOR_BUILD="cc -whatever"'. C++ Support, `--enable-cxx'C

++ support in GMP can be enabled with `--enable-cxx', in which case a C++compiler will be required. As a convenience `

--enable-cxx=detect' can be usedto enable C ++ support only if a compiler can be found. The C++ support consistsof a library `

libgmpxx.la' and header file `gmpxx.h' (see Section 3.1 [Headers andLibraries], page 16).

A separate `libgmpxx.la' has been adopted rather than having C++ objects within`

libgmp.la' in order to ensure dynamic linked C programs aren't bloated by adependency on the C

++ standard library, and to avoid any chance that the C++compiler could be required when linking plain C programs.

`libgmpxx.la' will use certain internals from `libgmp.la' and can only be expectedto work with `

libgmp.la' from the same GMP version. Future changes to the rele-vant internals will be accompanied by renaming, so a mismatch will cause unresolved

symbols rather than perhaps mysterious misbehaviour. In general `libgmpxx.la' will be usable only with the C++ compiler that built it,since name mangling and runtime support are usually incompatible between different

compilers. `CXX', `CXXFLAGS'When C

++ support is enabled, the C++ compiler and its flags can be set with vari-ables ` CXX' and `CXXFLAGS' in the usual way. The default for `CXX' is the first compilerthat works from a list of likely candidates, with

g++ normally preferred when avail-able. The default for ` CXXFLAGS' is to try `CFLAGS', `CFLAGS' without `-g', then for g++ either `-g -O2' or `-O2', or for other compilers `-g' or nothing. Trying `CFLAGS'this way is convenient when using `

gcc' and `g++' together, since the flags for `gcc'will usually suit ` g++'.

It's important that the C and C++ compilers match, meaning their startup andruntime support routines are compatible and that they generate code in the same

ABI (if there's a choice of ABIs on the system). `./configure' isn't currently able tocheck these things very well itself, so for that reason `

--disable-cxx' is the default,to avoid a build failure due to a compiler mismatch. Perhaps this will change in the

future. Incidentally, it's normally not good enough to set `CXX' to the same as `CC'. Although gcc for instance recognises `foo.cc' as C++ code, only g++ will invoke the linker theright way when building an executable or shared library from C

++ object files.

Chapter 2: Installing GMP 7 Temporary Memory, `--enable-alloca=<choice>'GMP allocates temporary workspace using one of the following three methods, which

can be selected with for instance `--enable-alloca=malloc-reentrant'.*

`alloca' - C library or compiler builtin.* `malloc-reentrant' - the heap, in a re-entrant fashion.* `malloc-notreentrant' - the heap, with global variables.

For convenience, the following choices are also available. `--disable-alloca' is thesame as `

no'.*

`yes' - a synonym for `alloca'.* `no' - a synonym for `malloc-reentrant'.* `reentrant' - alloca if available, otherwise `malloc-reentrant'. This is thedefault.

* `notreentrant' - alloca if available, otherwise `malloc-notreentrant'. alloca is reentrant and fast, and is recommended. It actually allocates just smallblocks on the stack; larger ones use malloc-reentrant.

`malloc-reentrant' is, as the name suggests, reentrant and thread safe, but`

malloc-notreentrant' is faster and should be used if reentrancy is not required.

The two malloc methods in fact use the memory allocation functions selected by mp_ set_memory_functions, these being malloc and friends by default. See Chapter 14[Custom Allocation], page 85.

An additional choice `--enable-alloca=debug' is available, to help when debuggingmemory related problems (see Section 3.12 [Debugging], page 23).

FFT Multiplication, `--disable-fft'By default multiplications are done using Karatsuba, 3-way Toom, and Fermat FFT.

The FFT is only used on large to very large operands and can be disabled to savecode size if desired.

Berkeley MP, `--enable-mpbsd'The Berkeley MP compatibility library (`

libmp') and header file (`mp.h') are builtand installed only if ` --enable-mpbsd' is used. See Chapter 13 [BSD CompatibleFunctions], page 83.

Assertion Checking, `--enable-assert'This option enables some consistency checking within the library. This can be of

use while debugging, see Section 3.12 [Debugging], page 23. Execution Profiling, `--enable-profiling=prof/gprof/instrument'Enable profiling support, in one of various styles, see Section 3.13 [Profiling], page 25.

`MPN_PATH' Various assembly versions of each mpn subroutines are provided. For a given CPU,

a search is made though a path to choose a version of each. For example `sparcv8'has

MPN_PATH="sparc32/v8 sparc32 generic" which means look first for v8 code, then plain sparc32 (which is v7), and finallyfall back on generic C. Knowledgeable users with special requirements can specify

a different path. Normally this is completely unnecessary. DocumentationThe source for the document you're now reading is `

doc/gmp.texi', in Texinfoformat, see Texinfo.

8 GNU MP 4.2.3

Info format `doc/gmp.info' is included in the distribution. The usual automaketargets are available to make PostScript, DVI, PDF and HTML (these will require various TEX and Texinfo tools). DocBook and XML can be generated by the Texinfo makeinfo program too, seeSection "Options for

makeinfo" in Texinfo.

Some supplementary notes can also be found in the `doc' subdirectory.

2.2 ABI and ISA ABI (Application Binary Interface) refers to the calling conventions between functions, meaningwhat registers are used and what sizes the various C data types are. ISA (Instruction Set

Architecture) refers to the instructions and registers a CPU has available. Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI defined, the latter for com-patibility with older CPUs in the family. GMP supports some CPUs like this in both ABIs. In

fact within GMP `ABI' means a combination of chip ABI, plus how GMP chooses to use it. Forexample in some 32-bit ABIs, GMP may support a limb as either a 32-bit

long or a 64-bit long long.

By default GMP chooses the best ABI available for a given system, and this generally givessignificantly greater speed. But an ABI can be chosen explicitly to make GMP compatible with

other libraries, or particular application requirements. For example,

./configure ABI=32 In all cases it's vital that all object code used in a given program is compiled for the same ABI. Usually a limb is implemented as a long. When a long long limb is used this is encoded inthe generated `

gmp.h'. This is convenient for applications, but it does mean that `gmp.h' willvary, and can't be just copied around. `

gmp.h' remains compiler independent though, since allcompilers for a particular ABI will be expected to use the same limb type.

Currently no attempt is made to follow whatever conventions a system has for installing libraryor header files built for a particular ABI. This will probably only matter when installing multiple builds of GMP, and it might be as simple as configuring with a special `libdir', or it mightrequire more than that. Note that builds for different ABIs need to done separately, with a fresh ./configure and make each.

AMD64 (`x86_64')On AMD64 systems supporting both 32-bit and 64-bit modes for applications, the

following ABI choices are available. `ABI=64' The 64-bit ABI uses 64-bit limbs and pointers and makes full use ofthe chip architecture. This is the default. Applications will usually not

need special compiler flags, but for reference the option is

gcc -m64

`ABI=32' The 32-bit ABI is the usual i386 conventions. This will be slower, andis not recommended except for inter-operating with other code not yet

64-bit capable. Applications must be compiled with

gcc -m32 (In GCC 2.95 and earlier there's no `-m32' option, it's the only mode.)

Chapter 2: Installing GMP 9 HPPA 2.0 (`hppa2.0*', `hppa64')

`ABI=2.0w' The 2.0w ABI uses 64-bit limbs and pointers and is available on HP-UX

11 or up. Applications must be compiled with

gcc [built for 2.0w] cc +DD64

`ABI=2.0n' The 2.0n ABI means the 32-bit HPPA 1.0 ABI and all its normal calling

conventions, but with 64-bit instructions permitted within functions.GMP uses a 64-bit

long long for a limb. This ABI is available onhppa64 GNU/Linux and on HP-UX 10 or higher. Applications must be

compiled with

gcc [built for 2.0n] cc +DA2.0 +e

Note that current versions of GCC (eg. 3.2) don't generate 64-bit in-structions for

long long operations and so may be slower than for 2.0w.(The GMP assembly code is the same though.)

`ABI=1.0' HPPA 2.0 CPUs can run all HPPA 1.0 and 1.1 code in the 32-bit HPPA1.0 ABI. No special compiler options are needed for applications. All three ABIs are available for CPU types `hppa2.0w', `hppa2.0' and `hppa64', butfor CPU type `

hppa2.0n' only 2.0n or 1.0 are considered.

Note that GCC on HP-UX has no options to choose between 2.0n and 2.0w modes,unlike HP

cc. Instead it must be built for one or the other ABI. GMP will detecthow it was built, and skip to the corresponding `

ABI'.

IA-64 under HP-UX (`ia64*-*-hpux*', `itanium*-*-hpux*')HP-UX supports two ABIs for IA-64. GMP performance is the same in both.

`ABI=32' In the 32-bit ABI, pointers, ints and longs are 32 bits and GMP usesa 64 bit

long long for a limb. Applications can be compiled withoutany special flags since this ABI is the default in both HP C and GCC,

but for reference the flags are

gcc -milp32 cc +DD32

`ABI=64' In the 64-bit ABI, longs and pointers are 64 bits and GMP uses a longfor a limb. Applications must be compiled with

gcc -mlp64 cc +DD64

On other IA-64 systems, GNU/Linux for instance, `ABI=64' is the only choice.

MIPS under IRIX 6 (`mips*-*-irix[6789]')IRIX 6 always has a 64-bit MIPS 3 or better CPU, and supports ABIs o32, n32,

and 64. n32 or 64 are recommended, and GMP performance will be the same ineach. The default is n32.

`ABI=o32' The o32 ABI is 32-bit pointers and integers, and no 64-bit operations.GMP will be slower than in n32 or 64, this option only exists to support

old compilers, eg. GCC 2.7.2. Applications can be compiled with nospecial flags on an old compiler, or on a newer compiler with

10 GNU MP 4.2.3

gcc -mabi=32 cc -32

`ABI=n32' The n32 ABI is 32-bit pointers and integers, but with a 64-bit limbusing a

long long. Applications must be compiled with

gcc -mabi=n32 cc -n32

`ABI=64' The 64-bit ABI is 64-bit pointers and integers. Applications must becompiled with

gcc -mabi=64 cc -64

Note that MIPS GNU/Linux, as of kernel version 2.2, doesn't have the necessarysupport for n32 or 64 and so only gets a 32-bit limb and the MIPS 2 code.

PowerPC 64 (`powerpc64', `powerpc620', `powerpc630', `powerpc970', `power4', `power5')

`ABI=aix64'The AIX 64 ABI uses 64-bit limbs and pointers and is the default on

PowerPC 64 `*-*-aix*' systems. Applications must be compiled with

gcc -maix64 xlc -q64

`ABI=mode64'The `

mode64' ABI uses 64-bit limbs and pointers, and is the default on64-bit GNU/Linux, BSD, and Mac OS X/Darwin systems. Applications

must be compiled with

gcc -m64

`ABI=mode32'The `

mode32' ABI uses a 64-bit long long limb but with the chip stillin 32-bit mode and using 32-bit calling conventions. This is the default

on for systems where the true 64-bit ABIs are unavailable. No specialcompiler options are needed for applications.

`ABI=32' This is the basic 32-bit PowerPC ABI, with a 32-bit limb. No specialcompiler options are needed for applications. GMP speed is greatest in `aix64' and `mode32'. In `ABI=32' only the 32-bit ISA isused and this doesn't make full use of a 64-bit chip. On a suitable system we could perhaps use more of the ISA, but there are no plans to do so.

Sparc V9 (`sparc64', `sparcv9', `ultrasparc*')

`ABI=64' The 64-bit V9 ABI is available on the various BSD sparc64 ports, recentversions of Sparc64 GNU/Linux, and Solaris 2.7 and up (when the kernel

is in 64-bit mode). GCC 3.2 or higher, or Sun cc is required. OnGNU/Linux, depending on the default

gcc mode, applications must becompiled with

gcc -m64 On Solaris applications must be compiled with

gcc -m64 -mptr64 -Wa,-xarch=v9 -mcpu=v9 cc -xarch=v9

On the BSD sparc64 systems no special options are required, since 64-bits is the only ABI available.

Chapter 2: Installing GMP 11

`ABI=32' For the basic 32-bit ABI, GMP still uses as much of the V9 ISA as itcan. In the Sun documentation this combination is known as "v8plus".

On GNU/Linux, depending on the default gcc mode, applications mayneed to be compiled with

gcc -m32 On Solaris, no special compiler options are required for applications,though using something like the following is recommended. (

gcc 2.8and earlier only support ` -mv8' though.)

gcc -mv8plus cc -xarch=v8plus

GMP speed is greatest in `ABI=64', so it's the default where available. The speedis partly because there are extra registers available and partly because 64-bits is

considered the more important case and has therefore had better code written forit.

Don't be confused by the names of the `-m' and `-x' compiler options, they're called`

arch' but effectively control both ABI and ISA.

On Solaris 2.6 and earlier, only `ABI=32' is available since the kernel doesn't saveall registers.

On Solaris 2.7 with the kernel in 32-bit mode, a normal native build will reject`

ABI=64' because the resulting executables won't run. `ABI=64' can still be built ifdesired by making it look like a cross-compile, for example

./configure --build=none --host=sparcv9-sun-solaris2.7 ABI=64 2.3 Notes for Package Builds GMP should present no great difficulties for packaging in a binary distribution.

Libtool is used to build the library and `-version-info' is set appropriately, having startedfrom `

3:0:0' in GMP 3.0 (see Section "Library interface versions" in GNU Libtool).

The GMP 4 series will be upwardly binary compatible in each release and will be upwardlybinary compatible with all of the GMP 3 series. Additional function interfaces may be added

in each release, so on systems where libtool versioning is not fully checked by the loader anauxiliary mechanism may be needed to express that a dynamic linked application depends on a new enough GMP. An auxiliary mechanism may also be needed to express that `libgmpxx.la' (from`

--enable-cxx', see Section 2.1 [Build Options], page 3) requires `libgmp.la' from the sameGMP version, since this is not done by the libtool versioning, nor otherwise. A mismatch will

result in unresolved symbols from the linker, or perhaps the loader. When building a package for a CPU family, care should be taken to use `--host' (or `--build')to choose the least common denominator among the CPUs which might use the package. For

example this might mean plain `sparc' (meaning V7) for SPARCs. For x86s, `--enable-fat' sets things up for a fat binary build, making a runtime selection ofoptimized low level routines. This is a good choice for packaging to run on a range of x86 chips.

Users who care about speed will want GMP built for their exact CPU type, to make best useof the available optimizations. Providing a way to suitably rebuild a package may be useful. This could be as simple as making it possible for a user to omit `--build' (and `--host') so`

./config.guess' will detect the CPU. But a way to manually specify a `--build' will bewanted for systems where `

./config.guess' is inexact.

12 GNU MP 4.2.3 On systems with multiple ABIs, a packaged build will need to decide which among the choicesis to be provided, see Section 2.2 [ABI and ISA], page 8. A given run of `

./configure' etc willonly build one ABI. If a second ABI is also required then a second run of `

./configure' etcmust be made, starting from a clean directory tree (` make distclean').

As noted under "ABI and ISA", currently no attempt is made to follow system conventions forinstall locations that vary with ABI, such as `

/usr/lib/sparcv9' for `ABI=64' as opposed to` /usr/lib' for `ABI=32'. A package build can override `libdir' and other standard variables asnecessary.

Note that `gmp.h' is a generated file, and will be architecture and ABI dependent. Whenattempting to install two ABIs simultaneously it will be important that an application compile gets the correct `gmp.h' for its desired ABI. If compiler include paths don't vary with ABIoptions then it might be necessary to create a `

/usr/include/gmp.h' which tests preprocessorsymbols and chooses the correct actual ` gmp.h'.

2.4 Notes for Particular Systems AIX 3 and 4On systems `

*-*-aix[34]*' shared libraries are disabled by default, since someversions of the native

ar fail on the convenience libraries used. A shared build canbe attempted with

./configure --enable-shared --disable-static Note that the `--disable-static' is necessary because in a shared build libtoolmakes `

libgmp.a' a symlink to `libgmp.so', apparently for the benefit of old ver-sions of

ld which only recognise `.a', but unfortunately this is done even if a fullyfunctional

ld is available.

ARM On systems `arm*-*-*', versions of GCC up to and including 2.95.3 have a bug inunsigned division, giving wrong results for some operands. GMP `

./configure' willdemand GCC 2.95.4 or later.

Compaq C++Compaq C

++ on OSF 5.1 has two flavours of iostream, a standard one and an oldpre-standard one (see `

man iostream_intro'). GMP can only use the standard one,which unfortunately is not the default but must be selected by defining

__USE_STD_ IOSTREAM. Configure with for instance

./configure --enable-cxx CPPFLAGS=-D__USE_STD_IOSTREAM

Floating Point ModeOn some systems, the hardware floating point has a control mode which can set

all operations to be done in a particular precision, for instance single, double orextended on x86 systems (x87 floating point). The GMP functions involving a double cannot be expected to operate to their full precision when the hardware isin single precision mode. Of course this affects all code, including application code, not just GMP. MacOS 9 The `macos' directory contains an unsupported port to MacOS 9 on Power Mac-intosh, see `

macos/README'. Note that MacOS X "Darwin" should use the normalUnix-style ` ./configure'.

MS-DOS and MS WindowsOn an MS-DOS system DJGPP can be used to build GMP, and on an MS Windows

system Cygwin, DJGPP and MINGW can be used. All three are excellent ports ofGCC and the various GNU tools.

Chapter 2: Installing GMP 13

http://www.cygwin.com/ http://www.delorie.com/djgpp/ http://www.mingw.org/

Microsoft also publishes an Interix "Services for Unix" which can be used to buildGMP on Windows (with a normal `

./configure'), but it's not free software.

MS Windows DLLsOn systems `

*-*-cygwin*', `*-*-mingw*' and `*-*-pw32*' by default GMP buildsonly a static library, but a DLL can be built instead using

./configure --disable-static --enable-shared Static and DLL libraries can't both be built, since certain export directives in `gmp.h'must be different.

A MINGW DLL build of GMP can be used with Microsoft C. Libtool doesn't installa `

.lib' format import library, but it can be created with MS lib as follows, andcopied to the install directory. Similarly for `

libmp' and `libgmpxx'.

cd .libs lib /def:libgmp-3.dll.def /out:libgmp-3.lib

MINGW uses the C runtime library `msvcrt.dll' for I/O, so applications wantingto use the GMP I/O routines must be compiled with `

cl /MD' to do the same. Ifone of the other C runtime library choices provided by MS C is desired then the

suggestion is to use the GMP string functions and confine I/O to the application. Motorola 68k CPU Types`

m68k' is taken to mean 68000. `m68020' or higher will give a performance boost onapplicable CPUs. `

m68360' can be used for CPU32 series chips. `m68302' can beused for "Dragonball" series chips, though this is merely a synonym for `

m68000'.

OpenBSD 2.6

m4 in this release of OpenBSD has a bug in eval that makes it unsuitable for `.asm'file processing. `

./configure' will detect the problem and either abort or chooseanother m4 in the

PATH. The bug is fixed in OpenBSD 2.7, so either upgrade or useGNU m4.

Power CPU TypesIn GMP, CPU types `

power*' and `powerpc*' will each use instructions not availableon the other, so it's important to choose the right one for the CPU that will be

used. Currently GMP has no assembly code support for using just the commoninstruction subset. To get executables that run on both, the current suggestion is to use the generic C code (CPU `none'), possibly with appropriate compiler options(like `

-mcpu=common' for gcc). CPU `rs6000' (which is not a CPU but a family ofworkstations) is accepted by `

config.sub', but is currently equivalent to `none'.

Sparc CPU Types`

sparcv8' or `supersparc' on relevant systems will give a significant performanceincrease over the V7 code selected by plain `

sparc'.

Sparc App RegsThe GMP assembly code for both 32-bit and 64-bit Sparc clobbers the "application

registers" g2, g3 and g4, the same way that the GCC default `-mapp-regs' does(see Section "SPARC Options" in

Using the GNU Compiler Collection (GCC)).

This makes that code unsuitable for use with the special V9 `-mcmodel=embmedany'(which uses

g4 as a data segment pointer), and for applications wanting to use thoseregisters for special purposes. In these cases the only suggestion currently is to build

GMP with CPU `none' to avoid the assembly code.

14 GNU MP 4.2.3 SunOS 4 /usr/bin/m4 lacks various features needed to process `.asm' files, and instead`

./configure' will automatically use /usr/5bin/m4, which we believe is alwaysavailable (if not then use GNU m4).

x86 CPU Types`

i586', `pentium' or `pentiummmx' code is good for its intended P5 Pentium chips,but quite slow when run on Intel P6 class chips (PPro, P-II, P-III). `

i386' is abetter choice when making binaries that must run on both.

x86 MMX and SSE2 CodeIf the CPU selected has MMX code but the assembler doesn't support it, a warning

is given and non-MMX code is used instead. This will be an inferior build, since theMMX code that's present is there because it's faster than the corresponding plain integer code. The same applies to SSE2. Old versions of `gas' don't support MMX instructions, in particular version 1.92.3that comes with FreeBSD 2.2.8 or the more recent OpenBSD 3.1 doesn't.

Solaris 2.6 and 2.7 as generate incorrect object code for register to register movqinstructions, and so can't be used for MMX code. Install a recent

gas if MMX codeis wanted on these systems.

2.5 Known Build Problems You might find more up-to-date information at http://gmplib.org/.

Compiler link optionsThe version of libtool currently in use rather aggressively strips compiler options

when linking a shared library. This will hopefully be relaxed in the future, but fornow if this is a problem the suggestion is to create a little script to hide them, and for instance configure with

./configure CC=gcc-with-my-options

DJGPP (`*-*-msdosdjgpp*')The DJGPP port of

bash 2.03 is unable to run the `configure' script, it exitssilently, having died writing a preamble to `

config.log'. Use bash 2.04 or higher.

`make all' was found to run out of memory during the final `libgmp.la' link on onesystem tested, despite having 64Mb available. Running `

make libgmp.la' directlyhelped, perhaps recursing into the various subdirectories uses up memory.

GNU binutils strip prior to 2.12

strip from GNU binutils 2.11 and earlier should not be used on the static libraries`

libgmp.a' and `libmp.a' since it will discard all but the last of multiple archivemembers with the same name, like the three versions of `

init.o' in `libgmp.a'.Binutils 2.12 or higher can be used successfully.

The shared libraries `libgmp.so' and `libmp.so' are not affected by this and anyversion of

strip can be used on them.

make syntax errorOn certain versions of SCO OpenServer 5 and IRIX 6.5 the native

make is unableto handle the long dependencies list for ` libgmp.la'. The symptom is a "syntaxerror" on the following line of the top-level `

Makefile'.

libgmp.la: $(libgmp_la_OBJECTS) $(libgmp_la_DEPENDENCIES) Either use GNU Make, or as a workaround remove $(libgmp_la_DEPENDENCIES)from that line (which will make the initial build work, but if any recompiling is done

`libgmp.la' might not be rebuilt).

Chapter 2: Installing GMP 15 MacOS X (`*-*-darwin*')Libtool currently only knows how to create shared libraries on MacOS X using the

native cc (which is a modified GCC), not a plain GCC. A static-only build shouldwork though (`

--disable-shared').

NeXT prior to 3.3The system compiler on old versions of NeXT was a massacred and old GCC, even

if it called itself `cc'. This compiler cannot be used to build GMP, you need toget a real GCC, and install that. (NeXT may have fixed this in release 3.3 of their system.) POWER and PowerPCBugs in GCC 2.7.2 (and 2.6.3) mean it can't be used to compile GMP on POWER

or PowerPC. If you want to use GCC for these machines, get GCC 2.7.2.1 (or later). Sequent SymmetryUse the GNU assembler instead of the system assembler, since the latter has serious

bugs. Solaris 2.6 The system sed prints an error "Output line too long" when libtool builds`

libgmp.la'. This doesn't seem to cause any obvious ill effects, but GNU sedis recommended, to avoid any doubt.

Sparc Solaris 2.7 with gcc 2.95.2 in `ABI=32'A shared library build of GMP seems to fail in this combination, it builds but

then fails the tests, apparently due to some incorrect data relocations within gmp_ randinit_lc_2exp_size. The exact cause is unknown, `--disable-shared' is rec-ommended.

2.6 Performance optimization For optimal performance, build GMP for the exact CPU type of the target computer, seeSection 2.1 [Build Options], page 3.

Unlike what is the case for most other programs, the compiler typically doesn't matter much,since GMP uses assembly language for the most critical operation. In particular for long-running GMP applications, and applications demanding extremely largenumbers, building and running the

tuneup program in the `tune' subdirectory, can be important.For example,

cd tune make tuneup ./tuneup

will generate better contents for the `gmp-mparam.h' parameter file. To use the results, put the output in the file file indicated in the `Parameters for ...' header.Then recompile from scratch.

The tuneup program takes one useful parameter, `-f NNN', which instructs the program how longto check FFT multiply parameters. If you're going to use GMP for extremely large numbers, you may want to run tuneup with a large NNN value.

16 GNU MP 4.2.3 3 GMP Basics Using functions, macros, data types, etc. not documented in this manual is strongly discouraged. If you do so your application is guaranteed to be incompatible with future versions of GMP.

3.1 Headers and Libraries All declarations needed to use GMP are collected in the include file `gmp.h'. It is designed towork with both C and C

++ compilers.

#include <gmp.h> Note however that prototypes for GMP functions with FILE * parameters are only provided if <stdio.h> is included too.

#include <stdio.h> #include <gmp.h>

Likewise <stdarg.h> (or <varargs.h>) is required for prototypes with va_list parameters,such as

gmp_vprintf. And <obstack.h> for prototypes with struct obstack parameters, suchas gmp_obstack_printf, when available.

All programs using GMP must link against the `libgmp' library. On a typical Unix-like systemthis can be done with `

-lgmp', for example

gcc myprogram.c -lgmp GMP C++ functions are in a separate `libgmpxx' library. This is built and installed if C++support has been enabled (see Section 2.1 [Build Options], page 3). For example,

g++ mycxxprog.cc -lgmpxx -lgmp GMP is built using Libtool and an application can use that to link if desired, see GNU Libtool . If GMP has been installed to a non-standard location then it may be necessary to use `-I' and`

-L' compiler options to point to the right directories, and some sort of run-time path for ashared library.

3.2 Nomenclature and Types In this manual, integer usually means a multiple precision integer, as defined by the GMPlibrary. The C data type for such integers is

mpz_t. Here are some examples of how to declaresuch integers:

mpz_t sum; struct foo { mpz_t x, y; }; mpz_t vec[20]; Rational number means a multiple precision fraction. The C data type for these fractions is mpq_t. For example:

mpq_t quotient; Floating point number or Float for short, is an arbitrary precision mantissa with a limitedprecision exponent. The C data type for such objects is

mpf_t. For example:

mpf_t fp;

Chapter 3: GMP Basics 17 The floating point functions accept and return exponents in the C type mp_exp_t. Currentlythis is usually a

long, but on some systems it's an int for efficiency.

A limb means the part of a multi-precision number that fits in a single machine word. (We chosethis word because a limb of the human body is analogous to a digit, only larger, and containing

several digits.) Normally a limb is 32 or 64 bits. The C data type for a limb is mp_limb_t. Counts of limbs are represented in the C type mp_size_t. Currently this is normally a long,but on some systems it's an

int for efficiency.

Random state means an algorithm selection and current state data. The C data type for suchobjects is

gmp_randstate_t. For example:

gmp_randstate_t rstate; Also, in general unsigned long is used for bit counts and ranges, and size_t is used for byteor character counts.

3.3 Function Classes There are six classes of functions in the GMP library:

1. Functions for signed integer arithmetic, with names beginning with mpz_. The associatedtype is

mpz_t. There are about 150 functions in this class. (see Chapter 5 [Integer Func-tions], page 29)

2. Functions for rational number arithmetic, with names beginning with mpq_. The associatedtype is

mpq_t. There are about 40 functions in this class, but the integer functions can beused for arithmetic on the numerator and denominator separately. (see Chapter 6 [Rational

Number Functions], page 44) 3. Functions for floating-point arithmetic, with names beginning with mpf_. The associatedtype is

mpf_t. There are about 60 functions is this class. (see Chapter 7 [Floating-pointFunctions], page 48)

4. Functions compatible with Berkeley MP, such as itom, madd, and mult. The associatedtype is

MINT. (see Chapter 13 [BSD Compatible Functions], page 83)

5. Fast low-level functions that operate on natural numbers. These are used by the functionsin the preceding groups, and you can also call them directly from very time-critical user

programs. These functions' names begin with mpn_. The associated type is array of mp_ limb_t. There are about 30 (hard-to-use) functions in this class. (see Chapter 8 [Low-levelFunctions], page 56)

6. Miscellaneous functions. Functions for setting up custom allocation and functions for gen-erating random numbers. (see Chapter 14 [Custom Allocation], page 85, and see Chapter 9

[Random Number Functions], page 64)

3.4 Variable Conventions GMP functions generally have output arguments before input arguments. This notation is byanalogy with the assignment operator. The BSD MP compatibility functions are exceptions,

having the output arguments last. GMP lets you use the same variable for both input and output in one call. For example, themain function for integer multiplication,

mpz_mul, can be used to square x and put the resultback in x with

mpz_mul (x, x, x);

18 GNU MP 4.2.3 Before you can assign to a GMP variable, you need to initialize it by calling one of the specialinitialization functions. When you're done with a variable, you need to clear it out, using one of the functions for that purpose. Which function to use depends on the type of variable. Seethe chapters on integer functions, rational number functions, and floating-point functions for details. A variable should only be initialized once, or at least cleared between each initialization. Aftera variable has been initialized, it may be assigned to any number of times.

For efficiency reasons, avoid excessive initializing and clearing. In general, initialize near thestart of a function and clear near the end. For example,

void foo (void) {

mpz_t n; int i; mpz_init (n); for (i = 1; i < 100; i++)

{

mpz_mul (n, ...); mpz_fdiv_q (n, ...); ... } mpz_clear (n); }

3.5 Parameter Conventions When a GMP variable is used as a function parameter, it's effectively a call-by-reference, meaningif the function stores a value there it will change the original in the caller. Parameters which

are input-only can be designated const to provoke a compiler error or warning on attemptingto modify them.

When a function is going to return a GMP result, it should designate a parameter that it sets,like the library functions do. More than one value can be returned by having more than one output parameter, again like the library functions. A return of an mpz_t etc doesn't return theobject, only a pointer, and this is almost certainly not what's wanted.

Here's an example accepting an mpz_t parameter, doing a calculation, and storing the result tothe indicated parameter.

void foo (mpz_t result, const mpz_t param, unsigned long n) {

unsigned long i; mpz_mul_ui (result, param, n); for (i = 1; i < n; i++)

mpz_add_ui (result, result, i*7); }

int main (void) {

mpz_t r, n;

Chapter 3: GMP Basics 19

mpz_init (r); mpz_init_set_str (n, "123456", 0); foo (r, n, 20L); gmp_printf ("%Zd\n", r); return 0; }

foo works even if the mainline passes the same variable for param and result, just like thelibrary functions. But sometimes it's tricky to make that work, and an application might not

want to bother supporting that sort of thing. For interest, the GMP types mpz_t etc are implemented as one-element arrays of certain struc-tures. This is why declaring a variable creates an object with the fields GMP needs, but then

using it as a parameter passes a pointer to the object. Note that the actual fields in each mpz_tetc are for internal use only and should not be accessed directly by code that expects to be compatible with future GMP releases.

3.6 Memory Management The GMP types like mpz_t are small, containing only a couple of sizes, and pointers to allocateddata. Once a variable is initialized, GMP takes care of all space allocation. Additional space is

allocated whenever a variable doesn't have enough. mpz_t and mpq_t variables never reduce their allocated space. Normally this is the best policy,since it avoids frequent reallocation. Applications that need to return memory to the heap at

some particular point can use mpz_realloc2, or clear variables no longer needed. mpf_t variables, in the current implementation, use a fixed amount of space, determined by thechosen precision and allocated at initialization, so their size doesn't change.

All memory is allocated using malloc and friends by default, but this can be changed, seeChapter 14 [Custom Allocation], page 85. Temporary memory on the stack is also used (via alloca), but this can be changed at build-time if desired, see Section 2.1 [Build Options], page 3.

3.7 Reentrancy GMP is reentrant and thread-safe, with some exceptions:

* If configured with `--enable-alloca=malloc-notreentrant' (or with`

--enable-alloca=notreentrant' when alloca is not available), then naturallyGMP is not reentrant.

* mpf_set_default_prec and mpf_init use a global variable for the selected precision. mpf_

init2 can be used instead, and in the C++ interface an explicit precision to the mpf_classconstructor.

* mpz_random and the other old random number functions use a global random state and arehence not reentrant. The newer random number functions that accept a

gmp_randstate_tparameter can be used instead.

* gmp_randinit (obsolete) returns an error indication through a global variable, which is notthread safe. Applications are advised to use

gmp_randinit_default or gmp_randinit_lc_ 2exp instead.*

mp_set_memory_functions uses global variables to store the selected memory allocationfunctions.

* If the memory allocation functions set by a call to mp_set_memory_functions (or mallocand friends by default) are not reentrant, then GMP will not be reentrant either.

20 GNU MP 4.2.3

* If the standard I/O functions such as fwrite are not reentrant then the GMP I/O functionsusing them will not be reentrant either.

* It's safe for two threads to read from the same GMP variable simultaneously, but it'snot safe for one to read while the another might be writing, nor for two threads to write

simultaneously. It's not safe for two threads to generate a random number from the same gmp_randstate_t simultaneously, since this involves an update of that variable.

3.8 Useful Macros and Constants

[Global Constant]const int mp_bits_per_limbThe number of bits per limb.

[Macro]__GNU_MP_VERSION [Macro] __GNU_MP_VERSION_MINOR [Macro] __GNU_MP_VERSION_PATCHLEVELThe major and minor GMP version, and patch level, respectively, as integers. For GMP i.j,

these numbers will be i, j, and 0, respectively. For GMP i.j.k, these numbers will be i, j, andk, respectively.

[Global Constant]const char * const gmp_versionThe GMP version number, as a null-terminated string, in the form "i.j" or "i.j.k". This release is "4.2.3".

3.9 Compatibility with older versions This version of GMP is upwardly binary compatible with all 4.x and 3.x versions, and upwardlycompatible at the source level with all 2.x versions, with the following exceptions.

* mpn_gcd had its source arguments swapped as of GMP 3.0, for consistency with other mpnfunctions.

* mpf_get_prec counted precision slightly differently in GMP 3.0 and 3.0.1, but in 3.1 re-verted to the 2.x style.

There are a number of compatibility issues between GMP 1 and GMP 2 that of course alsoapply when porting applications from GMP 1 to GMP 4. Please see the GMP 2 manual for details. The Berkeley MP compatibility library (see Chapter 13 [BSD Compatible Functions], page 83)is source and binary compatible with the standard `

libmp'.

3.10 Demonstration programs The `demos' subdirectory has some sample programs using GMP. These aren't built or installed,but there's a `

Makefile' with rules for them. For instance,

make pexpr ./pexpr 68^975+10

The following programs are provided

* `pexpr' is an expression evaluator, the program used on the GMP web page.*

The `calc' subdirectory has a similar but simpler evaluator using lex and yacc.* The `expr' subdirectory is yet another expression evaluator, a library designed for ease ofuse within a C program. See `

demos/expr/README' for more information.

Chapter 3: GMP Basics 21

* `factorize' is a Pollard-Rho factorization program.*

`isprime' is a command-line interface to the mpz_probab_prime_p function.* `primes' counts or lists primes in an interval, using a sieve.* `qcn' is an example use of mpz_kronecker_ui to estimate quadratic class numbers.* The `perl' subdirectory is a comprehensive perl interface to GMP. See`

demos/perl/INSTALL' for more information. Documentation is in POD formatin `

demos/perl/GMP.pm'.

As an aside, consideration has been given at various times to some sort of expression evaluationwithin the main GMP library. Going beyond something minimal quickly leads to matters like

user-defined functions, looping, fixnums for control variables, etc, which are considered outsidethe scope of GMP (much closer to language interpreters or compilers, See Chapter 15 [Language Bindings], page 87.) Something simple for program input convenience may yet be a possibility,a combination of the `

expr' demo and the `pexpr' tree back-end perhaps. But for now the aboveevaluators are offered as illustrations.

3.11 Efficiency Small OperandsOn small operands, the time for function call overheads and memory allocation can

be significant in comparison to actual calculation. This is unavoidable in a generalpurpose variable precision library, although GMP attempts to be as efficient as it can on both large and small operands. Static LinkingOn some CPUs, in particular the x86s, the static `

libgmp.a' should be used formaximum speed, since the PIC code in the shared `

libgmp.so' will have a smalloverhead on each function call and global data address. For many programs this

will be insignificant, but for long calculations there's a gain to be had. Initializing and ClearingAvoid excessive initializing and clearing of variables, since this can be quite time

consuming, especially in comparison to otherwise fast operations like addition. A language interpreter might want to keep a free list or stack of initialized variablesready for use. It should be possible to integrate something like that with a garbage

collector too. ReallocationsAn

mpz_t or mpq_t variable used to hold successively increasing values will haveits memory repeatedly

realloced, which could be quite slow or could fragmentmemory, depending on the C library. If an application can estimate the final size

then mpz_init2 or mpz_realloc2 can be called to allocate the necessary space fromthe beginning (see Section 5.1 [Initializing Integers], page 29). It doesn't matter if a size set with mpz_init2 or mpz_realloc2 is too small, since allfunctions will do a further reallocation if necessary. Badly overestimating memory required will waste space though. 2exp FunctionsIt's up to an application to call functions like

mpz_mul_2exp when appropriate.General purpose functions like mpz_mul make no attempt to identify powers of twoor other special forms, because such inputs will usually be very rare and testing

every time would be wasteful. ui and si FunctionsThe

ui functions and the small number of si functions exist for convenience andshould be used where applicable. But if for example an

mpz_t contains a value that

22 GNU MP 4.2.3

fits in an unsigned long there's no need extract it and call a ui function, just usethe regular

mpz function.

In-Place Operations

mpz_abs, mpq_abs, mpf_abs, mpz_neg, mpq_neg and mpf_neg are fast when used forin-place operations like

mpz_abs(x,x), since in the current implementation only asingle field of x needs changing. On suitable compilers (GCC for instance) this isinlined too.

mpz_add_ui, mpz_sub_ui, mpf_add_ui and mpf_sub_ui benefit from an in-placeoperation like

mpz_add_ui(x,x,y), since usually only one or two limbs of x willneed to be changed. The same applies to the full precision

mpz_add etc if y is small.If y is big then cache locality may be helped, but that's all.

mpz_mul is currently the opposite, a separate destination is slightly better. A calllike

mpz_mul(x,x,y) will, unless y is only one limb, make a temporary copy of xbefore forming the result. Normally that copying will only be a tiny fraction of the

time for the multiply, so this is not a particularly important consideration. mpz_set, mpq_set, mpq_set_num, mpf_set, etc, make no attempt to recognise acopy of something to itself, so a call like

mpz_set(x,x) will be wasteful. Naturallythat would never be written deliberately, but if it might arise from two pointers to

the same object then a test to avoid it might be desirable.

if (x != y)

mpz_set (x, y);

Note that it's never worth introducing extra mpz_set calls just to get in-place op-erations. If a result should go to a particular variable then just direct it there and

let GMP take care of data movement. Divisibility Testing (Small Integers)

mpz_divisible_ui_p and mpz_congruent_ui_p are the best functions for testingwhether an

mpz_t is divisible by an individual small integer. They use an algorithmwhich is faster than

mpz_tdiv_ui, but which gives no useful information about theactual remainder, only whether it's zero (or a particular value).

However when testing divisibility by several small integers, it's best to take a re-mainder modulo their product, to save multi-precision operations. For instance to test whether a number is divisible by any of 23, 29 or 31 take a remainder modulo23 * 29 * 31 = 20677 and then test that.

The division functions like mpz_tdiv_q_ui which give a quotient as well as a re-mainder are generally a little slower than the remainder-only functions like

mpz_ tdiv_ui. If the quotient is only rarely wanted then it's probably best to just takea remainder and then go back and calculate the quotient if and when it's wanted

(mpz_divexact_ui can be used if the remainder is zero). Rational ArithmeticThe

mpq functions operate on mpq_t values with no common factors in the numeratorand denominator. Common factors are checked-for and cast out as necessary. In

general, cancelling factors every time is the best approach since it minimizes thesizes for subsequent operations.

However, applications that know something about the factorization of the valuesthey're working with might be able to avoid some of the GCDs used for canonicalization, or swap them for divisions. For example when multiplying by a prime it'senough to check for factors of it in the denominator instead of doing a full GCD. Or when forming a big product it might be known that very little cancellation willbe possible, and so canonicalization can be left to the end.

Chapter 3: GMP Basics 23

The mpq_numref and mpq_denref macros give access to the numerator and denom-inator to do things outside the scope of the supplied

mpq functions. See Section 6.5[Applying Integer Functions], page 46.

The canonical form for rationals allows mixed-type mpq_t and integer additions orsubtractions to be done directly with multiples of the denominator. This will be somewhat faster than mpq_add. For example,

/* mpq increment */ mpz_add (mpq_numref(q), mpq_numref(q), mpq_denref(q));

/* mpq += unsigned long */ mpz_addmul_ui (mpq_numref(q), mpq_denref(q), 123UL);

/* mpq -= mpz */ mpz_submul (mpq_numref(q), mpq_denref(q), z);

Number SequencesFunctions like

mpz_fac_ui, mpz_fib_ui and mpz_bin_uiui are designed for calcu-lating isolated values. If a range of values is wanted it's probably best to call to get

a starting point and iterate from there. Text Input/OutputHexadecimal or octal are suggested for input or output in text form. Power-of2 bases like these can be converted much more efficiently than other bases, likedecimal. For big numbers there's usually nothing of particular interest to be seen in the digits, so the base doesn't matter much. Maybe we can hope octal will one day become the normal base for everyday use, asproposed by King Charles XII of Sweden and later reformers.

3.12 Debugging Stack OverflowDepending on the system, a segmentation violation or bus error might be the only

indication of stack overflow. See `--enable-alloca' choices in Section 2.1 [BuildOptions], page 3, for how to address this.

In new enough versions of GCC, `-fstack-check' may be able to ensurean overflow is recognised by the system before too much damage is done, or `-fstack-limit-symbol' or `-fstack-limit-register' may be able to addchecking if the system itself doesn't do any (see Section "Options for Code Generation" in Using the GNU Compiler Collection (GCC)). These options mustbe added to the `

CFLAGS' used in the GMP build (see Section 2.1 [Build Options],page 3), adding them just to an application will have no effect. Note also they're a

slowdown, adding overhead to each function call and each stack allocation. Heap ProblemsThe most likely cause of application problems with GMP is heap corruption. Failing to init GMP variables will have unpredictable effects, and corruption arisingelsewhere in a program may well affect GMP. Initializing GMP variables more than once or failing to clear them will cause memory leaks. In all such cases a malloc debugger is recommended. On a GNU or BSD systemthe standard C library

malloc has some diagnostic facilities, see Section "AllocationDebugging" in The GNU C Library Reference Manual, or `man 3 malloc'. Otherpossibilities, in no particular order, include

http://www.inf.ethz.ch/personal/biere/projects/ccmalloc/

24 GNU MP 4.2.3

http://dmalloc.com/ http://www.perens.com/FreeSoftware/ (electric fence) http://packages.debian.org/stable/devel/fda http://www.gnupdate.org/components/leakbug/ http://people.redhat.com/~otaylor/memprof/ http://www.cbmamiga.demon.co.uk/mpatrol/

The GMP default allocation routines in `memory.c' also have a simple sentinelscheme which can be enabled with

#define DEBUG in that file. This is mainly de-signed for detecting buffer overruns during GMP development, but might find other

uses. Stack BacktracesOn some systems the compiler options GMP uses by default can interfere with

debugging. In particular on x86 and 68k systems `-fomit-frame-pointer' is usedand this generally inhibits stack backtracing. Recompiling without such options may help while debugging, though the usual caveats about it potentially moving amemory problem or hiding a compiler bug will apply.

GDB, the GNU DebuggerA sample `

.gdbinit' is included in the distribution, showing how to call some un-documented dump functions to print GMP variables from within GDB. Note that

these functions shouldn't be used in final application code since they're undocu-mented and may be subject to incompatible changes in future versions of GMP.

Source File PathsGMP has multiple source files with the same name, in different directories. For

example `mpz', `mpq' and `mpf' each have an `init.c'. If the debugger can't alreadydetermine the right one it may help to build with absolute paths on each C file. One way to do that is to use a separate object directory with an absolute path tothe source directory.

cd /my/build/dir /my/source/dir/gmp-4.2.3/configure

This works via VPATH, and might require GNU make. Alternately it might be possibleto change the

.c.lo rules appropriately.

Assertion CheckingThe build option `

--enable-assert' is available to add some consistency checksto the library (see Section 2.1 [Build Options], page 3). These are likely to be of

limited value to most applications. Assertion failures are just as likely to indicatememory corruption as a library or compiler bug. Applications using the low-level mpn functions, however, will benefit from`

--enable-assert' since it adds checks on the parameters of most such functions,many of which have subtle restrictions on their usage. Note however that only the

generic C code has checks, not the assembly code, so CPU `none' should be usedfor maximum checking.

Temporary Memory CheckingThe build option `

--enable-alloca=debug' arranges that each block of temporarymemory in GMP is allocated with a separate call to

malloc (or the allocationfunction set with mp_set_memory_functions).

This can help a malloc debugger detect accesses outside the intended bounds, ordetect memory not released. In a normal build, on the other hand, temporary

memory is allocated in blocks which GMP divides up for its own use, or may beallocated with a compiler builtin

alloca which will go nowhere near any mallocdebugger hooks.

Chapter 3: GMP Basics 25 Maximum DebuggabilityTo summarize the above, a GMP build for maximum debuggability would be

./configure --disable-shared --enable-assert \

--enable-alloca=debug --host=none CFLAGS=-g

For C++, add `--enable-cxx CXXFLAGS=-g'.

Checker The GCC checker (http://savannah.nongnu.org/projects/checker/) can beused with GMP. It contains a stub library which means GMP applications compiled

with checker can use a normal GMP build. A build of GMP with checking within GMP itself can be made. This will run veryvery slowly. On GNU/Linux for example,

./configure --host=none-pc-linux-gnu CC=checkergcc `--host=none' must be used, since the GMP assembly code doesn't support thechecking scheme. The GMP C

++ features cannot be used, since current versions ofchecker (0.9.9.1) don't yet support the standard C

++ library.

Valgrind The valgrind program (http://valgrind.org/) is a memory checker for x86s. Ittranslates and emulates machine instructions to do strong checks for uninitialized

data (at the level of individual bits), memory accesses through bad pointers, andmemory leaks.

Recent versions of Valgrind are getting support for MMX and SSE/SSE2 instruc-tions, for past versions GMP will need to be configured not to use those, ie. for an x86 without them (for instance plain `i486'). Other ProblemsAny suspected bug in GMP itself should be isolated to make sure it's not an application problem, see Chapter 4 [Reporting Bugs], page 28.

3.13 Profiling Running a program under a profiler is a good way to find where it's spending most time andwhere improvements can be best sought. The profiling choices for a GMP build are as follows.

`--disable-profiling'The default is to add nothing special for profiling.

It should be possible to just compile the mainline of a program with -p and use profto get a profile consisting of timer-based sampling of the program counter. Most of the GMP assembly code has the necessary symbol information. This approach has the advantage of minimizing interference with normal programoperation, but on most systems the resolution of the sampling is quite low (10

milliseconds for instance), requiring long runs to get accurate information. `--enable-profiling=prof'Build with support for the system

prof, which means `-p' added to the `CFLAGS'.

This provides call counting in addition to program counter sampling, which allowsthe most frequently called routines to be identified, and an average time spent in

each routine to be determined. The x86 assembly code has support for this option, but on other processors theassembly routines will be as if compiled without `

-p' and therefore won't appear inthe call counts.

On some systems, such as GNU/Linux, `-p' in fact means `-pg' and in this case`

--enable-profiling=gprof' described below should be used instead.

26 GNU MP 4.2.3 `--enable-profiling=gprof'Build with support for

gprof, which means `-pg' added to the `CFLAGS'.

This provides call graph construction in addition to call counting and programcounter sampling, which makes it possible to count calls coming from different locations. For example the number of calls to mpn_mul from mpz_mul versus the numberfrom

mpf_mul. The program counter sampling is still flat though, so only a totaltime in

mpn_mul would be accumulated, not a separate amount for each call site.

The x86 assembly code has support for this option, but on other processors theassembly routines will be as if compiled without `

-pg' and therefore not be includedin the call counts.

On x86 and m68k systems `-pg' and `-fomit-frame-pointer' are incompatible, sothe latter is omitted from the default flags in that case, which might result in poorer code generation. Incidentally, it should be possible to use the gprof program with a plain`

--enable-profiling=prof' build. But in that case only the `gprof -p' flat profileand call counts can be expected to be valid, not the `

gprof -q' call graph.

`--enable-profiling=instrument'Build with the GCC option `

-finstrument-functions' added to the `CFLAGS' (seeSection "Options for Code Generation" in

Using the GNU Compiler Collection (GCC)).

This inserts special instrumenting calls at the start and end of each function, allowingexact timing and full call graph construction.

This instrumenting is not normally a standard system feature and will require sup-port from an external library, such as

http://sourceforge.net/projects/fnccheck/ This should be included in `LIBS' during the GMP configure so that test programswill link. For example,

./configure --enable-profiling=instrument LIBS=-lfc On a GNU system the C library provides dummy instrumenting functions, so pro-grams compiled with this option will link. In this case it's only necessary to ensure

the correct library is added when linking an application. The x86 assembly code supports this option, but on other processors the assemblyroutines will be as if compiled without `

-finstrument-functions' meaning timespent in them will effectively be attributed to their caller.

3.14 Autoconf Autoconf based applications can easily check whether GMP is installed. The only thing to benoted is that GMP library symbols from version 3 onwards have prefixes like

__gmpz. Thefollowing therefore would be a simple test,

AC_CHECK_LIB(gmp, __gmpz_init) This just uses the default AC_CHECK_LIB actions for found or not found, but an application thatmust have GMP would want to generate an error if not found. For example,

AC_CHECK_LIB(gmp, __gmpz_init, ,

[AC_MSG_ERROR([GNU MP not found, see http://gmplib.org/])])

If functions added in some particular version of GMP are required, then one of those can beused when checking. For example

mpz_mul_si was added in GMP 3.1,

Chapter 3: GMP Basics 27

AC_CHECK_LIB(gmp, __gmpz_mul_si, ,

[AC_MSG_ERROR( [GNU MP not found, or not 3.1 or up, see http://gmplib.org/])])

An alternative would be to test the version number in `gmp.h' using say AC_EGREP_CPP. Thatwould make it possible to test the exact version, if some particular sub-minor release is known

to be necessary. In general it's recommended that applications should simply demand a new enough GMP ratherthan trying to provide supplements for features not available in past versions.

Occasionally an application will need or want to know the size of a type at configuration orpreprocessing time, not just with

sizeof in the code. This can be done in the normal waywith mp_limb_t etc, but GMP 4.0 or up is best for this, since prior versions needed certain `-D'defines on systems using a

long long limb. The following would suit Autoconf 2.50 or up,

AC_CHECK_SIZEOF(mp_limb_t, , [#include <gmp.h>])

3.15 Emacs C-H C-I (info-lookup-symbol) is a good way to find documentation on C functions whileediting (see Section "Info Documentation Lookup" in

The Emacs Editor).

The GMP manual can be included in such lookups by putting the following in your `.emacs',

(eval-after-load "info-look"

'(let ((mode-value (assoc 'c-mode (assoc 'symbol info-lookup-alist))))

(setcar (nthcdr 3 mode-value)

(cons '("(gmp)Function Index" nil "^ -.* " "\\>")

(nth 3 mode-value)))))

28 GNU MP 4.2.3 4 Reporting Bugs If you think you have found a bug in the GMP library, please investigate it and report it. Wehave made this library available to you, and it is not too much to ask you to report the bugs you find. Before you report a bug, check it's not already addressed in Section 2.5 [Known Build Problems],page 14, or perhaps Section 2.4 [Notes for Particular Systems], page 12. You may also want to

check http://gmplib.org/ for patches for this release. Please include the following in any report,

* The GMP version number, and if pre-packaged or patched then say so.*

A test program that makes it possible for us to reproduce the bug. Include instructions onhow to run the program.

* A description of what is wrong. If the results are incorrect, in what way. If you get a crash,say so.

* If you get a crash, include a stack backtrace from the debugger if it's informative (`where'in

gdb, or `$C' in adb).*

Please do not send core dumps, executables or straces.* The configuration options you used when building GMP, if any.* The name of the compiler and its version. For gcc, get the version with `gcc -v', otherwiseperhaps `

what `which cc`', or similar.*

The output from running `uname -a'.* The output from running `./config.guess', and from running `./configfsf.guess'(might be the same).

* If the bug is related to `configure', then the compressed contents of `config.log'.*

If the bug is related to an `asm' file not assembling, then the contents of `config.m4' andthe offending line or lines from the temporary `

mpn/tmp-<file>.s'.

Please make an effort to produce a self-contained report, with something definite that can betested or debugged. Vague queries or piecemeal messages are difficult to act on and don't help the development effort. It is not uncommon that an observed problem is actually due to a bug in the compiler; the GMPcode tends to explore interesting corners in compilers.

If your bug report is good, we will do our best to help you get a corrected version of the library;if the bug report is poor, we won't do anything about it (except maybe ask you to send a better report). Send your report to: gmp-bugs@swox.com. If you think something in this manual is unclear, or downright incorrect, or if the language needsto be improved, please send a note to the same address.

Chapter 5: Integer Functions 29 5 Integer Functions This chapter describes the GMP functions for performing integer arithmetic. These functionsstart with the prefix

mpz_.

GMP integers are stored in objects of type mpz_t.

5.1 Initialization Functions The functions for integer arithmetic assume that all integer objects are initialized. You do thatby calling the function

mpz_init. For example,

{

mpz_t integ; mpz_init (integ); ... mpz_add (integ, ...); ... mpz_sub (integ, ...);

/* Unless the program is about to exit, do ... */ mpz_clear (integ); }

As you can see, you can store new values any number of times, once an object is initialized.

[Function]void mpz_init (mpz t integer )Initialize integer, and set its value to 0.

[Function]void mpz_init2 (mpz t integer, unsigned long n )Initialize integer, with space for n bits, and set its value to 0.

n is only the initial space, integer will grow automatically in the normal way, if necessary,for subsequent values stored.

mpz_init2 makes it possible to avoid such reallocations if amaximum size is known in advance.

[Function]void mpz_clear (mpz t integer )Free the space occupied by integer. Call this function for all mpz_t variables when you aredone with them.

[Function]void mpz_realloc2 (mpz t integer, unsigned long n )Change the space allocated for integer to n bits. The value in integer is preserved if it fits,or is set to 0 if not.

This function can be used to increase the space for a variable in order to avoid repeatedautomatic reallocations, or to decrease it to give memory back to the heap.

5.2 Assignment Functions These functions assign new values to already initialized integers (see Section 5.1 [InitializingIntegers], page 29).

[Function]void mpz_set (mpz t rop, mpz t op ) [Function] void mpz_set_ui (mpz t rop, unsigned long int op ) [Function] void mpz_set_si (mpz t rop, signed long int op )

30 GNU MP 4.2.3

[Function]void mpz_set_d (mpz t rop, double op ) [Function] void mpz_set_q (mpz t rop, mpq t op ) [Function] void mpz_set_f (mpz t rop, mpf t op )Set the value of

rop from op.

mpz_set_d, mpz_set_q and mpz_set_f truncate op to make it an integer.

[Function]int mpz_set_str (mpz t rop, char *str, int base )Set the value of rop from str, a null-terminated C string in base base. White space is allowedin the string, and is simply ignored.

The base may vary from 2 to 62, or if base is 0, then the leading characters are used: 0x and 0X for hexadecimal, 0b and 0B for binary, 0 for octal, or decimal otherwise.

For bases up to 36, case is ignored; upper-case and lower-case letters have the same value. Forbases 37 to 62, upper-case letter represent the usual 10..35 while lower-case letter represent

36..61. This function returns 0 if the entire string is a valid number in base base. Otherwise it returns-1.

[Function]void mpz_swap (mpz t rop1, mpz t rop2 )Swap the values rop1 and rop2 efficiently.

5.3 Combined Initialization and Assignment Functions For convenience, GMP provides a parallel series of initialize-and-set functions which initialize theoutput and then store the value there. These functions' names have the form

mpz_init_set...

Here is an example of using one:

{

mpz_t pie; mpz_init_set_str (pie, "3141592653589793238462643383279502884", 10); ... mpz_sub (pie, ...); ... mpz_clear (pie); }

Once the integer has been initialized by any of the mpz_init_set... functions, it can be usedas the source or destination operand for the ordinary integer functions. Don't use an initializeand-set function on a variable already initialized!

[Function]void mpz_init_set (mpz t rop, mpz t op ) [Function] void mpz_init_set_ui (mpz t rop, unsigned long int op ) [Function] void mpz_init_set_si (mpz t rop, signed long int op ) [Function] void mpz_init_set_d (mpz t rop, double op )Initialize

rop with limb space and set the initial numeric value from op.

[Function]int mpz_init_set_str (mpz t rop, char *str, int base )Initialize rop and set its value like mpz_set_str (see its documentation above for details).

If the string is a correct base base number, the function returns 0; if an error occurs it returns-1.

rop is initialized even if an error occurs. (I.e., you have to call mpz_clear for it.)

Chapter 5: Integer Functions 31 5.4 Conversion Functions This section describes functions for converting GMP integers to standard C types. Functionsfor converting to GMP integers are described in Section 5.2 [Assigning Integers], page 29 and

Section 5.12 [I/O of Integers], page 39.

[Function]unsigned long int mpz_get_ui (mpz t op )Return the value of op as an unsigned long.

If op is too big to fit an unsigned long then just the least significant bits that do fit arereturned. The sign of

op is ignored, only the absolute value is used.

[Function]signed long int mpz_get_si (mpz t op )If op fits into a signed long int return the value of op. Otherwise return the least significantpart of

op, with the same sign as op.

If op is too big to fit in a signed long int, the returned result is probably not very useful.To find out if the value will fit, use the function

mpz_fits_slong_p.

[Function]double mpz_get_d (mpz t op )Convert op to a double, truncating if necessary (ie. rounding towards zero).

If the exponent from the conversion is too big, the result is system dependent. An infinity isreturned where available. A hardware overflow trap may or may not occur.

[Function]double mpz_get_d_2exp (signed long int *exp, mpz t op )Convert op to a double, truncating if necessary (ie. rounding towards zero), and returningthe exponent separately.

The return value is in the range 0.5 <= |d| < 1 and the exponent is stored to *exp . d * 2exp isthe (truncated)

op value. If op is zero, the return is 0.0 and 0 is stored to *exp .

This is similar to the standard C frexp function (see Section "Normalization Functions" in The GNU C Library Reference Manual).

[Function]char * mpz_get_str (char *str, int base, mpz t op )Convert op to a string of digits in base base. The base argument may vary from 2 to 62 orfrom -2 to -36.

For base in the range 2..36, digits and lower-case letters are used; for -2..-36, digits andupper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that significance order) are used. If str is NULL, the result string is allocated using the current allocation function (seeChapter 14 [Custom Allocation], page 85). The block will be

strlen(str)+1 bytes, thatbeing exactly enough for the string and null-terminator.

If str is not NULL, it should point to a block of storage large enough for the result, that being mpz_sizeinbase (op, base ) + 2. The two extra bytes are for a possible minus sign, and thenull-terminator.

A pointer to the result string is returned, being either the allocated block, or the given str.

32 GNU MP 4.2.3 5.5 Arithmetic Functions

[Function]void mpz_add (mpz t rop, mpz t op1, mpz t op2 ) [Function] void mpz_add_ui (mpz t rop, mpz t op1, unsigned long int op2 )Set

rop to op1 + op2.

[Function]void mpz_sub (mpz t rop, mpz t op1, mpz t op2 ) [Function] void mpz_sub_ui (mpz t rop, mpz t op1, unsigned long int op2 ) [Function] void mpz_ui_sub (mpz t rop, unsigned long int op1, mpz t op2 )Set

rop to op1 - op2.

[Function]void mpz_mul (mpz t rop, mpz t op1, mpz t op2 ) [Function] void mpz_mul_si (mpz t rop, mpz t op1, long int op2 ) [Function] void mpz_mul_ui (mpz t rop, mpz t op1, unsigned long int op2 )Set

rop to op1 * op2.

[Function]void mpz_addmul (mpz t rop, mpz t op1, mpz t op2 ) [Function] void mpz_addmul_ui (mpz t rop, mpz t op1, unsigned long int op2 )Set

rop to rop + op1 * op2.

[Function]void mpz_submul (mpz t rop, mpz t op1, mpz t op2 ) [Function] void mpz_submul_ui (mpz t rop, mpz t op1, unsigned long int op2 )Set

rop to rop - op1 * op2.

[Function]void mpz_mul_2exp (mpz t rop, mpz t op1, unsigned long int op2 )Set rop to op1 * 2op2. This operation can also be defined as a left shift by op2 bits.

[Function]void mpz_neg (mpz t rop, mpz t op )Set rop to -op.

[Function]void mpz_abs (mpz t rop, mpz t op )Set rop to the absolute value of op.

5.6 Division Functions Division is undefined if the divisor is zero. Passing a zero divisor to the division or modulofunctions (including the modular powering functions

mpz_powm and mpz_powm_ui), will cause anintentional division by zero. This lets a program handle arithmetic exceptions in these functions

the same way as for normal C int arithmetic.

[Function]void mpz_cdiv_q (mpz t q, mpz t n, mpz t d ) [Function] void mpz_cdiv_r (mpz t r, mpz t n, mpz t d ) [Function] void mpz_cdiv_qr (mpz t q, mpz t r, mpz t n, mpz t d ) [Function] unsigned long int mpz_cdiv_q_ui (mpz t q, mpz t n,

unsigned long int d ) [Function] unsigned long int mpz_cdiv_r_ui (mpz t r, mpz t n,

unsigned long int d ) [Function] unsigned long int mpz_cdiv_qr_ui (mpz t q, mpz t r, mpz t n ,

unsigned long int d ) [Function] unsigned long int mpz_cdiv_ui (mpz t n, unsigned long int d ) [Function] void mpz_cdiv_q_2exp (mpz t q, mpz t n, unsigned long int b )

Chapter 5: Integer Functions 33

[Function]void mpz_cdiv_r_2exp (mpz t r, mpz t n, unsigned long int b ) [Function]void mpz_fdiv_q (mpz t q, mpz t n, mpz t d ) [Function] void mpz_fdiv_r (mpz t r, mpz t n, mpz t d ) [Function] void mpz_fdiv_qr (mpz t q, mpz t r, mpz t n, mpz t d ) [Function] unsigned long int mpz_fdiv_q_ui (mpz t q, mpz t n,

unsigned long int d ) [Function] unsigned long int mpz_fdiv_r_ui (mpz t r, mpz t n,

unsigned long int d ) [Function] unsigned long int mpz_fdiv_qr_ui (mpz t q, mpz t r, mpz t n ,

unsigned long int d ) [Function] unsigned long int mpz_fdiv_ui (mpz t n, unsigned long int d ) [Function] void mpz_fdiv_q_2exp (mpz t q, mpz t n, unsigned long int b ) [Function] void mpz_fdiv_r_2exp (mpz t r, mpz t n, unsigned long int b )

[Function]void mpz_tdiv_q (mpz t q, mpz t n, mpz t d ) [Function] void mpz_tdiv_r (mpz t r, mpz t n, mpz t d ) [Function] void mpz_tdiv_qr (mpz t q, mpz t r, mpz t n, mpz t d ) [Function] unsigned long int mpz_tdiv_q_ui (mpz t q, mpz t n,

unsigned long int d ) [Function] unsigned long int mpz_tdiv_r_ui (mpz t r, mpz t n,

unsigned long int d ) [Function] unsigned long int mpz_tdiv_qr_ui (mpz t q, mpz t r, mpz t n ,

unsigned long int d ) [Function] unsigned long int mpz_tdiv_ui (mpz t n, unsigned long int d ) [Function] void mpz_tdiv_q_2exp (mpz t q, mpz t n, unsigned long int b ) [Function] void mpz_tdiv_r_2exp (mpz t r, mpz t n, unsigned long int b )

Divide n by d, forming a quotient q and/or remainder r. For the 2exp functions, d = 2b. Therounding is in three styles, each suiting different applications.

* cdiv rounds q up towards +1, and r will have the opposite sign to d. The c stands for"ceil".

* fdiv rounds q down towards -1, and r will have the same sign as d. The f stands for"floor".

* tdiv rounds q towards zero, and r will have the same sign as n. The t stands for"truncate".

In all cases q and r will satisfy n = qd + r, and r will satisfy 0 <= |r| < |d|. The q functions calculate only the quotient, the r functions only the remainder, and the qrfunctions calculate both. Note that for

qr the same variable cannot be passed for both q and r, or results will be unpredictable.

For the ui variants the return value is the remainder, and in fact returning the remainder isall the

div_ui functions do. For tdiv and cdiv the remainder can be negative, so for thosethe return value is the absolute value of the remainder.

For the 2exp variants the divisor is 2b. These functions are implemented as right shifts andbit masks, but of course they round the same as the other functions. For positive n both mpz_fdiv_q_2exp and mpz_tdiv_q_2exp are simple bitwise right shifts.For negative

n, mpz_fdiv_q_2exp is effectively an arithmetic right shift treating n as twoscomplement the same as the bitwise logical functions do, whereas

mpz_tdiv_q_2exp effec-tively treats n as sign and magnitude.

34 GNU MP 4.2.3

[Function]void mpz_mod (mpz t r, mpz t n, mpz t d ) [Function] unsigned long int mpz_mod_ui (mpz t r, mpz t n, unsigned long int d )Set

r to n mod d. The sign of the divisor is ignored; the result is always non-negative.

mpz_mod_ui is identical to mpz_fdiv_r_ui above, returning the remainder as well as setting r. See mpz_fdiv_ui above if only the return value is wanted.

[Function]void mpz_divexact (mpz t q, mpz t n, mpz t d ) [Function] void mpz_divexact_ui (mpz t q, mpz t n, unsigned long d )Set

q to n/d. These functions produce correct results only when it is known in advance that d divides n.

These routines are much faster than the other division functions, and are the best choicewhen exact division is known to occur, for example reducing a rational to lowest terms.

[Function]int mpz_divisible_p (mpz t n, mpz t d ) [Function] int mpz_divisible_ui_p (mpz t n, unsigned long int d ) [Function] int mpz_divisible_2exp_p (mpz t n, unsigned long int b )Return non-zero if

n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b.

n is divisible by d if there exists an integer q satisfying n = qd. Unlike the other divisionfunctions,

d = 0 is accepted and following the rule it can be seen that only 0 is considereddivisible by 0.

[Function]int mpz_congruent_p (mpz t n, mpz t c, mpz t d ) [Function] int mpz_congruent_ui_p (mpz t n, unsigned long int c, unsigned long int d ) [Function] int mpz_congruent_2exp_p (mpz t n, mpz t c, unsigned long int b )Return non-zero if

n is congruent to c modulo d, or in the case of mpz_congruent_2exp_pmodulo 2 b.

n is congruent to c mod d if there exists an integer q satisfying n = c + qd. Unlike the otherdivision functions,

d = 0 is accepted and following the rule it can be seen that n and c areconsidered congruent mod 0 only when exactly equal.

5.7 Exponentiation Functions

[Function]void mpz_powm (mpz t rop, mpz t base, mpz t exp, mpz t mod ) [Function] void mpz_powm_ui (mpz t rop, mpz t base, unsigned long int exp, mpz t

mod )Set rop to baseexp mod mod.

Negative exp is supported if an inverse base-1 mod mod exists (see mpz_invert in Section 5.9[Number Theoretic Functions], page 35). If an inverse doesn't exist then a divide by zero is

raised.

[Function]void mpz_pow_ui (mpz t rop, mpz t base, unsigned long int exp ) [Function] void mpz_ui_pow_ui (mpz t rop, unsigned long int base, unsigned long int

exp )Set rop to baseexp. The case 00 yields 1.

Chapter 5: Integer Functions 35 5.8 Root Extraction Functions

[Function]int mpz_root (mpz t rop, mpz t op, unsigned long int n )Set rop to b npopc, the truncated integer part of the nth root of op. Return non-zero if thecomputation was exact, i.e., if

op is rop to the nth power.

[Function]void mpz_rootrem (mpz t root, mpz t rem, mpz t u, unsigned long int n )Set root to b npuc, the truncated integer part of the nth root of u. Set rem to the remainder,( u - rootn).

[Function]void mpz_sqrt (mpz t rop, mpz t op )Set rop to bpopc, the truncated integer part of the square root of op.

[Function]void mpz_sqrtrem (mpz t rop1, mpz t rop2, mpz t op )Set rop1 to bpopc, like mpz_sqrt. Set rop2 to the remainder (op - rop12), which will bezero if

op is a perfect square.

If rop1 and rop2 are the same variable, the results are undefined.

[Function]int mpz_perfect_power_p (mpz t op )Return non-zero if op is a perfect power, i.e., if there exist integers a and b, with b > 1, suchthat op = ab.

Under this definition both 0 and 1 are considered to be perfect powers. Negative values of op are accepted, but of course can only be odd perfect powers.

[Function]int mpz_perfect_square_p (mpz t op )Return non-zero if op is a perfect square, i.e., if the square root of op is an integer. Underthis definition both 0 and 1 are considered to be perfect squares.

5.9 Number Theoretic Functions

[Function]int mpz_probab_prime_p (mpz t n, int reps )Determine whether n is prime. Return 2 if n is definitely prime, return 1 if n is probablyprime (without being certain), or return 0 if

n is definitely composite.

This function does some trial divisions, then some Miller-Rabin probabilistic primality tests. reps controls how many such tests are done, 5 to 10 is a reasonable number, more will reducethe chances of a composite being returned as "probably prime".

Miller-Rabin and similar tests can be more properly called compositeness tests. Numberswhich fail are known to be composite but those which pass might be prime or might be composite. Only a few composites pass, hence those which pass are considered probablyprime.

[Function]void mpz_nextprime (mpz t rop, mpz t op )Set rop to the next prime greater than op.

This function uses a probabilistic algorithm to identify primes. For practical purposes it'sadequate, the chance of a composite passing will be extremely small.

[Function]void mpz_gcd (mpz t rop, mpz t op1, mpz t op2 )Set rop to the greatest common divisor of op1 and op2. The result is always positive even ifone or both input operands are negative.

36 GNU MP 4.2.3

[Function]unsigned long int mpz_gcd_ui (mpz t rop, mpz t op1, unsigned long int op2 )Compute the greatest common divisor of

op1 and op2. If rop is not NULL, store the resultthere.

If the result is small enough to fit in an unsigned long int, it is returned. If the result doesnot fit, 0 is returned, and the result is equal to the argument

op1. Note that the result willalways fit if op2 is non-zero.

[Function]void mpz_gcdext (mpz t g, mpz t s, mpz t t, mpz t a, mpz t b )Set g to the greatest common divisor of a and b, and in addition set s and t to coefficientssatisfying

as + bt = g. g is always positive, even if one or both of a and b are negative.

If t is NULL then that value is not computed.

[Function]void mpz_lcm (mpz t rop, mpz t op1, mpz t op2 ) [Function] void mpz_lcm_ui (mpz t rop, mpz t op1, unsigned long op2 )Set

rop to the least common multiple of op1 and op2. rop is always positive, irrespective ofthe signs of

op1 and op2. rop will be zero if either op1 or op2 is zero.

[Function]int mpz_invert (mpz t rop, mpz t op1, mpz t op2 )Compute the inverse of op1 modulo op2 and put the result in rop. If the inverse exists, thereturn value is non-zero and

rop will satisfy 0 <= rop < op2. If an inverse doesn't exist thereturn value is zero and rop is undefined.

[Function]int mpz_jacobi (mpz t a, mpz t b )Calculate the Jacobi symbol \Gamma  a

b \Delta . This is defined only for b odd.

[Function]int mpz_legendre (mpz t a, mpz t p ) Calculate the Legendre symbol i ap j. This is defined only for p an odd positive prime, and for such p it's identical to the Jacobi symbol.

[Function]int mpz_kronecker (mpz t a, mpz t b ) [Function] int mpz_kronecker_si (mpz t a, long b ) [Function] int mpz_kronecker_ui (mpz t a, unsigned long b ) [Function] int mpz_si_kronecker (long a, mpz t b ) [Function] int mpz_ui_kronecker (unsigned long a, mpz t b )Calculate the Jacobi symbol \Gamma 

a

b \Delta  with the Kronecker extension \Gamma 

a

2 \Delta  = \Gamma 

2 a \Delta  when a odd, or\Gamma  a

2 \Delta  = 0 when a even.

When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_uietc can be used for mixed precision Jacobi symbols too.

For more information see Henri Cohen section 1.4.2 (see Appendix B [References], page 119),or any number theory textbook. See also the example program `

demos/qcn.c' which uses mpz_kronecker_ui.

[Function]unsigned long int mpz_remove (mpz t rop, mpz t op, mpz t f )Remove all occurrences of the factor f from op and store the result in rop. The return valueis how many such occurrences were removed.

[Function]void mpz_fac_ui (mpz t rop, unsigned long int op )Set rop to op!, the factorial of op.

Chapter 5: Integer Functions 37

[Function]void mpz_bin_ui (mpz t rop, mpz t n, unsigned long int k ) [Function] void mpz_bin_uiui (mpz t rop, unsigned long int n, unsigned long int k )Compute the binomial coefficient \Gamma 

n

k \Delta  and store the result in rop. Negative values of n aresupported by

mpz_bin_ui, using the identity \Gamma  -nk \Delta  = (-1)k i n+k-1k j, see Knuth volume 1

section 1.2.6 part G.

[Function]void mpz_fib_ui (mpz t fn, unsigned long int n ) [Function] void mpz_fib2_ui (mpz t fn, mpz t fnsub1, unsigned long int n )

mpz_fib_ui sets fn to to Fn, the n'th Fibonacci number. mpz_fib2_ui sets fn to Fn, and fnsub1 to Fn-1.

These functions are designed for calculating isolated Fibonacci numbers. When a sequence ofvalues is wanted it's best to start with

mpz_fib2_ui and iterate the defining Fn+1 = Fn +Fn-1or similar.

[Function]void mpz_lucnum_ui (mpz t ln, unsigned long int n ) [Function] void mpz_lucnum2_ui (mpz t ln, mpz t lnsub1, unsigned long int n )

mpz_lucnum_ui sets ln to to Ln, the n'th Lucas number. mpz_lucnum2_ui sets ln to Ln, and lnsub1 to Ln-1.

These functions are designed for calculating isolated Lucas numbers. When a sequence ofvalues is wanted it's best to start with

mpz_lucnum2_ui and iterate the defining Ln+1 = Ln + Ln-1 or similar.

The Fibonacci numbers and Lucas numbers are related sequences, so it's never necessaryto call both

mpz_fib2_ui and mpz_lucnum2_ui. The formulas for going from Fibonacci toLucas can be found in Section 16.7.5 [Lucas Numbers Algorithm], page 106, the reverse is

straightforward too.

5.10 Comparison Functions

[Function]int mpz_cmp (mpz t op1, mpz t op2 ) [Function] int mpz_cmp_d (mpz t op1, double op2 ) [Macro] int mpz_cmp_si (mpz t op1, signed long int op2 ) [Macro] int mpz_cmp_ui (mpz t op1, unsigned long int op2 )Compare

op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, or a negativevalue if op1 < op2.

mpz_cmp_ui and mpz_cmp_si are macros and will evaluate their arguments more than once. mpz_cmp_d can be called with an infinity, but results are undefined for a NaN.

[Function]int mpz_cmpabs (mpz t op1, mpz t op2 ) [Function] int mpz_cmpabs_d (mpz t op1, double op2 ) [Function] int mpz_cmpabs_ui (mpz t op1, unsigned long int op2 )Compare the absolute values of

op1 and op2. Return a positive value if |op1| > |op2|, zeroif | op1| = |op2|, or a negative value if |op1| < |op2|.

mpz_cmpabs_d can be called with an infinity, but results are undefined for a NaN.

[Macro]int mpz_sgn (mpz t op )Return +1 if op > 0, 0 if op = 0, and -1 if op < 0.

This function is actually implemented as a macro. It evaluates its argument multiple times.

38 GNU MP 4.2.3 5.11 Logical and Bit Manipulation Functions These functions behave as if twos complement arithmetic were used (although sign-magnitudeis the actual implementation). The least significant bit is number 0.

[Function]void mpz_and (mpz t rop, mpz t op1, mpz t op2 )Set rop to op1 bitwise-and op2.

[Function]void mpz_ior (mpz t rop, mpz t op1, mpz t op2 )Set rop to op1 bitwise inclusive-or op2.

[Function]void mpz_xor (mpz t rop, mpz t op1, mpz t op2 )Set rop to op1 bitwise exclusive-or op2.

[Function]void mpz_com (mpz t rop, mpz t op )Set rop to the one's complement of op.

[Function]unsigned long int mpz_popcount (mpz t op )If op >= 0, return the population count of op, which is the number of 1 bits in the binaryrepresentation. If

op < 0, the number of 1s is infinite, and the return value is ULONG MAX,the largest possible

unsigned long.

[Function]unsigned long int mpz_hamdist (mpz t op1, mpz t op2 )If op1 and op2 are both >= 0 or both < 0, return the hamming distance between the twooperands, which is the number of bit positions where

op1 and op2 have different bit values.If one operand is >= 0 and the other < 0 then the number of bits different is infinite, and thereturn value is ULONG MAX, the largest possible unsigned long.

[Function]unsigned long int mpz_scan0 (mpz t op, unsigned long int starting_bit ) [Function] unsigned long int mpz_scan1 (mpz t op, unsigned long int

starting_bit )Scan op, starting from bit starting bit, towards more significant bits, until the first 0 or 1 bit(respectively) is found. Return the index of the found bit.

If the bit at starting bit is already what's sought, then starting bit is returned. If there's no bit found, then ULONG MAX is returned. This will happen in mpz_scan0 pastthe end of a negative number, or

mpz_scan1 past the end of a nonnegative number.

[Function]void mpz_setbit (mpz t rop, unsigned long int bit_index )Set bit bit index in rop.

[Function]void mpz_clrbit (mpz t rop, unsigned long int bit_index )Clear bit bit index in rop.

[Function]void mpz_combit (mpz t rop, unsigned long int bit_index )Complement bit bit index in rop.

[Function]int mpz_tstbit (mpz t op, unsigned long int bit_index )Test bit bit index in op and return 0 or 1 accordingly.

Chapter 5: Integer Functions 39 5.12 Input and Output Functions Functions that perform input from a stdio stream, and functions that output to a stdio stream.Passing a

NULL pointer for a stream argument to any of these functions will make them readfrom stdin and write to stdout, respectively.

When using any of these functions, it is a good idea to include `stdio.h' before `gmp.h', sincethat will allow `

gmp.h' to define prototypes for these functions.

[Function]size_t mpz_out_str (FILE *stream, int base, mpz t op )Output op on stdio stream stream, as a string of digits in base base. The base argument mayvary from 2 to 62 or from -2 to -36.

For base in the range 2..36, digits and lower-case letters are used; for -2..-36, digits andupper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that significance order) are used. Return the number of bytes written, or if an error occurred, return 0.

[Function]size_t mpz_inp_str (mpz t rop, FILE *stream, int base )Input a possibly white-space preceded string in base base from stdio stream stream, and putthe read integer in rop.

The base may vary from 2 to 62, or if base is 0, then the leading characters are used: 0x and 0X for hexadecimal, 0b and 0B for binary, 0 for octal, or decimal otherwise.

For bases up to 36, case is ignored; upper-case and lower-case letters have the same value. Forbases 37 to 62, upper-case letter represent the usual 10..35 while lower-case letter represent

36..61. Return the number of bytes read, or if an error occurred, return 0.

[Function]size_t mpz_out_raw (FILE *stream, mpz t op )Output op on stdio stream stream, in raw binary format. The integer is written in a portableformat, with 4 bytes of size information, and that many bytes of limbs. Both the size and

the limbs are written in decreasing significance order (i.e., in big-endian). The output can be read with mpz_inp_raw. Return the number of bytes written, or if an error occurred, return 0. The output of this can not be read by mpz_inp_raw from GMP 1, because of changes necessaryfor compatibility between 32-bit and 64-bit machines.

[Function]size_t mpz_inp_raw (mpz t rop, FILE *stream )Input from stdio stream stream in the format written by mpz_out_raw, and put the result in rop. Return the number of bytes read, or if an error occurred, return 0.

This routine can read the output from mpz_out_raw also from GMP 1, in spite of changesnecessary for compatibility between 32-bit and 64-bit machines.

40 GNU MP 4.2.3 5.13 Random Number Functions The random number functions of GMP come in two groups; older function that rely on a globalstate, and newer functions that accept a state parameter that is read and modified. Please see

the Chapter 9 [Random Number Functions], page 64 for more information on how to use andnot to use random number functions.

[Function]void mpz_urandomb (mpz t rop, gmp randstate t state, unsigned long int n )Generate a uniformly distributed random integer in the range 0 to 2

n - 1, inclusive.

The variable state must be initialized by calling one of the gmp_randinit functions(Section 9.1 [Random State Initialization], page 64) before invoking this function.

[Function]void mpz_urandomm (mpz t rop, gmp randstate t state, mpz t n )Generate a uniform random integer in the range 0 to n - 1, inclusive.

The variable state must be initialized by calling one of the gmp_randinit functions(Section 9.1 [Random State Initialization], page 64) before invoking this function.

[Function]void mpz_rrandomb (mpz t rop, gmp randstate t state, unsigned long int n )Generate a random integer with long strings of zeros and ones in the binary representation.

Useful for testing functions and algorithms, since this kind of random numbers have provento be more likely to trigger corner-case bugs. The random number will be in the range 0 to 2n - 1, inclusive. The variable state must be initialized by calling one of the gmp_randinit functions(Section 9.1 [Random State Initialization], page 64) before invoking this function.

[Function]void mpz_random (mpz t rop, mp size t max_size )Generate a random integer of at most max size limbs. The generated random number doesn'tsatisfy any particular requirements of randomness. Negative random numbers are generated

when max size is negative. This function is obsolete. Use mpz_urandomb or mpz_urandomm instead.

[Function]void mpz_random2 (mpz t rop, mp size t max_size )Generate a random integer of at most max size limbs, with long strings of zeros and onesin the binary representation. Useful for testing functions and algorithms, since this kind of

random numbers have proven to be more likely to trigger corner-case bugs. Negative randomnumbers are generated when

max size is negative.

This function is obsolete. Use mpz_rrandomb instead.

5.14 Integer Import and Export mpz_t variables can be converted to and from arbitrary words of binary data with the followingfunctions.

[Function]void mpz_import (mpz t rop, size t count, int order, size t size, int endian, size t nails, const void *op )Set rop from an array of word data at op.

Chapter 5: Integer Functions 41

The parameters specify the format of the data. count many words are read, each size bytes. order can be 1 for most significant word first or -1 for least significant first. Within eachword

endian can be 1 for most significant byte first, -1 for least significant first, or 0 for thenative endianness of the host CPU. The most significant

nails bits of each word are skipped,this can be 0 to use the full words.

There is no sign taken from the data, rop will simply be a positive integer. An applicationcan handle any sign itself, and apply it for instance with

mpz_neg.

There are no data alignment restrictions on op, any address is allowed. Here's an example converting an array of unsigned long data, most significant element first,and host byte order within each value.

unsigned long a[20]; mpz_t z; mpz_import (z, 20, 1, sizeof(a[0]), 0, 0, a);

This example assumes the full sizeof bytes are used for data in the given type, which isusually true, and certainly true for

unsigned long everywhere we know of. However on Crayvector systems it may be noted that

short and int are always stored in 8 bytes (and with sizeof indicating that) but use only 32 or 46 bits. The nails feature can account for this,by passing for instance

8*sizeof(int)-INT_BIT.

[Function]void * mpz_export (void *rop, size t *countp, int order, size t size, int endian, size t nails, mpz t op )Fill rop with word data from op.

The parameters specify the format of the data produced. Each word will be size bytes and order can be 1 for most significant word first or -1 for least significant first. Within eachword

endian can be 1 for most significant byte first, -1 for least significant first, or 0 for thenative endianness of the host CPU. The most significant

nails bits of each word are unusedand set to zero, this can be 0 to produce full words.

The number of words produced is written to *countp , or countp can be NULL to discard thecount.

rop must have enough space for the data, or if rop is NULL then a result array ofthe necessary size is allocated using the current GMP allocation function (see Chapter 14

[Custom Allocation], page 85). In either case the return value is the destination used, either rop or the allocated block.

If op is non-zero then the most significant word produced will be non-zero. If op is zero thenthe count returned will be zero and nothing written to

rop. If rop is NULL in this case, noblock is allocated, just NULL is returned.

The sign of op is ignored, just the absolute value is exported. An application can use mpz_sgnto get the sign and handle it as desired. (see Section 5.10 [Integer Comparisons], page 37)

There are no data alignment restrictions on rop, any address is allowed. When an application is allocating space itself the required size can be determined with acalculation like the following. Since

mpz_sizeinbase always returns at least 1, count herewill be at least one, which avoids any portability problems with

malloc(0), though if z iszero no space at all is actually needed (or written).

numb = 8*size - nail; count = (mpz_sizeinbase (z, 2) + numb-1) / numb; p = malloc (count * size);

42 GNU MP 4.2.3 5.15 Miscellaneous Functions

[Function]int mpz_fits_ulong_p (mpz t op ) [Function] int mpz_fits_slong_p (mpz t op ) [Function] int mpz_fits_uint_p (mpz t op ) [Function] int mpz_fits_sint_p (mpz t op ) [Function] int mpz_fits_ushort_p (mpz t op ) [Function] int mpz_fits_sshort_p (mpz t op )Return non-zero iff the value of

op fits in an unsigned long int, signed long int, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, re-turn zero.

[Macro]int mpz_odd_p (mpz t op ) [Macro] int mpz_even_p (mpz t op )Determine whether

op is odd or even, respectively. Return non-zero if yes, zero if no. Thesemacros evaluate their argument more than once.

[Function]size_t mpz_sizeinbase (mpz t op, int base )Return the size of op measured in number of digits in the given base. base can vary from 2to 62. The sign of

op is ignored, just the absolute value is used. The result will be eitherexact or 1 too big. If

base is a power of 2, the result is always exact. If op is zero the returnvalue is always 1.

This function can be used to determine the space required when converting op to a string. Theright amount of allocation is normally two more than the value returned by

mpz_sizeinbase,one extra for a minus sign and one for the null-terminator.

It will be noted that mpz_sizeinbase(op,2) can be used to locate the most significant 1 bitin

op, counting from 1. (Unlike the bitwise functions which start from 0, See Section 5.11[Logical and Bit Manipulation Functions], page 38.)

5.16 Special Functions The functions in this section are for various special purposes. Most applications will not needthem.

[Function]void mpz_array_init (mpz t integer_array, mp size t array_size, mp size t fixed_num_bits )This is a special type of initialization.

Fixed space of fixed num bits is allocated to each ofthe array size integers in integer array. There is no way to free the storage allocated by thisfunction. Don't call

mpz_clear!

The integer array parameter is the first mpz_t in the array. For example,

mpz_t arr[20000]; mpz_array_init (arr[0], 20000, 512);

This function is only intended for programs that create a large number of integers and needto reduce memory usage by avoiding the overheads of allocating and reallocating lots of small

blocks. In normal programs this function is not recommended. The space allocated to each integer by this function will not be automatically increased, unlikethe normal

mpz_init, so an application must ensure it is sufficient for any value stored. Thefollowing space requirements apply to various routines,

Chapter 5: Integer Functions 43

* mpz_abs, mpz_neg, mpz_set, mpz_set_si and mpz_set_ui need room for the value theystore.

* mpz_add, mpz_add_ui, mpz_sub and mpz_sub_ui need room for the larger of the twooperands, plus an extra

mp_bits_per_limb.*

mpz_mul, mpz_mul_ui and mpz_mul_ui need room for the sum of the number of bits intheir operands, but each rounded up to a multiple of

mp_bits_per_limb.*

mpz_swap can be used between two array variables, but not between an array and anormal variable.

For other functions, or if in doubt, the suggestion is to calculate in a regular mpz_init variableand copy the result to an array variable with

mpz_set.

[Function]void * _mpz_realloc (mpz t integer, mp size t new_alloc )Change the space for integer to new alloc limbs. The value in integer is preserved if it fits,or is set to 0 if not. The return value is not useful to applications and should be ignored.

mpz_realloc2 is the preferred way to accomplish allocation changes like this. mpz_realloc2and

_mpz_realloc are the same except that _mpz_realloc takes its size in limbs.

[Function]mp_limb_t mpz_getlimbn (mpz t op, mp size t n )Return limb number n from op. The sign of op is ignored, just the absolute value is used.The least significant limb is number 0.

mpz_size can be used to find how many limbs make up op. mpz_getlimbn returns zero if nis outside the range 0 to

mpz_size(op )-1.

[Function]size_t mpz_size (mpz t op )Return the size of op measured in number of limbs. If op is zero, the returned value will bezero.

44 GNU MP 4.2.3 6 Rational Number Functions This chapter describes the GMP functions for performing arithmetic on rational numbers. Thesefunctions start with the prefix

mpq_.

Rational numbers are stored in objects of type mpq_t. All rational arithmetic functions assume operands have a canonical form, and canonicalize theirresult. The canonical from means that the denominator and the numerator have no common

factors, and that the denominator is positive. Zero has the unique representation 0/1. Pure assignment functions do not canonicalize the assigned variable. It is the responsibility ofthe user to canonicalize the assigned variable before any arithmetic operations are performed on

that variable.

[Function]void mpq_canonicalize (mpq t op )Remove any factors that are common to the numerator and denominator of op, and makethe denominator positive.

6.1 Initialization and Assignment Functions

[Function]void mpq_init (mpq t dest_rational )Initialize dest rational and set it to 0/1. Each variable should normally only be initializedonce, or at least cleared out (using the function

mpq_clear) between each initialization.

[Function]void mpq_clear (mpq t rational_number )Free the space occupied by rational number. Make sure to call this function for all mpq_tvariables when you are done with them.

[Function]void mpq_set (mpq t rop, mpq t op ) [Function] void mpq_set_z (mpq t rop, mpz t op )Assign

rop from op.

[Function]void mpq_set_ui (mpq t rop, unsigned long int op1, unsigned long int op2 ) [Function] void mpq_set_si (mpq t rop, signed long int op1, unsigned long int op2 )Set the value of

rop to op1/op2. Note that if op1 and op2 have common factors, rop has tobe passed to mpq_canonicalize before any operations are performed on rop.

[Function]int mpq_set_str (mpq t rop, char *str, int base )Set rop from a null-terminated string str in the given base.

The string can be an integer like "41" or a fraction like "41/152". The fraction must bein canonical form (see Chapter 6 [Rational Number Functions], page 44), or if not then

mpq_canonicalize must be called. The numerator and optional denominator are parsed the same as in mpz_set_str (seeSection 5.2 [Assigning Integers], page 29). White space is allowed in the string, and is simply

ignored. The base can vary from 2 to 62, or if base is 0 then the leading characters are used: 0x or 0X for hex, 0b or 0B for binary, 0 for octal, or decimal otherwise. Note that this is doneseparately for the numerator and denominator, so for instance

0xEF/100 is 239/100, whereas 0xEF/0x100 is 239/256.

The return value is 0 if the entire string is a valid number, or -1 if not.

Chapter 6: Rational Number Functions 45

[Function]void mpq_swap (mpq t rop1, mpq t rop2 )Swap the values rop1 and rop2 efficiently.

6.2 Conversion Functions

[Function]double mpq_get_d (mpq t op )Convert op to a double, truncating if necessary (ie. rounding towards zero).

If the exponent from the conversion is too big or too small to fit a double then the result issystem dependent. For too big an infinity is returned when available. For too small 0

.0 isnormally returned. Hardware overflow, underflow and denorm traps may or may not occur.

[Function]void mpq_set_d (mpq t rop, double op ) [Function] void mpq_set_f (mpq t rop, mpf t op )Set

rop to the value of op. There is no rounding, this conversion is exact.

[Function]char * mpq_get_str (char *str, int base, mpq t op )Convert op to a string of digits in base base. The base may vary from 2 to 36. The stringwill be of the form `

num/den', or if the denominator is 1 then just `num'.

If str is NULL, the result string is allocated using the current allocation function (seeChapter 14 [Custom Allocation], page 85). The block will be

strlen(str)+1 bytes, thatbeing exactly enough for the string and null-terminator.

If str is not NULL, it should point to a block of storage large enough for the result, that being

mpz_sizeinbase (mpq_numref(op ), base ) + mpz_sizeinbase (mpq_denref(op ), base ) + 3

The three extra bytes are for a possible minus sign, possible slash, and the null-terminator. A pointer to the result string is returned, being either the allocated block, or the given str.

6.3 Arithmetic Functions

[Function]void mpq_add (mpq t sum, mpq t addend1, mpq t addend2 )Set sum to addend1 + addend2.

[Function]void mpq_sub (mpq t difference, mpq t minuend, mpq t subtrahend )Set difference to minuend - subtrahend.

[Function]void mpq_mul (mpq t product, mpq t multiplier, mpq t multiplicand )Set product to multiplier * multiplicand.

[Function]void mpq_mul_2exp (mpq t rop, mpq t op1, unsigned long int op2 )Set rop to op1 * 2op2.

[Function]void mpq_div (mpq t quotient, mpq t dividend, mpq t divisor )Set quotient to dividend/divisor.

[Function]void mpq_div_2exp (mpq t rop, mpq t op1, unsigned long int op2 )Set rop to op1/2op2.

[Function]void mpq_neg (mpq t negated_operand, mpq t operand )Set negated operand to -operand.

46 GNU MP 4.2.3

[Function]void mpq_abs (mpq t rop, mpq t op )Set rop to the absolute value of op.

[Function]void mpq_inv (mpq t inverted_number, mpq t number )Set inverted number to 1/number. If the new denominator is zero, this routine will divideby zero.

6.4 Comparison Functions

[Function]int mpq_cmp (mpq t op1, mpq t op2 )Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, and anegative value if

op1 < op2.

To determine if two rationals are equal, mpq_equal is faster than mpq_cmp.

[Macro]int mpq_cmp_ui (mpq t op1, unsigned long int num2, unsigned long int den2 ) [Macro] int mpq_cmp_si (mpq t op1, long int num2, unsigned long int den2 )Compare

op1 and num2/den2. Return a positive value if op1 > num2/den2, zero if op1 = num2/den2, and a negative value if op1 < num2/den2.

num2 and den2 are allowed to have common factors. These functions are implemented as a macros and evaluate their arguments multiple times.

[Macro]int mpq_sgn (mpq t op )Return +1 if op > 0, 0 if op = 0, and -1 if op < 0.

This function is actually implemented as a macro. It evaluates its arguments multiple times.

[Function]int mpq_equal (mpq t op1, mpq t op2 )Return non-zero if op1 and op2 are equal, zero if they are non-equal. Although mpq_cmp canbe used for the same purpose, this function is much faster.

6.5 Applying Integer Functions to Rationals The set of mpq functions is quite small. In particular, there are few functions for either inputor output. The following functions give direct access to the numerator and denominator of an

mpq_t. Note that if an assignment to the numerator and/or denominator could take an mpq_t outof the canonical form described at the start of this chapter (see Chapter 6 [Rational Number

Functions], page 44) then mpq_canonicalize must be called before any other mpq functions areapplied to that

mpq_t.

[Macro]mpz_t mpq_numref (mpq t op ) [Macro] mpz_t mpq_denref (mpq t op )Return a reference to the numerator and denominator of

op, respectively. The mpz functionscan be used on the result of these macros.

[Function]void mpq_get_num (mpz t numerator, mpq t rational ) [Function] void mpq_get_den (mpz t denominator, mpq t rational ) [Function] void mpq_set_num (mpq t rational, mpz t numerator )

Chapter 6: Rational Number Functions 47

[Function]void mpq_set_den (mpq t rational, mpz t denominator )Get or set the numerator or denominator of a rational. These functions are equivalent to calling mpz_set with an appropriate mpq_numref or mpq_denref. Direct use of mpq_numrefor

mpq_denref is recommended instead of these functions.

6.6 Input and Output Functions When using any of these functions, it's a good idea to include `stdio.h' before `gmp.h', sincethat will allow `

gmp.h' to define prototypes for these functions.

Passing a NULL pointer for a stream argument to any of these functions will make them readfrom

stdin and write to stdout, respectively.

[Function]size_t mpq_out_str (FILE *stream, int base, mpq t op )Output op on stdio stream stream, as a string of digits in base base. The base may vary from2 to 36. Output is in the form `

num/den' or if the denominator is 1 then just `num'.

Return the number of bytes written, or if an error occurred, return 0.

[Function]size_t mpq_inp_str (mpq t rop, FILE *stream, int base )Read a string of digits from stream and convert them to a rational in rop. Any initial white-space characters are read and discarded. Return the number of characters read (including

white space), or 0 if a rational could not be read. The input can be a fraction like `17/63' or just an integer like `123'. Reading stops at thefirst character not in this form, and white space is not permitted within the string. If the

input might not be in canonical form, then mpq_canonicalize must be called (see Chapter 6[Rational Number Functions], page 44).

The base can be between 2 and 36, or can be 0 in which case the leading characters of thestring determine the base, `

0x' or `0X' for hexadecimal, `0' for octal, or decimal otherwise.The leading characters are examined separately for the numerator and denominator of a

fraction, so for instance `0x10/11' is 16/11, whereas `0x10/0x11' is 16/17.

48 GNU MP 4.2.3 7 Floating-point Functions GMP floating point numbers are stored in objects of type mpf_t and functions operating onthem have an

mpf_ prefix.

The mantissa of each float has a user-selectable precision, limited only by available memory.Each variable has its own precision, and that can be increased or decreased at any time.

The exponent of each float is a fixed precision, one machine word on most systems. In thecurrent implementation the exponent is a count of limbs, so for example on a 32-bit system this means a range of roughly 2-68719476768 to 268719476736, or on a 64-bit system this will be greater.Note however

mpf_get_str can only return an exponent which fits an mp_exp_t and currently mpf_set_str doesn't accept exponents bigger than a long.

Each variable keeps a size for the mantissa data actually in use. This means that if a float isexactly represented in only a few bits then only those bits will be used in a calculation, even if

the selected precision is high. All calculations are performed to the precision of the destination variable. Each function isdefined to calculate with "infinite precision" followed by a truncation to the destination precision,

but of course the work done is only what's needed to determine a result under that definition. The precision selected for a variable is a minimum value, GMP may increase it a little to facilitateefficient calculation. Currently this means rounding up to a whole limb, and then sometimes

having a further partial limb, depending on the high limb of the mantissa. But applicationsshouldn't be concerned by such details.

The mantissa in stored in binary, as might be imagined from the fact precisions are expressedin bits. One consequence of this is that decimal fractions like 0

.1 cannot be represented exactly.The same is true of plain IEEE double floats. This makes both highly unsuitable for calculationsinvolving money or other values that should be exact decimal fractions. (Suitably scaled integers,

or perhaps rationals, are better choices.) mpf functions and variables have no special notion of infinity or not-a-number, and applicationsmust take care not to overflow the exponent or results will be unpredictable. This might change

in a future release. Note that the mpf functions are not intended as a smooth extension to IEEE P754 arithmetic.In particular results obtained on one computer often differ from the results on a computer with

a different word size.

7.1 Initialization Functions

[Function]void mpf_set_default_prec (unsigned long int prec )Set the default precision to be at least prec bits. All subsequent calls to mpf_init will usethis precision, but previously initialized variables are unaffected.

[Function]unsigned long int mpf_get_default_prec (void)Return the default precision actually used. An mpf_t object must be initialized before storing the first value in it. The functions mpf_initand

mpf_init2 are used for that purpose.

Chapter 7: Floating-point Functions 49

[Function]void mpf_init (mpf t x )Initialize x to 0. Normally, a variable should be initialized once only or at least be cleared,using mpf_clear, between initializations. The precision of x is undefined unless a defaultprecision has already been established by a call to

mpf_set_default_prec.

[Function]void mpf_init2 (mpf t x, unsigned long int prec )Initialize x to 0 and set its precision to be at least prec bits. Normally, a variable should beinitialized once only or at least be cleared, using

mpf_clear, between initializations.

[Function]void mpf_clear (mpf t x )Free the space occupied by x. Make sure to call this function for all mpf_t variables whenyou are done with them.

Here is an example on how to initialize floating-point variables:

{

mpf_t x, y; mpf_init (x); /* use default precision */ mpf_init2 (y, 256); /* precision at least 256 bits */ ... /* Unless the program is about to exit, do ... */ mpf_clear (x); mpf_clear (y); }

The following three functions are useful for changing the precision during a calculation. A typicaluse would be for adjusting the precision gradually in iterative algorithms like Newton-Raphson,

making the computation precision closely match the actual accurate part of the numbers.

[Function]unsigned long int mpf_get_prec (mpf t op )Return the current precision of op, in bits.

[Function]void mpf_set_prec (mpf t rop, unsigned long int prec )Set the precision of rop to be at least prec bits. The value in rop will be truncated to thenew precision.

This function requires a call to realloc, and so should not be used in a tight loop.

[Function]void mpf_set_prec_raw (mpf t rop, unsigned long int prec )Set the precision of rop to be at least prec bits, without changing the memory allocated.

prec must be no more than the allocated precision for rop, that being the precision when ropwas initialized, or in the most recent

mpf_set_prec.

The value in rop is unchanged, and in particular if it had a higher precision than prec it willretain that higher precision. New values written to

rop will use the new prec.

Before calling mpf_clear or the full mpf_set_prec, another mpf_set_prec_raw call must bemade to restore

rop to its original allocated precision. Failing to do so will have unpredictableresults.

mpf_get_prec can be used before mpf_set_prec_raw to get the original allocated precision.After

mpf_set_prec_raw it reflects the prec value set.

50 GNU MP 4.2.3

mpf_set_prec_raw is an efficient way to use an mpf_t variable at different precisions duringa calculation, perhaps to gradually increase precision in an iteration, or just to use various different precisions for different purposes during a calculation.

7.2 Assignment Functions These functions assign new values to already initialized floats (see Section 7.1 [Initializing Floats],page 48).

[Function]void mpf_set (mpf t rop, mpf t op ) [Function] void mpf_set_ui (mpf t rop, unsigned long int op ) [Function] void mpf_set_si (mpf t rop, signed long int op ) [Function] void mpf_set_d (mpf t rop, double op ) [Function] void mpf_set_z (mpf t rop, mpz t op ) [Function] void mpf_set_q (mpf t rop, mpq t op )Set the value of

rop from op.

[Function]int mpf_set_str (mpf t rop, char *str, int base )Set the value of rop from the string in str. The string is of the form `M@N' or, if the base is 10or less, alternatively `

MeN'. `M' is the mantissa and `N' is the exponent. The mantissa is alwaysin the specified base. The exponent is either in the specified base or, if

base is negative, indecimal. The decimal point expected is taken from the current locale, on systems providing

localeconv. The argument base may be in the ranges 2 to 62, or -62 to -2. Negative values are used tospecify that the exponent is in decimal.

For bases up to 36, case is ignored; upper-case and lower-case letters have the same value; forbases 37 to 62, upper-case letter represent the usual 10..35 while lower-case letter represent 36..61. Unlike the corresponding mpz function, the base will not be determined from the leadingcharacters of the string if

base is 0. This is so that numbers like `0.23' are not interpretedas octal.

White space is allowed in the string, and is simply ignored. [This is not really true; white-space is ignored in the beginning of the string and within the mantissa, but not in other places, such as after a minus sign or in the exponent. We are considering changing thedefinition of this function, making it fail when there is any white-space in the input, since that makes a lot of sense. Please tell us your opinion about this change. Do you really wantit to accept

"3 14" as meaning 314 as it does now?]

This function returns 0 if the entire string is a valid number in base base. Otherwise it returns-1.

[Function]void mpf_swap (mpf t rop1, mpf t rop2 )Swap rop1 and rop2 efficiently. Both the values and the precisions of the two variables areswapped.

7.3 Combined Initialization and Assignment Functions For convenience, GMP provides a parallel series of initialize-and-set functions which initialize theoutput and then store the value there. These functions' names have the form

mpf_init_set...

Chapter 7: Floating-point Functions 51 Once the float has been initialized by any of the mpf_init_set... functions, it can be used asthe source or destination operand for the ordinary float functions. Don't use an initialize-and-set function on a variable already initialized!

[Function]void mpf_init_set (mpf t rop, mpf t op ) [Function] void mpf_init_set_ui (mpf t rop, unsigned long int op ) [Function] void mpf_init_set_si (mpf t rop, signed long int op ) [Function] void mpf_init_set_d (mpf t rop, double op )Initialize

rop and set its value from op.

The precision of rop will be taken from the active default precision, as set by mpf_set_ default_prec.

[Function]int mpf_init_set_str (mpf t rop, char *str, int base )Initialize rop and set its value from the string in str. See mpf_set_str above for details onthe assignment operation.

Note that rop is initialized even if an error occurs. (I.e., you have to call mpf_clear for it.) The precision of rop will be taken from the active default precision, as set by mpf_set_ default_prec.

7.4 Conversion Functions

[Function]double mpf_get_d (mpf t op )Convert op to a double, truncating if necessary (ie. rounding towards zero).

If the exponent in op is too big or too small to fit a double then the result is system dependent.For too big an infinity is returned when available. For too small 0

.0 is normally returned.Hardware overflow, underflow and denorm traps may or may not occur.

[Function]double mpf_get_d_2exp (signed long int *exp, mpf t op )Convert op to a double, truncating if necessary (ie. rounding towards zero), and with anexponent returned separately.

The return value is in the range 0.5 <= |d| < 1 and the exponent is stored to *exp . d * 2exp isthe (truncated)

op value. If op is zero, the return is 0.0 and 0 is stored to *exp .

This is similar to the standard C frexp function (see Section "Normalization Functions" in The GNU C Library Reference Manual).

[Function]long mpf_get_si (mpf t op ) [Function] unsigned long mpf_get_ui (mpf t op )Convert

op to a long or unsigned long, truncating any fraction part. If op is too big forthe return type, the result is undefined.

See also mpf_fits_slong_p and mpf_fits_ulong_p (see Section 7.8 [Miscellaneous FloatFunctions], page 54).

[Function]char * mpf_get_str (char *str, mp exp t *expptr, int base, size t n_digits, mpf t op )Convert

op to a string of digits in base base. The base argument may vary from 2 to 62 orfrom -2 to -36. Up to

n digits digits will be generated. Trailing zeros are not returned.No more digits than can be accurately represented by

op are ever generated. If n digits is 0then that accurate maximum number of digits are generated.

52 GNU MP 4.2.3

For base in the range 2..36, digits and lower-case letters are used; for -2..-36, digits andupper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that significance order) are used. If str is NULL, the result string is allocated using the current allocation function (seeChapter 14 [Custom Allocation], page 85). The block will be

strlen(str)+1 bytes, thatbeing exactly enough for the string and null-terminator.

If str is not NULL, it should point to a block of n digits + 2 bytes, that being enough forthe mantissa, a possible minus sign, and a null-terminator. When

n digits is 0 to get allsignificant digits, an application won't be able to know the space required, and

str should be NULL in that case.

The generated string is a fraction, with an implicit radix point immediately to the left of thefirst digit. The applicable exponent is written through the

expptr pointer. For example, thenumber 3.1416 would be returned as string "31416" and exponent 1.

When op is zero, an empty string is produced and the exponent returned is 0. A pointer to the result string is returned, being either the allocated block or the given str.

7.5 Arithmetic Functions

[Function]void mpf_add (mpf t rop, mpf t op1, mpf t op2 ) [Function] void mpf_add_ui (mpf t rop, mpf t op1, unsigned long int op2 )Set

rop to op1 + op2.

[Function]void mpf_sub (mpf t rop, mpf t op1, mpf t op2 ) [Function] void mpf_ui_sub (mpf t rop, unsigned long int op1, mpf t op2 ) [Function] void mpf_sub_ui (mpf t rop, mpf t op1, unsigned long int op2 )Set

rop to op1 - op2.

[Function]void mpf_mul (mpf t rop, mpf t op1, mpf t op2 ) [Function] void mpf_mul_ui (mpf t rop, mpf t op1, unsigned long int op2 )Set

rop to op1 * op2.

Division is undefined if the divisor is zero, and passing a zero divisor to the divide functionswill make these functions intentionally divide by zero. This lets the user handle arithmetic exceptions in these functions in the same manner as other arithmetic exceptions.

[Function]void mpf_div (mpf t rop, mpf t op1, mpf t op2 ) [Function] void mpf_ui_div (mpf t rop, unsigned long int op1, mpf t op2 ) [Function] void mpf_div_ui (mpf t rop, mpf t op1, unsigned long int op2 )Set

rop to op1/op2.

[Function]void mpf_sqrt (mpf t rop, mpf t op ) [Function] void mpf_sqrt_ui (mpf t rop, unsigned long int op )Set

rop to pop.

[Function]void mpf_pow_ui (mpf t rop, mpf t op1, unsigned long int op2 )Set rop to op1op2.

[Function]void mpf_neg (mpf t rop, mpf t op )Set rop to -op.

Chapter 7: Floating-point Functions 53

[Function]void mpf_abs (mpf t rop, mpf t op )Set rop to the absolute value of op.

[Function]void mpf_mul_2exp (mpf t rop, mpf t op1, unsigned long int op2 )Set rop to op1 * 2op2.

[Function]void mpf_div_2exp (mpf t rop, mpf t op1, unsigned long int op2 )Set rop to op1/2op2.

7.6 Comparison Functions

[Function]int mpf_cmp (mpf t op1, mpf t op2 ) [Function] int mpf_cmp_d (mpf t op1, double op2 ) [Function] int mpf_cmp_ui (mpf t op1, unsigned long int op2 ) [Function] int mpf_cmp_si (mpf t op1, signed long int op2 )Compare

op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, and anegative value if

op1 < op2.

mpf_cmp_d can be called with an infinity, but results are undefined for a NaN.

[Function]int mpf_eq (mpf t op1, mpf t op2, unsigned long int op3)Return non-zero if the first op3 bits of op1 and op2 are equal, zero otherwise. I.e., test if op1 and op2 are approximately equal.

Caution: Currently only whole limbs are compared, and only in an exact fashion. In thefuture values like 1000 and 0111 may be considered the same to 3 bits (on the basis that their

difference is that small).

[Function]void mpf_reldiff (mpf t rop, mpf t op1, mpf t op2 )Compute the relative difference between op1 and op2 and store the result in rop. This is| op1 - op2|/op1.

[Macro]int mpf_sgn (mpf t op )Return +1 if op > 0, 0 if op = 0, and -1 if op < 0.

This function is actually implemented as a macro. It evaluates its arguments multiple times.

7.7 Input and Output Functions Functions that perform input from a stdio stream, and functions that output to a stdio stream.Passing a

NULL pointer for a stream argument to any of these functions will make them readfrom stdin and write to stdout, respectively.

When using any of these functions, it is a good idea to include `stdio.h' before `gmp.h', sincethat will allow `

gmp.h' to define prototypes for these functions.

[Function]size_t mpf_out_str (FILE *stream, int base, size t n_digits, mpf t op )Print op to stream, as a string of digits. Return the number of bytes written, or if an erroroccurred, return 0.

The mantissa is prefixed with an `0.' and is in the given base, which may vary from 2 to 62or from -2 to -36. An exponent is then printed, separated by an `

e', or if the base is greaterthan 10 then by an ` @'. The exponent is always in decimal. The decimal point follows thecurrent locale, on systems providing

localeconv.

54 GNU MP 4.2.3

For base in the range 2..36, digits and lower-case letters are used; for -2..-36, digits andupper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that significance order) are used. Up to n digits will be printed from the mantissa, except that no more digits than are accu-rately representable by

op will be printed. n digits can be 0 to select that accurate maximum.

[Function]size_t mpf_inp_str (mpf t rop, FILE *stream, int base )Read a string in base base from stream, and put the read float in rop. The string is ofthe form ` M@N' or, if the base is 10 or less, alternatively `MeN'. `M' is the mantissa and `N' isthe exponent. The mantissa is always in the specified base. The exponent is either in the

specified base or, if base is negative, in decimal. The decimal point expected is taken fromthe current locale, on systems providing

localeconv.

The argument base may be in the ranges 2 to 36, or -36 to -2. Negative values are used tospecify that the exponent is in decimal.

Unlike the corresponding mpz function, the base will not be determined from the leadingcharacters of the string if

base is 0. This is so that numbers like `0.23' are not interpretedas octal.

Return the number of bytes read, or if an error occurred, return 0. 7.8 Miscellaneous Functions

[Function]void mpf_ceil (mpf t rop, mpf t op ) [Function] void mpf_floor (mpf t rop, mpf t op ) [Function] void mpf_trunc (mpf t rop, mpf t op )Set

rop to op rounded to an integer. mpf_ceil rounds to the next higher integer, mpf_floorto the next lower, and

mpf_trunc to the integer towards zero.

[Function]int mpf_integer_p (mpf t op )Return non-zero if op is an integer.

[Function]int mpf_fits_ulong_p (mpf t op ) [Function] int mpf_fits_slong_p (mpf t op ) [Function] int mpf_fits_uint_p (mpf t op ) [Function] int mpf_fits_sint_p (mpf t op ) [Function] int mpf_fits_ushort_p (mpf t op ) [Function] int mpf_fits_sshort_p (mpf t op )Return non-zero if

op would fit in the respective C data type, when truncated to an integer.

[Function]void mpf_urandomb (mpf t rop, gmp randstate t state, unsigned long int nbits )Generate a uniformly distributed random float in

rop, such that 0 <= rop < 1, with nbitssignificant bits in the mantissa.

The variable state must be initialized by calling one of the gmp_randinit functions(Section 9.1 [Random State Initialization], page 64) before invoking this function.

[Function]void mpf_random2 (mpf t rop, mp size t max_size, mp exp t exp )Generate a random float of at most max size limbs, with long strings of zeros and onesin the binary representation. The exponent of the number is in the interval -

exp to exp(in limbs). This function is useful for testing functions and algorithms, since these kind of

Chapter 7: Floating-point Functions 55

random numbers have proven to be more likely to trigger corner-case bugs. Negative randomnumbers are generated when

max size is negative.

56 GNU MP 4.2.3 8 Low-level Functions This chapter describes low-level GMP functions, used to implement the high-level GMP func-tions, but also intended for time-critical user code.

These functions start with the prefix mpn_. The mpn functions are designed to be as fast as possible, not to provide a coherent callinginterface. The different functions have somewhat similar interfaces, but there are variations that

make them hard to use. These functions do as little as possible apart from the real multipleprecision computation, so that no time is spent on things that not all callers need.

A source operand is specified by a pointer to the least significant limb and a limb count. Adestination operand is specified by just a pointer. It is the responsibility of the caller to ensure that the destination has enough space for storing the result. With this way of specifying operands, it is possible to perform computations on subranges of anargument, and store the result into a subrange of a destination.

A common requirement for all functions is that each source area needs at least one limb. No sizeargument may be zero. Unless otherwise stated, in-place operations are allowed where source and destination are the same, but not where they only partly overlap. The mpn functions are the base for the implementation of the mpz_, mpf_, and mpq_ functions. This example adds the number beginning at s1p and the number beginning at s2p and writesthe sum at

destp. All areas have n limbs.

cy = mpn_add_n (destp, s1p, s2p, n) It should be noted that the mpn functions make no attempt to identify high or low zero limbson their operands, or other special forms. On random data such cases will be unlikely and it'd

be wasteful for every function to check every time. An application knowing something about itsdata can take steps to trim or perhaps split its calculations.

In the notation used below, a source operand is identified by the pointer to the least significantlimb, and the limb count in braces. For example,

{s1p, s1n}.

[Function]mp_limb_t mpn_add_n (mp limb t *rp, const mp limb t *s1p, const mp limb t *s2p, mp size t n )Add {s1p, n} and {s2p, n}, and write the n least significant limbs of the result to rp. Returncarry, either 0 or 1.

This is the lowest-level function for addition. It is the preferred function for addition, sinceit is written in assembly for most CPUs. For addition of a variable to itself (i.e.,

s1p equals s2p) use mpn_lshift with a count of 1 for optimal speed.

[Function]mp_limb_t mpn_add_1 (mp limb t *rp, const mp limb t *s1p, mp size t n, mp limb t s2limb )Add {s1p, n} and s2limb, and write the n least significant limbs of the result to rp. Returncarry, either 0 or 1.

[Function]mp_limb_t mpn_add (mp limb t *rp, const mp limb t *s1p, mp size t s1n, const mp limb t *s2p, mp size t s2n )Add {s1p, s1n} and {s2p, s2n}, and write the s1n least significant limbs of the result to rp.Return carry, either 0 or 1.

Chapter 8: Low-level Functions 57

This function requires that s1n is greater than or equal to s2n.

[Function]mp_limb_t mpn_sub_n (mp limb t *rp, const mp limb t *s1p, const mp limb t *s2p, mp size t n )Subtract

{s2p, n} from {s1p, n}, and write the n least significant limbs of the result to rp.Return borrow, either 0 or 1.

This is the lowest-level function for subtraction. It is the preferred function for subtraction,since it is written in assembly for most CPUs.

[Function]mp_limb_t mpn_sub_1 (mp limb t *rp, const mp limb t *s1p, mp size t n, mp limb t s2limb )Subtract

s2limb from {s1p, n}, and write the n least significant limbs of the result to rp.Return borrow, either 0 or 1.

[Function]mp_limb_t mpn_sub (mp limb t *rp, const mp limb t *s1p, mp size t s1n, const mp limb t *s2p, mp size t s2n )Subtract

{s2p, s2n} from {s1p, s1n}, and write the s1n least significant limbs of the resultto rp. Return borrow, either 0 or 1.

This function requires that s1n is greater than or equal to s2n.

[Function]void mpn_mul_n (mp limb t *rp, const mp limb t *s1p, const mp limb t *s2p, mp size t n )Multiply

{s1p, n} and {s2p, n}, and write the 2*n-limb result to rp.

The destination has to have space for 2*n limbs, even if the product's most significant limbis zero. No overlap is permitted between the destination and either source.

[Function]mp_limb_t mpn_mul_1 (mp limb t *rp, const mp limb t *s1p, mp size t n, mp limb t s2limb )Multiply

{s1p, n} by s2limb, and write the n least significant limbs of the product to rp.Return the most significant limb of the product.

{s1p, n} and {rp, n} are allowed to overlapprovided rp <= s1p.

This is a low-level function that is a building block for general multiplication as well as otheroperations in GMP. It is written in assembly for most CPUs.

Don't call this function if s2limb is a power of 2; use mpn_lshift with a count equal to thelogarithm of

s2limb instead, for optimal speed.

[Function]mp_limb_t mpn_addmul_1 (mp limb t *rp, const mp limb t *s1p, mp size t n, mp limb t s2limb )Multiply

{s1p, n} and s2limb, and add the n least significant limbs of the product to {rp, n}and write the result to

rp. Return the most significant limb of the product, plus carry-outfrom the addition.

This is a low-level function that is a building block for general multiplication as well as otheroperations in GMP. It is written in assembly for most CPUs.

[Function]mp_limb_t mpn_submul_1 (mp limb t *rp, const mp limb t *s1p, mp size t n, mp limb t s2limb )Multiply

{s1p, n} and s2limb, and subtract the n least significant limbs of the product from {rp, n} and write the result to rp. Return the most significant limb of the product, plusborrow-out from the subtraction.

58 GNU MP 4.2.3

This is a low-level function that is a building block for general multiplication and division aswell as other operations in GMP. It is written in assembly for most CPUs.

[Function]mp_limb_t mpn_mul (mp limb t *rp, const mp limb t *s1p, mp size t s1n, const mp limb t *s2p, mp size t s2n )Multiply

{s1p, s1n} and {s2p, s2n}, and write the result to rp. Return the most significantlimb of the result.

The destination has to have space for s1n + s2n limbs, even if the result might be one limbsmaller. This function requires that s1n is greater than or equal to s2n. The destination must bedistinct from both input operands.

[Function]void mpn_tdiv_qr (mp limb t *qp, mp limb t *rp, mp size t qxn, const mp limb t *np, mp size t nn, const mp limb t *dp, mp size t dn )Divide {np, nn} by {dp, dn} and put the quotient at {qp, nn-dn+1} and the remainder at {rp, dn}. The quotient is rounded towards 0.

No overlap is permitted between arguments. nn must be greater than or equal to dn. Themost significant limb of

dp must be non-zero. The qxn operand must be zero.

[Function]mp_limb_t mpn_divrem (mp limb t *r1p, mp size t qxn, mp limb t *rs2p, mp size t rs2n, const mp limb t *s3p, mp size t s3n )[This function is obsolete. Please call

mpn_tdiv_qr instead for best performance.]

Divide {rs2p, rs2n} by {s3p, s3n}, and write the quotient at r1p, with the exception of themost significant limb, which is returned. The remainder replaces the dividend at

rs2p; it willbe s3n limbs long (i.e., as many limbs as the divisor).

In addition to an integer quotient, qxn fraction limbs are developed, and stored after theintegral limbs. For most usages,

qxn will be zero.

It is required that rs2n is greater than or equal to s3n. It is required that the most significantbit of the divisor is set.

If the quotient is not needed, pass rs2p + s3n as r1p. Aside from that special case, no overlapbetween arguments is permitted. Return the most significant limb of the quotient, either 0 or 1. The area at r1p needs to be rs2n - s3n + qxn limbs large.

[Function]mp_limb_t mpn_divrem_1 (mp limb t *r1p, mp size t qxn, mp limb t *s2p , mp size t s2n, mp limb t s3limb ) [Macro] mp_limb_t mpn_divmod_1 (mp limb t *r1p, mp limb t *s2p, mp size t s2n ,

mp limb t s3limb )Divide {s2p, s2n} by s3limb, and write the quotient at r1p. Return the remainder.

The integer quotient is written to {r1p+qxn, s2n} and in addition qxn fraction limbs aredeveloped and written to

{r1p, qxn}. Either or both s2n and qxn can be zero. For mostusages, qxn will be zero.

mpn_divmod_1 exists for upward source compatibility and is simply a macro calling mpn_ divrem_1 with a qxn of 0.

Chapter 8: Low-level Functions 59

The areas at r1p and s2p have to be identical or completely separate, not partially overlap-ping.

[Function]mp_limb_t mpn_divmod (mp limb t *r1p, mp limb t *rs2p, mp size t rs2n, const mp limb t *s3p, mp size t s3n )[This function is obsolete. Please call

mpn_tdiv_qr instead for best performance.]

[Macro]mp_limb_t mpn_divexact_by3 (mp limb t *rp, mp limb t *sp, mp size t n ) [Function] mp_limb_t mpn_divexact_by3c (mp limb t *rp, mp limb t *sp,

mp size t n , mp limb t carry )Divide {sp, n} by 3, expecting it to divide exactly, and writing the result to {rp, n}. If 3divides exactly, the return value is zero and the result is the quotient. If not, the return value

is non-zero and the result won't be anything useful. mpn_divexact_by3c takes an initial carry parameter, which can be the return value froma previous call, so a large calculation can be done piece by piece from low to high.

mpn_ divexact_by3 is simply a macro calling mpn_divexact_by3c with a 0 carry parameter.

These routines use a multiply-by-inverse and will be faster than mpn_divrem_1 on CPUs withfast multiplication but slow division.

The source a, result q, size n, initial carry i, and return value c satisfy cbn + a - i = 3q, where b = 2GMP NUMB BITS. The return c is always 0, 1 or 2, and the initial carry i must also be 0,1 or 2 (these are both borrows really). When

c = 0 clearly q = (a - i)/3. When c 6= 0, theremainder ( a - i) mod 3 is given by 3 - c, because b j 1 mod 3 (when mp_bits_per_limb iseven, which is always so currently).

[Function]mp_limb_t mpn_mod_1 (mp limb t *s1p, mp size t s1n, mp limb t s2limb )Divide {s1p, s1n} by s2limb, and return the remainder. s1n can be zero.

[Function]mp_limb_t mpn_bdivmod (mp limb t *rp, mp limb t *s1p, mp size t s1n, const mp limb t *s2p, mp size t s2n, unsigned long int d )This function puts the low b

d/mp bits per limbc limbs of q = {s1p, s1n}/{s2p, s2n} mod2 d at rp, and returns the high d mod mp_bits_per_limb bits of q.

{s1p, s1n} - q * {s2p, s2n} mod 2s1n*mp bits per limb is placed at s1p. Since the lowb

d/mp bits per limbc limbs of this difference are zero, it is possible to overwrite the lowlimbs at

s1p with this difference, provided rp <= s1p.

This function requires that s1n * mp bits per limb >= D, and that {s2p, s2n} is odd. This interface is preliminary. It might change incompatibly in future revisions.

[Function]mp_limb_t mpn_lshift (mp limb t *rp, const mp limb t *sp, mp size t n, unsigned int count )Shift {sp, n} left by count bits, and write the result to {rp, n}. The bits shifted out at theleft are returned in the least significant

count bits of the return value (the rest of the returnvalue is zero).

count must be in the range 1 to mp_bits_per_limb-1. The regions {sp, n} and {rp, n} mayoverlap, provided

rp >= sp.

This function is written in assembly for most CPUs.

60 GNU MP 4.2.3

[Function]mp_limb_t mpn_rshift (mp limb t *rp, const mp limb t *sp, mp size t n, unsigned int count )Shift {sp, n} right by count bits, and write the result to {rp, n}. The bits shifted out atthe right are returned in the most significant

count bits of the return value (the rest of thereturn value is zero).

count must be in the range 1 to mp_bits_per_limb-1. The regions {sp, n} and {rp, n} mayoverlap, provided

rp <= sp.

This function is written in assembly for most CPUs.

[Function]int mpn_cmp (const mp limb t *s1p, const mp limb t *s2p, mp size t n )Compare {s1p, n} and {s2p, n} and return a positive value if s1 > s2, 0 if they are equal, ora negative value if

s1 < s2.

[Function]mp_size_t mpn_gcd (mp limb t *rp, mp limb t *s1p, mp size t s1n, mp limb t *s2p, mp size t s2n )Set {rp, retval} to the greatest common divisor of {s1p, s1n} and {s2p, s2n}. The result canbe up to

s2n limbs, the return value is the actual number produced. Both source operandsare destroyed.

{s1p, s1n} must have at least as many bits as {s2p, s2n}. {s2p, s2n} must be odd. Bothoperands must have non-zero most significant limbs. No overlap is permitted between

{s1p, s1n} and {s2p, s2n}.

[Function]mp_limb_t mpn_gcd_1 (const mp limb t *s1p, mp size t s1n, mp limb t s2limb )Return the greatest common divisor of

{s1p, s1n} and s2limb. Both operands must be non-zero.

[Function]mp_size_t mpn_gcdext (mp limb t *r1p, mp limb t *r2p, mp size t *r2n, mp limb t *s1p, mp size t s1n, mp limb t *s2p, mp size t s2n )Calculate the greatest common divisor of

{s1p, s1n} and {s2p, s2n}. Store the gcd at {r1p, retval} and the first cofactor at {r2p, *r2n}, with *r2n negative if the cofactor is negative. r1p and r2p should each have room for s1n + 1 limbs, but the return value and value storedthrough

r2n indicate the actual number produced.

{s1p, s1n} >= {s2p, s2n} is required, and both must be non-zero. The regions {s1p, s1n + 1}and

{s2p, s2n + 1} are destroyed (i.e. the operands plus an extra limb past the end of each).

The cofactor r1 will satisfy r2s1 + ks2 = r1. The second cofactor k is not calculated but caneasily be obtained from (

r1 - r2s1)/s2.

[Function]mp_size_t mpn_sqrtrem (mp limb t *r1p, mp limb t *r2p, const mp limb t *sp, mp size t n )Compute the square root of

{sp, n} and put the result at {r1p, dn/2e} and the remainderat {r2p, retval}. r2p needs space for n limbs, but the return value indicates how many areproduced.

The most significant limb of {sp, n} must be non-zero. The areas {r1p, dn/2e} and {sp, n}must be completely separate. The areas

{r2p, n} and {sp, n} must be either identical orcompletely separate.

If the remainder is not wanted then r2p can be NULL, and in this case the return value is zeroor non-zero according to whether the remainder would have been zero or non-zero.

Chapter 8: Low-level Functions 61

A return value of zero indicates a perfect square. See also mpz_perfect_square_p.

[Function]mp_size_t mpn_get_str (unsigned char *str, int base, mp limb t *s1p, mp size t s1n )Convert

{s1p, s1n} to a raw unsigned char array at str in base base, and return the numberof characters produced. There may be leading zeros in the string. The string is not in ASCII;

to convert it to printable format, add the ASCII codes for `0' or `A', depending on the baseand range.

base can vary from 2 to 256.

The most significant limb of the input {s1p, s1n} must be non-zero. The input {s1p, s1n} isclobbered, except when

base is a power of 2, in which case it's unchanged.

The area at str has to have space for the largest possible number represented by a s1n longlimb array, plus one extra character.

[Function]mp_size_t mpn_set_str (mp limb t *rp, const unsigned char *str, size t strsize, int base )Convert bytes

{str,strsize} in the given base to limbs at rp.

str[0] is the most significant byte and str[strsize - 1] is the least significant. Each byte shouldbe a value in the range 0 to

base - 1, not an ASCII character. base can vary from 2 to 256.

The return value is the number of limbs written to rp. If the most significant input byte isnon-zero then the high limb at

rp will be non-zero, and only that exact number of limbs willbe required there.

If the most significant input byte is zero then there may be high zero limbs written to rp andincluded in the return value. strsize must be at least 1, and no overlap is permitted between {str,strsize} and the resultat

rp.

[Function]unsigned long int mpn_scan0 (const mp limb t *s1p, unsigned long int bit )Scan s1p from bit position bit for the next clear bit.

It is required that there be a clear bit within the area at s1p at or beyond bit position bit,so that the function has something to return.

[Function]unsigned long int mpn_scan1 (const mp limb t *s1p, unsigned long int bit )Scan s1p from bit position bit for the next set bit.

It is required that there be a set bit within the area at s1p at or beyond bit position bit, sothat the function has something to return.

[Function]void mpn_random (mp limb t *r1p, mp size t r1n ) [Function] void mpn_random2 (mp limb t *r1p, mp size t r1n )Generate a random number of length

r1n and store it at r1p. The most significant limbis always non-zero. mpn_random generates uniformly distributed limb data, mpn_random2generates long strings of zeros and ones in the binary representation.

mpn_random2 is intended for testing the correctness of the mpn routines.

[Function]unsigned long int mpn_popcount (const mp limb t *s1p, mp size t n )Count the number of set bits in {s1p, n}.

62 GNU MP 4.2.3

[Function]unsigned long int mpn_hamdist (const mp limb t *s1p, const mp limb t *s2p, mp size t n )Compute the hamming distance between

{s1p, n} and {s2p, n}, which is the number of bitpositions where the two operands have different bit values.

[Function]int mpn_perfect_square_p (const mp limb t *s1p, mp size t n )Return non-zero iff {s1p, n} is a perfect square.

8.1 Nails Everything in this section is highly experimental and may disappear or be subject to incompatible changes in a future version of GMP.

Nails are an experimental feature whereby a few bits are left unused at the top of each mp_limb_ t. This can significantly improve carry handling on some processors.

All the mpn functions accepting limb data will expect the nail bits to be zero on entry, and willreturn data with the nails similarly all zero. This applies both to limb vectors and to single limb

arguments. Nails can be enabled by configuring with `--enable-nails'. By default the number of bits willbe chosen according to what suits the host processor, but a particular number can be selected

with `--enable-nails=N'. At the mpn level, a nail build is neither source nor binary compatible with a non-nail build,strictly speaking. But programs acting on limbs only through the mpn functions are likely to

work equally well with either build, and judicious use of the definitions below should make anyprogram compatible with either build, at the source level.

For the higher level routines, meaning mpz etc, a nail build should be fully source and binarycompatible with a non-nail build.

[Macro]GMP_NAIL_BITS [Macro] GMP_NUMB_BITS [Macro] GMP_LIMB_BITS

GMP_NAIL_BITS is the number of nail bits, or 0 when nails are not in use. GMP_NUMB_BITSis the number of data bits in a limb.

GMP_LIMB_BITS is the total number of bits in an mp_limb_t. In all cases

GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS

[Macro]GMP_NAIL_MASK [Macro] GMP_NUMB_MASKBit masks for the nail and number parts of a limb.

GMP_NAIL_MASK is 0 when nails are notin use.

GMP_NAIL_MASK is not often needed, since the nail part can be obtained with x >> GMP_NUMB_ BITS, and that means one less large constant, which can help various RISC chips.

[Macro]GMP_NUMB_MAXThe maximum value that can be stored in the number part of a limb. This is the same as GMP_NUMB_MASK, but can be used for clarity when doing comparisons rather than bit-wiseoperations.

Chapter 8: Low-level Functions 63 The term "nails" comes from finger or toe nails, which are at the ends of a limb (arm or leg)."numb" is short for number, but is also how the developers felt after trying for a long time to come up with sensible names for these things. In the future (the distant future most likely) a non-zero nail might be permitted, giving non-unique representations for numbers in a limb vector. This would help vector processors since

carries would only ever need to propagate one or two limbs.

64 GNU MP 4.2.3 9 Random Number Functions Sequences of pseudo-random numbers in GMP are generated using a variable of type gmp_ randstate_t, which holds an algorithm selection and a current state. Such a variable must beinitialized by a call to one of the

gmp_randinit functions, and can be seeded with one of the gmp_randseed functions.

The functions actually generating random numbers are described in Section 5.13 [Integer Ran-dom Numbers], page 40, and Section 7.8 [Miscellaneous Float Functions], page 54.

The older style random number functions don't accept a gmp_randstate_t parameter but in-stead share a global variable of that type. They use a default algorithm and are currently not seeded (though perhaps that will change in the future). The new functions accepting a gmp_randstate_t are recommended for applications that care about randomness.

9.1 Random State Initialization

[Function]void gmp_randinit_default (gmp randstate t state )Initialize state with a default algorithm. This will be a compromise between speed andrandomness, and is recommended for applications with no special requirements. Currently

this is gmp_randinit_mt.

[Function]void gmp_randinit_mt (gmp randstate t state )Initialize state for a Mersenne Twister algorithm. This algorithm is fast and has good ran-domness properties.

[Function]void gmp_randinit_lc_2exp (gmp randstate t state, mpz t a, unsigned long c , unsigned long m2exp )Initialize

state with a linear congruential algorithm X = (aX + c) mod 2m2exp.

The low bits of X in this algorithm are not very random. The least significant bit will havea period no more than 2, and the second bit no more than 4, etc. For this reason only the

high half of each X is actually used. When a random number of more than m2exp/2 bits is to be generated, multiple iterationsof the recurrence are used and the results concatenated.

[Function]int gmp_randinit_lc_2exp_size (gmp randstate t state, unsigned long size )Initialize

state for a linear congruential algorithm as per gmp_randinit_lc_2exp. a, c and m2exp are selected from a table, chosen so that size bits (or more) of each X will be used,ie.

m2exp/2 >= size.

If successful the return value is non-zero. If size is bigger than the table data provides thenthe return value is zero. The maximum

size currently supported is 128.

[Function]void gmp_randinit_set (gmp randstate t rop, gmp randstate t op )Initialize rop with a copy of the algorithm and state from op.

[Function]void gmp_randinit (gmp randstate t state, gmp randalg t alg , . . . ) This function is obsolete.

Initialize state with an algorithm selected by alg. The only choice is GMP_RAND_ALG_LC, whichis

gmp_randinit_lc_2exp_size described above. A third parameter of type unsigned long

Chapter 9: Random Number Functions 65

is required, this is the size for that function. GMP_RAND_ALG_DEFAULT or 0 are the same as GMP_RAND_ALG_LC.

gmp_randinit sets bits in the global variable gmp_errno to indicate an error. GMP_ERROR_ UNSUPPORTED_ARGUMENT if alg is unsupported, or GMP_ERROR_INVALID_ARGUMENT if the sizeparameter is too big. It may be noted this error reporting is not thread safe (a good reason

to use gmp_randinit_lc_2exp_size instead).

[Function]void gmp_randclear (gmp randstate t state )Free all memory occupied by state.

9.2 Random State Seeding

[Function]void gmp_randseed (gmp randstate t state, mpz t seed ) [Function] void gmp_randseed_ui (gmp randstate t state, unsigned long int seed )Set an initial seed value into

state.

The size of a seed determines how many different sequences of random numbers that it'spossible to generate. The "quality" of the seed is the randomness of a given seed compared

to the previous seed used, and this affects the randomness of separate number sequences. Themethod for choosing a seed is critical if the generated numbers are to be used for important applications, such as generating cryptographic keys. Traditionally the system time has been used to seed, but care needs to be taken with this.If an application seeds often and the resolution of the system clock is low, then the same

sequence of numbers might be repeated. Also, the system time is quite easy to guess, so ifunpredictability is required then it should definitely not be the only source for the seed value. On some systems there's a special device `/dev/random' which provides random data bettersuited for use as a seed.

9.3 Random State Miscellaneous

[Function]unsigned long gmp_urandomb_ui (gmp randstate t state, unsigned long n )Return a uniformly distributed random number of

n bits, ie. in the range 0 to 2n - 1 inclusive. n must be less than or equal to the number of bits in an unsigned long.

[Function]unsigned long gmp_urandomm_ui (gmp randstate t state, unsigned long n )Return a uniformly distributed random number in the range 0 to

n - 1, inclusive.

66 GNU MP 4.2.3 10 Formatted Output 10.1 Format Strings gmp_printf and friends accept format strings similar to the standard C printf (see Section"Formatted Output" in

The GNU C Library Reference Manual). A format specification is ofthe form

% [flags] [width] [.[precision]] [type] conv GMP adds types `Z', `Q' and `F' for mpz_t, mpq_t and mpf_t respectively, `M' for mp_limb_t,and `

N' for an mp_limb_t array. `Z', `Q', `M' and `N' behave like integers. `Q' will print a `/' anda denominator, if needed. `

F' behaves like a float. For example,

mpz_t z; gmp_printf ("%s is an mpz %Zd\n", "here", z);

mpq_t q; gmp_printf ("a hex rational: %#40Qx\n", q);

mpf_t f; int n; gmp_printf ("fixed point mpf %.*Ff with %d digits\n", n, f, n);

mp_limb_t l; gmp_printf ("limb %Mu\n", limb);

const mp_limb_t *ptr; mp_size_t size; gmp_printf ("limb array %Nx\n", ptr, size);

For `N' the limbs are expected least significant first, as per the mpn functions (see Chapter 8[Low-level Functions], page 56). A negative size can be given to print the value as a negative.

All the standard C printf types behave the same as the C library printf, and can be freelyintermixed with the GMP extensions. In the current implementation the standard parts of the format string are simply handed to printf and only the GMP extensions handled directly. The flags accepted are as follows. GLIBC style `'' is only for the standard C types (not theGMP types), and only if the C library supports it.

0 pad with zeros (rather than spaces) # show the base with `0x', `0X' or `0' + always show a sign (space) show a space or a `-' sign ' group digits, GLIBC style (not GMP types)

The optional width and precision can be given as a number within the format string, or as a `*'to take an extra parameter of type

int, the same as the standard printf.

The standard types accepted are as follows. `h' and `l' are portable, the rest will depend on thecompiler (or include files) for the type and the C library for the output.

h short hh char

Chapter 10: Formatted Output 67

j intmax_t or uintmax_t l long or wchar_t ll long long L long double q quad_t or u_quad_t t ptrdiff_t z size_t

The GMP types are

F mpf_t, float conversions Q mpq_t, integer conversions M mp_limb_t, integer conversions N mp_limb_t array, integer conversions Z mpz_t, integer conversions

The conversions accepted are as follows. `a' and `A' are always supported for mpf_t but dependon the C library for standard C float types. `

m' and `p' depend on the C library.

a A hex floats, C99 style c character d decimal integer e E scientific format float f fixed point float i same as d g G fixed or scientific float m strerror string, GLIBC style n store characters written so far o octal integer p pointer s string u unsigned integer x X hex integer

`o', `x' and `X' are unsigned for the standard C types, but for types `Z', `Q' and `N' they aresigned. `

u' is not meaningful for `Z', `Q' and `N'.

`M' is a proxy for the C library `l' or `L', according to the size of mp_limb_t. Unsigned conver-sions will be usual, but a signed conversion can be used and will interpret the value as a twos

complement negative. `n' can be used with any type, even the GMP types. Other types or conversions that might be accepted by the C library printf cannot be usedthrough

gmp_printf, this includes for instance extensions registered with GLIBC register_ printf_function. Also currently there's no support for POSIX `$' style numbered arguments(perhaps this will be added in the future).

The precision field has it's usual meaning for integer `Z' and float `F' types, but is currentlyundefined for `

Q' and should not be used with that.

mpf_t conversions only ever generate as many digits as can be accurately represented by theoperand, the same as

mpf_get_str does. Zeros will be used if necessary to pad to the requestedprecision. This happens even for an `

f' conversion of an mpf_t which is an integer, for instance

68 GNU MP 4.2.3 21024 in an mpf_t of 128 bits precision will only produce about 40 digits, then pad with zerosto the decimal point. An empty precision field like `

%.Fe' or `%.Ff' can be used to specificallyrequest just the significant digits.

The decimal point character (or string) is taken from the current locale settings on systems whichprovide

localeconv (see Section "Locales and Internationalization" in The GNU C Library Reference Manual). The C library will normally do the same for standard float output.

The format string is only interpreted as plain chars, multibyte characters are not recognised.Perhaps this will change in the future.

10.2 Functions Each of the following functions is similar to the corresponding C library function. The basic printf forms take a variable argument list. The vprintf forms take an argument pointer, seeSection "Variadic Functions" in

The GNU C Library Reference Manual, or `man 3 va_start'.

It should be emphasised that if a format string is invalid, or the arguments don't match whatthe format specifies, then the behaviour of any of these functions will be unpredictable. GCC

format string checking is not available, since it doesn't recognise the GMP extensions. The file based functions gmp_printf and gmp_fprintf will return -1 to indicate a write error.Output is not "atomic", so partial output may be produced if a write error occurs. All the

functions can return -1 if the C library printf variant in use returns -1, but this shouldn'tnormally occur.

[Function]int gmp_printf (const char *fmt, . . . ) [Function] int gmp_vprintf (const char *fmt, va list ap )Print to the standard output

stdout. Return the number of characters written, or -1 if anerror occurred.

[Function]int gmp_fprintf (FILE *fp, const char *fmt, . . . ) [Function] int gmp_vfprintf (FILE *fp, const char *fmt, va list ap )Print to the stream

fp. Return the number of characters written, or -1 if an error occurred.

[Function]int gmp_sprintf (char *buf, const char *fmt, . . . ) [Function] int gmp_vsprintf (char *buf, const char *fmt, va list ap )Form a null-terminated string in

buf. Return the number of characters written, excludingthe terminating null.

No overlap is permitted between the space at buf and the string fmt. These functions are not recommended, since there's no protection against exceeding the spaceavailable at

buf.

[Function]int gmp_snprintf (char *buf, size t size, const char *fmt, . . . ) [Function] int gmp_vsnprintf (char *buf, size t size, const char *fmt, va list ap )Form a null-terminated string in

buf. No more than size bytes will be written. To get thefull output, size must be enough for the string and null-terminator.

The return value is the total number of characters which ought to have been produced,excluding the terminating null. If

retval >= size then the actual output has been truncated tothe first size - 1 characters, and a null appended.

No overlap is permitted between the region {buf,size} and the fmt string.

Chapter 10: Formatted Output 69

Notice the return value is in ISO C99 snprintf style. This is so even if the C library vsnprintf is the older GLIBC 2.0.x style.

[Function]int gmp_asprintf (char **pp, const char *fmt, . . . ) [Function] int gmp_vasprintf (char **pp, const char *fmt, va list ap )Form a null-terminated string in a block of memory obtained from the current memory

allocation function (see Chapter 14 [Custom Allocation], page 85). The block will be the sizeof the string and null-terminator. The address of the block in stored to *

pp. The returnvalue is the number of characters produced, excluding the null-terminator.

Unlike the C library asprintf, gmp_asprintf doesn't return -1 if there's no more memoryavailable, it lets the current allocation function handle that.

[Function]int gmp_obstack_printf (struct obstack *ob, const char *fmt, . . . ) [Function] int gmp_obstack_vprintf (struct obstack *ob, const char *fmt, va list ap )Append to the current object in

ob. The return value is the number of characters written.A null-terminator is not written.

fmt cannot be within the current object in ob, since that object might move as it grows. These functions are available only when the C library provides the obstack feature, whichprobably means only on GNU systems, see Section "Obstacks" in

The GNU C Library Reference Manual.

10.3 C++ Formatted Output The following functions are provided in `libgmpxx' (see Section 3.1 [Headers and Libraries],page 16), which is built if C

++ support is enabled (see Section 2.1 [Build Options], page 3).Prototypes are available from

<gmp.h>.

[Function]ostream& operator<< (ostream& stream, mpz t op )Print op to stream, using its ios formatting settings. ios::width is reset to 0 after output,the same as the standard

ostream operator<< routines do.

In hex or octal, op is printed as a signed number, the same as for decimal. This is unlike thestandard

operator<< routines on int etc, which instead give twos complement.

[Function]ostream& operator<< (ostream& stream, mpq t op )Print op to stream, using its ios formatting settings. ios::width is reset to 0 after output,the same as the standard

ostream operator<< routines do.

Output will be a fraction like `5/9', or if the denominator is 1 then just a plain integer like`

123'.

In hex or octal, op is printed as a signed value, the same as for decimal. If ios::showbase isset then a base indicator is shown on both the numerator and denominator (if the denominator

is required).

[Function]ostream& operator<< (ostream& stream, mpf t op )Print op to stream, using its ios formatting settings. ios::width is reset to 0 after output,the same as the standard

ostream operator<< routines do.

The decimal point follows the standard library float operator<<, which on recent systemsmeans the

std::locale imbued on stream.

70 GNU MP 4.2.3

Hex and octal are supported, unlike the standard operator<< on double. The mantissa willbe in hex or octal, the exponent will be in decimal. For hex the exponent delimiter is an `

@'.This is as per mpf_out_str.

ios::showbase is supported, and will put a base on the mantissa, for example hex `0x1.8' or`

0x0.8', or octal `01.4' or `00.4'. This last form is slightly strange, but at least differentiatesitself from decimal.

These operators mean that GMP types can be printed in the usual C++ way, for example,

mpz_t z; int n; ... cout << "iteration " << n << " value " << z << "\n";

But note that ostream output (and istream input, see Section 11.3 [C++ Formatted Input],page 73) is the only overloading available for the GMP types and that for instance using

+ withan mpz_t will have unpredictable results. For classes with overloading, see Chapter 12 [C++Class Interface], page 75.

Chapter 11: Formatted Input 71 11 Formatted Input 11.1 Formatted Input Strings gmp_scanf and friends accept format strings similar to the standard C scanf (see Section"Formatted Input" in

The GNU C Library Reference Manual). A format specification is of theform

% [flags] [width] [type] conv GMP adds types `Z', `Q' and `F' for mpz_t, mpq_t and mpf_t respectively. `Z' and `Q' behave likeintegers. `

Q' will read a `/' and a denominator, if present. `F' behaves like a float.

GMP variables don't require an & when passed to gmp_scanf, since they're already "call-by-reference". For example,

/* to read say "a(5) = 1234" */ int n; mpz_t z; gmp_scanf ("a(%d) = %Zd\n", &n, z);

mpq_t q1, q2; gmp_sscanf ("0377 + 0x10/0x11", "%Qi + %Qi", q1, q2);

/* to read say "topleft (1.55,-2.66)" */ mpf_t x, y; char buf[32]; gmp_scanf ("%31s (%Ff,%Ff)", buf, x, y);

All the standard C scanf types behave the same as in the C library scanf, and can be freelyintermixed with the GMP extensions. In the current implementation the standard parts of the

format string are simply handed to scanf and only the GMP extensions handled directly. The flags accepted are as follows. `a' and `'' will depend on support from the C library, and `''cannot be used with GMP types.

* read but don't store a allocate a buffer (string conversions) ' grouped digits, GLIBC style (not GMP types)

The standard types accepted are as follows. `h' and `l' are portable, the rest will depend on thecompiler (or include files) for the type and the C library for the input.

h short hh char j intmax_t or uintmax_t l long int, double or wchar_t ll long long L long double q quad_t or u_quad_t t ptrdiff_t z size_t

The GMP types are

72 GNU MP 4.2.3

F mpf_t, float conversions Q mpq_t, integer conversions Z mpz_t, integer conversions

The conversions accepted are as follows. `p' and `[' will depend on support from the C library,the rest are standard.

c character or characters d decimal integer e E f g G float i integer with base indicator n characters read so far o octal integer p pointer s string of non-whitespace characters u decimal integer x X hex integer [ string of characters in a set

`e', `E', `f', `g' and `G' are identical, they all read either fixed point or scientific format, andeither upper or lower case `

e' for the exponent in scientific format.

C99 style hex float format (printf %a, see Section 10.1 [Formatted Output Strings], page 66) isalways accepted for

mpf_t, but for the standard float types it will depend on the C library.

`x' and `X' are identical, both accept both upper and lower case hexadecimal. `o', `u', `x' and `X' all read positive or negative values. For the standard C types these aredescribed as "unsigned" conversions, but that merely affects certain overflow handling, negatives

are still allowed (per strtoul, see Section "Parsing of Integers" in The GNU C Library Reference Manual). For GMP types there are no overflows, so `d' and `u' are identical.

`Q' type reads the numerator and (optional) denominator as given. If the value might not be incanonical form then

mpq_canonicalize must be called before using it in any calculations (seeChapter 6 [Rational Number Functions], page 44).

`Qi' will read a base specification separately for the numerator and denominator. For example`

0x10/11' would be 16/11, whereas `0x10/0x11' would be 16/17.

`n' can be used with any of the types above, even the GMP types. `*' to suppress assignment isallowed, though in that case it would do nothing at all.

Other conversions or types that might be accepted by the C library scanf cannot be usedthrough

gmp_scanf.

Whitespace is read and discarded before a field, except for `c' and `[' conversions. For float conversions, the decimal point character (or string) expected is taken from the currentlocale settings on systems which provide

localeconv (see Section "Locales and International-ization" in The GNU C Library Reference Manual). The C library will normally do the samefor standard float input.

The format string is only interpreted as plain chars, multibyte characters are not recognised.Perhaps this will change in the future.

Chapter 11: Formatted Input 73 11.2 Formatted Input Functions Each of the following functions is similar to the corresponding C library function. The plain scanf forms take a variable argument list. The vscanf forms take an argument pointer, seeSection "Variadic Functions" in

The GNU C Library Reference Manual, or `man 3 va_start'.

It should be emphasised that if a format string is invalid, or the arguments don't match whatthe format specifies, then the behaviour of any of these functions will be unpredictable. GCC

format string checking is not available, since it doesn't recognise the GMP extensions. No overlap is permitted between the fmt string and any of the results produced.

[Function]int gmp_scanf (const char *fmt, . . . ) [Function] int gmp_vscanf (const char *fmt, va list ap )Read from the standard input

stdin.

[Function]int gmp_fscanf (FILE *fp, const char *fmt, . . . ) [Function] int gmp_vfscanf (FILE *fp, const char *fmt, va list ap )Read from the stream

fp.

[Function]int gmp_sscanf (const char *s, const char *fmt, . . . ) [Function] int gmp_vsscanf (const char *s, const char *fmt, va list ap )Read from a null-terminated string

s.

The return value from each of these functions is the same as the standard C99 scanf, namelythe number of fields successfully parsed and stored. `

%n' fields and fields read but suppressed by` *' don't count towards the return value.

If end of input (or a file error) is reached before a character for a field or a literal, and ifno previous non-suppressed fields have matched, then the return value is

EOF instead of 0. Awhitespace character in the format string is only an optional match and doesn't induce an

EOFin this fashion. Leading whitespace read and discarded for a field don't count as characters for

that field. For the GMP types, input parsing follows C99 rules, namely one character of lookahead is usedand characters are read while they continue to meet the format requirements. If this doesn't

provide a complete number then the function terminates, with that field not stored nor countedtowards the return value. For instance with

mpf_t an input `1.23e-XYZ' would be read up tothe ` X' and that character pushed back since it's not a digit. The string `1.23e-' would then beconsidered invalid since an `

e' must be followed by at least one digit.

For the standard C types, in the current implementation GMP calls the C library scanf func-tions, which might have looser rules about what constitutes a valid input.

Note that gmp_sscanf is the same as gmp_fscanf and only does one character of lookaheadwhen parsing. Although clearly it could look at its entire input, it is deliberately made identical to gmp_fscanf, the same way C99 sscanf is the same as fscanf. 11.3 C++ Formatted Input The following functions are provided in `libgmpxx' (see Section 3.1 [Headers and Libraries],page 16), which is built only if C

++ support is enabled (see Section 2.1 [Build Options], page 3).Prototypes are available from <gmp.h>.

[Function]istream& operator>> (istream& stream, mpz t rop )Read rop from stream, using its ios formatting settings.

74 GNU MP 4.2.3

[Function]istream& operator>> (istream& stream, mpq t rop )An integer like ` 123' will be read, or a fraction like `5/9'. No whitespace is allowed aroundthe ` /'. If the fraction is not in canonical form then mpq_canonicalize must be called (seeChapter 6 [Rational Number Functions], page 44) before operating on it.

As per integer input, an `0' or `0x' base indicator is read when none of ios::dec, ios::octor

ios::hex are set. This is done separately for numerator and denominator, so that forinstance `

0x10/11' is 16/11 and `0x10/0x11' is 16/17.

[Function]istream& operator>> (istream& stream, mpf t rop )Read rop from stream, using its ios formatting settings.

Hex or octal floats are not supported, but might be in the future, or perhaps it's best toaccept only what the standard float

operator>> does.

Note that digit grouping specified by the istream locale is currently not accepted. Perhaps thiswill change in the future.

These operators mean that GMP types can be read in the usual C++ way, for example,

mpz_t z; ... cin >> z;

But note that istream input (and ostream output, see Section 10.3 [C++ Formatted Output],page 69) is the only overloading available for the GMP types and that for instance using

+ withan mpz_t will have unpredictable results. For classes with overloading, see Chapter 12 [C++Class Interface], page 75.

Chapter 12: C++ Class Interface 75 12 C++ Class Interface This chapter describes the C++ class based interface to GMP. All GMP C language types and functions can be used in C++ programs, since `gmp.h' has extern "C" qualifiers, but the class interface offers overloaded functions and operators which may bemore convenient.

Due to the implementation of this interface, a reasonably recent C++ compiler is required, onesupporting namespaces, partial specialization of templates and member templates. For GCC this means version 2.91 or later. Everything described in this chapter is to be considered preliminary and might be subject to incompatible changes if some unforeseen difficulty reveals itself.

12.1 C++ Interface General All the C++ classes and functions are available with

#include <gmpxx.h> Programs should be linked with the `libgmpxx' and `libgmp' libraries. For example,

g++ mycxxprog.cc -lgmpxx -lgmp The classes defined are

[Class]mpz_class [Class] mpq_class [Class] mpf_classThe standard operators and various standard functions are overloaded to allow arithmetic with

these classes. For example,

int main (void) {

mpz_class a, b, c;

a = 1234; b = "-5678"; c = a+b; cout << "sum is " << c << "\n"; cout << "absolute value is " << abs(c) << "\n";

return 0; }

An important feature of the implementation is that an expression like a=b+c results in a singlecall to the corresponding

mpz_add, without using a temporary for the b+c part. Expressionswhich by their nature imply intermediate values, like

a=b*c+d*e, still use temporaries though.

The classes can be freely intermixed in expressions, as can the classes and the standard types long, unsigned long and double. Smaller types like int or float can also be intermixed, sinceC

++ will promote them.

Note that bool is not accepted directly, but must be explicitly cast to an int first. This isbecause C

++ will automatically convert any pointer to a bool, so if GMP accepted bool it

76 GNU MP 4.2.3 would make all sorts of invalid class and pointer combinations compile but almost certainly notdo anything sensible. Conversions back from the classes to standard C++ types aren't done automatically, insteadmember functions like

get_si are provided (see the following sections for details).

Also there are no automatic conversions from the classes to the corresponding GMP C types,instead a reference to the underlying C object can be obtained with the following functions,

[Function]mpz_t mpz_class::get_mpz_t () [Function] mpq_t mpq_class::get_mpq_t () [Function] mpf_t mpf_class::get_mpf_t ()These can be used to call a C function which doesn't have a C

++ class interface. For exampleto set a to the GCD of b and c,

mpz_class a, b, c; ... mpz_gcd (a.get_mpz_t(), b.get_mpz_t(), c.get_mpz_t());

In the other direction, a class can be initialized from the corresponding GMP C type, or assignedto if an explicit constructor is used. In both cases this makes a copy of the value, it doesn't

create any sort of association. For example,

mpz_t z; // ... init and calculate z ... mpz_class x(z); mpz_class y; y = mpz_class (z);

There are no namespace setups in `gmpxx.h', all types and functions are simply put into theglobal namespace. This is what `

gmp.h' has done in the past, and continues to do for compat-ibility. The extras provided by ` gmpxx.h' follow GMP naming conventions and are unlikely toclash with anything.

12.2 C++ Interface Integers

[Function]void mpz_class::mpz_class (type n )Construct an mpz_class. All the standard C++ types may be used, except long long and long double, and all the GMP C++ classes can be used. Any necessary conversion follows thecorresponding C function, for example

double follows mpz_set_d (see Section 5.2 [AssigningIntegers], page 29).

[Function]void mpz_class::mpz_class (mpz t z )Construct an mpz_class from an mpz_t. The value in z is copied into the new mpz_class,there won't be any permanent association between it and

z.

[Function]void mpz_class::mpz_class (const char *s ) [Function] void mpz_class::mpz_class (const char *s, int base = 0) [Function] void mpz_class::mpz_class (const string& s ) [Function] void mpz_class::mpz_class (const string& s, int base = 0)Construct an

mpz_class converted from a string using mpz_set_str (see Section 5.2 [As-signing Integers], page 29).

If the string is not a valid integer, an std::invalid_argument exception is thrown. Thesame applies to

operator=.

Chapter 12: C++ Class Interface 77

[Function]mpz_class operator/ (mpz class a, mpz class d ) [Function] mpz_class operator% (mpz class a, mpz class d )Divisions involving

mpz_class round towards zero, as per the mpz_tdiv_q and mpz_tdiv_rfunctions (see Section 5.6 [Integer Division], page 32). This is the same as the C99

/ and %operators.

The mpz_fdiv... or mpz_cdiv... functions can always be called directly if desired. Forexample,

mpz_class q, a, d; ... mpz_fdiv_q (q.get_mpz_t(), a.get_mpz_t(), d.get_mpz_t());

[Function]mpz_class abs (mpz class op1 ) [Function] int cmp (mpz class op1, type op2 ) [Function] int cmp (type op1, mpz class op2 ) [Function] bool mpz_class::fits_sint_p (void) [Function] bool mpz_class::fits_slong_p (void) [Function] bool mpz_class::fits_sshort_p (void) [Function] bool mpz_class::fits_uint_p (void) [Function] bool mpz_class::fits_ulong_p (void) [Function] bool mpz_class::fits_ushort_p (void) [Function] double mpz_class::get_d (void) [Function] long mpz_class::get_si (void) [Function] string mpz_class::get_str (int base = 10) [Function] unsigned long mpz_class::get_ui (void) [Function] int mpz_class::set_str (const char *str, int base ) [Function] int mpz_class::set_str (const string& str, int base ) [Function] int sgn (mpz class op ) [Function] mpz_class sqrt (mpz class op )These functions provide a C

++ class interface to the corresponding GMP C routines.

cmp can be used with any of the classes or the standard C++ types, except long long and long double.

Overloaded operators for combinations of mpz_class and double are provided for completeness,but it should be noted that if the given

double is not an integer then the way any rounding isdone is currently unspecified. The rounding might take place at the start, in the middle, or at

the end of the operation, and it might change in the future. Conversions between mpz_class and double, however, are defined to follow the correspondingC functions

mpz_get_d and mpz_set_d. And comparisons are always made exactly, as per mpz_cmp_d.

12.3 C++ Interface Rationals In all the following constructors, if a fraction is given then it should be in canonical form, or ifnot then

mpq_class::canonicalize called.

[Function]void mpq_class::mpq_class (type op ) [Function] void mpq_class::mpq_class (integer num, integer den )Construct an

mpq_class. The initial value can be a single value of any type, or a pair ofintegers ( mpz_class or standard C++ integer types) representing a fraction, except that long long and long double are not supported. For example,

78 GNU MP 4.2.3

mpq_class q (99); mpq_class q (1.75); mpq_class q (1, 3);

[Function]void mpq_class::mpq_class (mpq t q )Construct an mpq_class from an mpq_t. The value in q is copied into the new mpq_class,there won't be any permanent association between it and

q.

[Function]void mpq_class::mpq_class (const char *s ) [Function] void mpq_class::mpq_class (const char *s, int base = 0) [Function] void mpq_class::mpq_class (const string& s ) [Function] void mpq_class::mpq_class (const string& s, int base = 0)Construct an

mpq_class converted from a string using mpq_set_str (see Section 6.1 [Initial-izing Rationals], page 44).

If the string is not a valid rational, an std::invalid_argument exception is thrown. Thesame applies to

operator=.

[Function]void mpq_class::canonicalize ()Put an mpq_class into canonical form, as per Chapter 6 [Rational Number Functions],page 44. All arithmetic operators require their operands in canonical form, and will return

results in canonical form.

[Function]mpq_class abs (mpq class op ) [Function] int cmp (mpq class op1, type op2 ) [Function] int cmp (type op1, mpq class op2 ) [Function] double mpq_class::get_d (void) [Function] string mpq_class::get_str (int base = 10) [Function] int mpq_class::set_str (const char *str, int base ) [Function] int mpq_class::set_str (const string& str, int base ) [Function] int sgn (mpq class op )These functions provide a C

++ class interface to the corresponding GMP C routines.

cmp can be used with any of the classes or the standard C++ types, except long long and long double.

[Function]mpz_class& mpq_class::get_num () [Function] mpz_class& mpq_class::get_den ()Get a reference to an

mpz_class which is the numerator or denominator of an mpq_class.This can be used both for read and write access. If the object returned is modified, it modifies

the original mpq_class. If direct manipulation might produce a non-canonical value, then mpq_class::canonicalizemust be called before further operations.

[Function]mpz_t mpq_class::get_num_mpz_t () [Function] mpz_t mpq_class::get_den_mpz_t ()Get a reference to the underlying

mpz_t numerator or denominator of an mpq_class. Thiscan be passed to C functions expecting an

mpz_t. Any modifications made to the mpz_t willmodify the original mpq_class.

If direct manipulation might produce a non-canonical value, then mpq_class::canonicalizemust be called before further operations.

Chapter 12: C++ Class Interface 79

[Function]istream& operator>> (istream& stream, mpq class& rop );Read rop from stream, using its ios formatting settings, the same as mpq_t operator>> (seeSection 11.3 [C

++ Formatted Input], page 73).

If the rop read might not be in canonical form then mpq_class::canonicalize must becalled.

12.4 C++ Interface Floats When an expression requires the use of temporary intermediate mpf_class values, like f=g*h+x*y, those temporaries will have the same precision as the destination f. Explicit con-structors can be used if this doesn't suit.

[Function]mpf_class::mpf_class (type op ) [Function] mpf_class::mpf_class (type op, unsigned long prec )Construct an

mpf_class. Any standard C++ type can be used, except long long and long double, and any of the GMP C++ classes can be used.

If prec is given, the initial precision is that value, in bits. If prec is not given, then theinitial precision is determined by the type of

op given. An mpz_class, mpq_class, or C++builtin type will give the default mpf precision (see Section 7.1 [Initializing Floats], page 48).An mpf_class or expression will give the precision of that value. The precision of a binaryexpression is the higher of the two operands.

mpf_class f(1.5); // default precision mpf_class f(1.5, 500); // 500 bits (at least) mpf_class f(x); // precision of x mpf_class f(abs(x)); // precision of x mpf_class f(-g, 1000); // 1000 bits (at least) mpf_class f(x+y); // greater of precisions of x and y

[Function]void mpf_class::mpf_class (const char *s ) [Function] void mpf_class::mpf_class (const char *s, unsigned long prec, int base

= 0) [Function] void mpf_class::mpf_class (const string& s ) [Function] void mpf_class::mpf_class (const string& s, unsigned long prec, int

base = 0)Construct an

mpf_class converted from a string using mpf_set_str (see Section 7.2 [As-signing Floats], page 50). If

prec is given, the initial precision is that value, in bits. If not,the default mpf precision (see Section 7.1 [Initializing Floats], page 48) is used.

If the string is not a valid float, an std::invalid_argument exception is thrown. The sameapplies to

operator=.

[Function]mpf_class& mpf_class::operator= (type op )Convert and store the given op value to an mpf_class object. The same types are acceptedas for the constructors above.

Note that operator= only stores a new value, it doesn't copy or change the precision of thedestination, instead the value is truncated if necessary. This is the same as

mpf_set etc.Note in particular this means for mpf_class a copy constructor is not the same as a defaultconstructor plus assignment.

mpf_class x (y); // x created with precision of y

80 GNU MP 4.2.3

mpf_class x; // x created with default precision x = y; // value truncated to that precision

Applications using templated code may need to be careful about the assumptions the codemakes in this area, when working with

mpf_class values of various different or non-defaultprecisions. For instance implementations of the standard

complex template have been seenin both styles above, though of course complex is normally only actually specified for usewith the builtin float types.

[Function]mpf_class abs (mpf class op ) [Function] mpf_class ceil (mpf class op ) [Function] int cmp (mpf class op1, type op2 ) [Function] int cmp (type op1, mpf class op2 ) [Function] bool mpf_class::fits_sint_p (void) [Function] bool mpf_class::fits_slong_p (void) [Function] bool mpf_class::fits_sshort_p (void) [Function] bool mpf_class::fits_uint_p (void) [Function] bool mpf_class::fits_ulong_p (void) [Function] bool mpf_class::fits_ushort_p (void) [Function] mpf_class floor (mpf class op ) [Function] mpf_class hypot (mpf class op1, mpf class op2 ) [Function] double mpf_class::get_d (void) [Function] long mpf_class::get_si (void) [Function] string mpf_class::get_str (mp exp t& exp, int base = 10, size t

digits = 0) [Function] unsigned long mpf_class::get_ui (void) [Function] int mpf_class::set_str (const char *str, int base ) [Function] int mpf_class::set_str (const string& str, int base ) [Function] int sgn (mpf class op ) [Function] mpf_class sqrt (mpf class op ) [Function] mpf_class trunc (mpf class op )These functions provide a C

++ class interface to the corresponding GMP C routines.

cmp can be used with any of the classes or the standard C++ types, except long long and long double.

The accuracy provided by hypot is not currently guaranteed.

[Function]unsigned long int mpf_class::get_prec () [Function] void mpf_class::set_prec (unsigned long prec ) [Function] void mpf_class::set_prec_raw (unsigned long prec )Get or set the current precision of an

mpf_class.

The restrictions described for mpf_set_prec_raw (see Section 7.1 [Initializing Floats],page 48) apply to

mpf_class::set_prec_raw. Note in particular that the mpf_class mustbe restored to it's allocated precision before being destroyed. This must be done by application code, there's no automatic mechanism for it.

12.5 C++ Interface Random Numbers

[Class]gmp_randclassThe C ++ class interface to the GMP random number functions uses gmp_randclass to holdan algorithm selection and current state, as per

gmp_randstate_t.

Chapter 12: C++ Class Interface 81

[Function]gmp_randclass::gmp_randclass (void (*randinit ) (gmp randstate t, . . . ), . . . )Construct a

gmp_randclass, using a call to the given randinit function (see Section 9.1[Random State Initialization], page 64). The arguments expected are the same as

randinit,but with mpz_class instead of mpz_t. For example,

gmp_randclass r1 (gmp_randinit_default); gmp_randclass r2 (gmp_randinit_lc_2exp_size, 32); gmp_randclass r3 (gmp_randinit_lc_2exp, a, c, m2exp); gmp_randclass r4 (gmp_randinit_mt);

gmp_randinit_lc_2exp_size will fail if the size requested is too big, an std::length_errorexception is thrown in that case.

[Function]gmp_randclass::gmp_randclass (gmp randalg t alg, . . . )Construct a gmp_randclass using the same parameters as gmp_randinit (see Section 9.1[Random State Initialization], page 64). This function is obsolete and the above

randinitstyle should be preferred.

[Function]void gmp_randclass::seed (unsigned long int s ) [Function] void gmp_randclass::seed (mpz class s )Seed a random number generator. See see Chapter 9 [Random Number Functions], page 64,

for how to choose a good seed.

[Function]mpz_class gmp_randclass::get_z_bits (unsigned long bits ) [Function] mpz_class gmp_randclass::get_z_bits (mpz class bits )Generate a random integer with a specified number of bits.

[Function]mpz_class gmp_randclass::get_z_range (mpz class n )Generate a random integer in the range 0 to n - 1 inclusive.

[Function]mpf_class gmp_randclass::get_f () [Function] mpf_class gmp_randclass::get_f (unsigned long prec )Generate a random float

f in the range 0 <= f < 1. f will be to prec bits precision, or if prec is not given then to the precision of the destination. For example,

gmp_randclass r; ... mpf_class f (0, 512); // 512 bits precision f = r.get_f(); // random number, 512 bits

12.6 C++ Interface Limitations mpq_class and Templated ReadingA generic piece of template code probably won't know that

mpq_class requires a canonicalize call if inputs read with operator>> might be non-canonical. Thiscan lead to incorrect results.

operator>> behaves as it does for reasons of efficiency. A canonicalize can be quitetime consuming on large operands, and is best avoided if it's not necessary. But this potential difficulty reduces the usefulness of mpq_class. Perhaps a mech-anism to tell

operator>> what to do will be adopted in the future, maybe a pre-processor define, a global flag, or an

ios flag pressed into service. Or maybe, atthe risk of inconsistency, the mpq_class operator>> could canonicalize and leave

82 GNU MP 4.2.3

mpq_t operator>> not doing so, for use on those occasions when that's acceptable.Send feedback or alternate ideas to

gmp-bugs@swox.com.

Subclassing Subclassing the GMP C

++ classes works, but is not currently recommended.

Expressions involving subclasses resolve correctly (or seem to), but in normal C++fashion the subclass doesn't inherit constructors and assignments. There's many of

those in the GMP classes, and a good way to reestablish them in a subclass is notyet provided.

Templated ExpressionsA subtle difficulty exists when using expressions together with application-defined

template functions. Consider the following, with T intended to be some numerictype,

template <class T> T fun (const T &, const T &);

When used with, say, plain mpz_class variables, it works fine: T is resolved as mpz_class.

mpz_class f(1), g(2); fun (f, g); // Good

But when one of the arguments is an expression, it doesn't work.

mpz_class f(1), g(2), h(3); fun (f, g+h); // Bad

This is because g+h ends up being a certain expression template type internal to gmpxx.h, which the C++ template resolution rules are unable to automatically con-vert to

mpz_class. The workaround is simply to add an explicit cast.

mpz_class f(1), g(2), h(3); fun (f, mpz_class(g+h)); // Good

Similarly, within fun it may be necessary to cast an expression to type T whencalling a templated

fun2.

template <class T> void fun (T f, T g) {

fun2 (f, f+g); // Bad }

template <class T> void fun (T f, T g) {

fun2 (f, T(f+g)); // Good }

Chapter 13: Berkeley MP Compatible Functions 83 13 Berkeley MP Compatible Functions These functions are intended to be fully compatible with the Berkeley MP library which isavailable on many BSD derived U*ix systems. The `

--enable-mpbsd' option must be usedwhen building GNU MP to make these available (see Chapter 2 [Installing GMP], page 3).

The original Berkeley MP library has a usage restriction: you cannot use the same variable asboth source and destination in a single function call. The compatible functions in GNU MP do not share this restriction--inputs and outputs may overlap. It is not recommended that new programs are written using these functions. Apart from theincomplete set of functions, the interface for initializing

MINT objects is more error prone, andthe pow function collides with pow in `libm.a'.

Include the header `mp.h' to get the definition of the necessary types and functions. If you areon a BSD derived system, make sure to include GNU `

mp.h' if you are going to link the GNU` libmp.a' to your program. This means that you probably need to give the `-I<dir>' option tothe compiler, where `

<dir>' is the directory where you have GNU `mp.h'.

[Function]MINT * itom (signed short int initial_value )Allocate an integer consisting of a MINT object and dynamic limb space. Initialize the integerto initial value. Return a pointer to the MINT object.

[Function]MINT * xtom (char *initial_value )Allocate an integer consisting of a MINT object and dynamic limb space. Initialize the integerfrom initial value, a hexadecimal, null-terminated C string. Return a pointer to the MINTobject.

[Function]void move (MINT *src, MINT *dest )Set dest to src by copying. Both variables must be previously initialized.

[Function]void madd (MINT *src_1, MINT *src_2, MINT *destination )Add src 1 and src 2 and put the sum in destination.

[Function]void msub (MINT *src_1, MINT *src_2, MINT *destination )Subtract src 2 from src 1 and put the difference in destination.

[Function]void mult (MINT *src_1, MINT *src_2, MINT *destination )Multiply src 1 and src 2 and put the product in destination.

[Function]void mdiv (MINT *dividend, MINT *divisor, MINT *quotient, MINT *remainder ) [Function] void sdiv (MINT *dividend, signed short int divisor, MINT *quotient,

signed short int *remainder )Set quotient to dividend/divisor, and remainder to dividend mod divisor. The quotient isrounded towards zero; the remainder has the same sign as the dividend unless it is zero.

Some implementations of these functions work differently--or not at all--for negative argu-ments.

[Function]void msqrt (MINT *op, MINT *root, MINT *remainder )Set root to bpopc, like mpz_sqrt. Set remainder to (op - root2), i.e. zero if op is a perfectsquare.

If root and remainder are the same variable, the results are undefined.

84 GNU MP 4.2.3

[Function]void pow (MINT *base, MINT *exp, MINT *mod, MINT *dest )Set dest to (base raised to exp) modulo mod.

Note that the name pow clashes with pow from the standard C math library (see Section"Exponentiation and Logarithms" in

The GNU C Library Reference Manual). An applicationwill only be able to use one or the other.

[Function]void rpow (MINT *base, signed short int exp, MINT *dest )Set dest to base raised to exp.

[Function]void gcd (MINT *op1, MINT *op2, MINT *res )Set res to the greatest common divisor of op1 and op2.

[Function]int mcmp (MINT *op1, MINT *op2 )Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, and a negativevalue if op1 < op2.

[Function]void min (MINT *dest )Input a decimal string from stdin, and put the read integer in dest. SPC and TAB areallowed in the number string, and are ignored.

[Function]void mout (MINT *src )Output src to stdout, as a decimal string. Also output a newline.

[Function]char * mtox (MINT *op )Convert op to a hexadecimal string, and return a pointer to the string. The returned stringis allocated using the default memory allocation function,

malloc by default. It will be strlen(str)+1 bytes, that being exactly enough for the string and null-terminator.

[Function]void mfree (MINT *op )De-allocate, the space used by op. This function should only be passed a value returned by itom or xtom.

Chapter 14: Custom Allocation 85 14 Custom Allocation By default GMP uses malloc, realloc and free for memory allocation, and if they fail GMPprints a message to the standard error output and terminates the program.

Alternate functions can be specified, to allocate memory in a different way or to have a differenterror action on running out of memory. This feature is available in the Berkeley compatibility library (see Chapter 13 [BSD CompatibleFunctions], page 83) as well as the main GMP library.

[Function]void mp_set_memory_functions ( void *(*alloc_func_ptr ) (size t), void *(*realloc_func_ptr ) (void *, size t, size t), void (*free_func_ptr ) (void *, size t))Replace the current allocation functions from the arguments. If an argument is

NULL, thecorresponding default function is used.

These functions will be used for all memory allocation done by GMP, apart from temporaryspace from

alloca if that function is available and GMP is configured to use it (see Section 2.1[Build Options], page 3).

Be sure to call mp_set_memory_functions only when there are no active GMP objects allocated using the previous memory functions! Usually that means calling it before any other GMP function.

The functions supplied should fit the following declarations:

[Function]void * allocate_function (size t alloc_size )Return a pointer to newly allocated space with at least alloc size bytes.

[Function]void * reallocate_function (void *ptr, size t old_size, size t new_size )Resize a previously allocated block

ptr of old size bytes to be new size bytes.

The block may be moved if necessary or if desired, and in that case the smaller of old sizeand

new size bytes must be copied to the new location. The return value is a pointer to theresized block, that being the new location if moved or just

ptr if not.

ptr is never NULL, it's always a previously allocated block. new size may be bigger or smallerthan

old size.

[Function]void free_function (void *ptr, size t size )De-allocate the space pointed to by ptr.

ptr is never NULL, it's always a previously allocated block of size bytes.

A byte here means the unit used by the sizeof operator. The old size parameters to reallocate function and free function are passed for convenience,but of course can be ignored if not needed. The default functions using

malloc and friends forinstance don't use them.

No error return is allowed from any of these functions, if they return then they must have per-formed the specified operation. In particular note that

allocate function or reallocate functionmustn't return NULL.

86 GNU MP 4.2.3 Getting a different fatal error action is a good use for custom allocation functions, for examplegiving a graphical dialog rather than the default print to

stderr. How much is possible whengenuinely out of memory is another question though.

There's currently no defined way for the allocation functions to recover from an error such as outof memory, they must terminate program execution. A

longjmp or throwing a C++ exceptionwill have undefined results. This may change in the future.

GMP may use allocated blocks to hold pointers to other allocated blocks. This will limit theassumptions a conservative garbage collection scheme can make. Since the default GMP allocation uses malloc and friends, those functions will be linked in evenif the first thing a program does is an

mp_set_memory_functions. It's necessary to change theGMP sources if this is a problem.

[Function]void mp_get_memory_functions ( void *(**alloc_func_ptr ) (size t), void *(**realloc_func_ptr ) (void *, size t, size t), void (**free_func_ptr ) (void *, size t))Get the current allocation functions, storing function pointers to the locations given by the

arguments. If an argument is NULL, that function pointer is not stored. For example, to get just the current free function,

void (*freefunc) (void *, size_t);

mp_get_memory_functions (NULL, NULL, &freefunc);

Chapter 15: Language Bindings 87 15 Language Bindings The following packages and projects offer access to GMP from languages other than C, thoughperhaps with varying levels of functionality and efficiency.

C++ *

GMP C++ class interface, see Chapter 12 [C++ Class Interface], page 75Straightforward interface, expression templates to eliminate temporaries.

* ALP http://www-sop.inria.fr/saga/logiciels/ALP/Linear algebra and polynomials using templates.

* Arithmos http://www.win.ua.ac.be/~cant/arithmos/Rationals with infinities and square roots.

* CLN http://www.ginac.de/CLN/High level classes for arithmetic.

* LiDIA http://www.cdc.informatik.tu-darmstadt.de/TI/LiDIA/A C

++ library for computational number theory.*

Linbox http://www.linalg.org/Sparse vectors and matrices.

* NTL http://www.shoup.net/ntl/A C

++ number theory library.

Fortran *

Omni F77 http://phase.hpcc.jp/Omni/home.htmlArbitrary precision floats.

Haskell *

Glasgow Haskell Compiler http://www.haskell.org/ghc/

Java *

Kaffe http://www.kaffe.org/* Kissme http://kissme.sourceforge.net/

Lisp *

GNU Common Lisp http://www.gnu.org/software/gcl/gcl.html* Librep http://librep.sourceforge.net/* XEmacs (21.5.18 beta and up) http://www.xemacs.orgOptional big integers, rationals and floats using GMP.

M4 *

GNU m4 betas http://www.seindal.dk/rene/gnu/Optionally provides an arbitrary precision

mpeval.

ML *

MLton compiler http://mlton.org/

Objective Caml* MLGMP

http://www.di.ens.fr/~monniaux/programmes.html.en*

Numerix http://pauillac.inria.fr/~quercia/Optionally using GMP.

Oz *

Mozart http://www.mozart-oz.org/

88 GNU MP 4.2.3 Pascal *

GNU Pascal Compiler http://www.gnu-pascal.de/GMP unit.

* Numerix http://pauillac.inria.fr/~quercia/For Free Pascal, optionally using GMP.

Perl *

GMP module, see `demos/perl' in the GMP sources (see Section 3.10 [Demon-stration Programs], page 20).

* Math::GMP http://www.cpan.org/Compatible with Math::BigInt, but not as many functions as the GMP module

above.* Math::BigInt::GMP http://www.cpan.org/Plug Math::GMP into normal Math::BigInt operations.

Pike *

mpz module in the standard distribution, http://pike.ida.liu.se/

Prolog *

SWI Prolog http://www.swi-prolog.org/Arbitrary precision floats.

Python *

mpz module in the standard distribution, http://www.python.org/* GMPY http://gmpy.sourceforge.net/

Scheme *

GNU Guile (upcoming 1.8) http://www.gnu.org/software/guile/guile.html* RScheme http://www.rscheme.org/* STklos http://www.stklos.org/

Smalltalk *

GNU Smalltalk http://www.smalltalk.org/versions/GNUSmalltalk.html

Other *

Axiom http://savannah.nongnu.org/projects/axiomComputer algebra using GCL.

* DrGenius http://drgenius.seul.org/Geometry system and mathematical programming language.

* GiNaC http://www.ginac.de/C

++ computer algebra using CLN.*

GOO http://www.googoogaga.org/Dynamic object oriented language.

* Maxima http://www.ma.utexas.edu/users/wfs/maxima.htmlMacsyma computer algebra using GCL.

* Q http://q-lang.sourceforge.net/Equational programming system.

* Regina http://regina.sourceforge.net/Topological calculator.

* Yacas http://www.xs4all.nl/~apinkus/yacas.htmlYet another computer algebra system.

Chapter 16: Algorithms 89 16 Algorithms This chapter is an introduction to some of the algorithms used for various GMP operations.The code is likely to be hard to understand without knowing something about the algorithms. Some GMP internals are mentioned, but applications that expect to be compatible with futureGMP releases should take care to use only the documented functions.

16.1 Multiplication N*N limb multiplications and squares are done using one of four algorithms, as the size Nincreases.

Algorithm Threshold Basecase (none) Karatsuba MUL_KARATSUBA_THRESHOLD Toom-3 MUL_TOOM3_THRESHOLD FFT MUL_FFT_THRESHOLD

Similarly for squaring, with the SQR thresholds. N*M multiplications of operands with different sizes above MUL_KARATSUBA_THRESHOLD arecurrently done by splitting into M*M pieces. The Karatsuba and Toom-3 routines then operate

only on equal size operands. This is not very efficient, and is slated for improvement in thefuture.

16.1.1 Basecase Multiplication Basecase N*M multiplication is a straightforward rectangular set of cross-products, the sameas long multiplication done by hand and for that reason sometimes known as the schoolbook or

grammar school method. This is an O(N M ) algorithm. See Knuth section 4.3.1 algorithm M(see Appendix B [References], page 119), and the `

mpn/generic/mul_basecase.c' code.

Assembly implementations of mpn_mul_basecase are essentially the same as the generic C code,but have all the usual assembly tricks and obscurities introduced for speed.

A square can be done in roughly half the time of a multiply, by using the fact that the crossproducts above and below the diagonal are the same. A triangle of products below the diagonal is formed, doubled (left shift by one bit), and then the products on the diagonal added. This can beseen in `

mpn/generic/sqr_basecase.c'. Again the assembly implementations take essentiallythe same approach.

u0 u1 u2 u3 u4

u0 u1 u2 u3 u4

d

d

d

d

d

In practice squaring isn't a full 2* faster than multiplying, it's usually around 1.5*. Less than1.5* probably indicates

mpn_sqr_basecase wants improving on that CPU.

90 GNU MP 4.2.3 On some CPUs mpn_mul_basecase can be faster than the generic C mpn_sqr_basecase on somesmall sizes.

SQR_BASECASE_THRESHOLD is the size at which to use mpn_sqr_basecase, this willbe zero if that routine should be used always.

16.1.2 Karatsuba Multiplication The Karatsuba multiplication algorithm is described in Knuth section 4.3.3 part A, and variousother textbooks. A brief description is given here.

The inputs x and y are treated as each split into two parts of equal length (or the most significantpart one limb shorter if N is odd).

high low

x1 x0

y1 y0

Let b be the power of 2 where the split occurs, ie. if x0 is k limbs (y0 the same) then b = 2k*mp bits per limb. With that x = x1b + x0 and y = y1b + y0, and the following holds,

xy = (b2 + b)x1y1 - b(x1 - x0)(y1 - y0) + (b + 1)x0y0 This formula means doing only three multiplies of (N/2)*(N/2) limbs, whereas a basecasemultiply of N*N limbs is equivalent to four multiplies of (N/2)*(N/2). The factors (

b2 + b) etcrepresent the positions where the three products must be added.

high low

x1y1 x0y0

+ x1y1 + x0y0-

(x1 - x0)(y1 - y0)

The term (x1 - x0)(y1 - y0) is best calculated as an absolute value, and the sign used to chooseto add or subtract. Notice the sum high(

x0y0) + low(x1y1) occurs twice, so it's possible to do 5klimb additions, rather than 6 k, but in GMP extra function call overheads outweigh the saving.

Squaring is similar to multiplying, but with x = y the formula reduces to an equivalent withthree squares,

x2 = (b2 + b)x21 - b(x1 - x0)2 + (b + 1)x20 The final result is accumulated from those three squares the same way as for the three multipliesabove. The middle term (

x1 - x0)2 is now always positive.

A similar formula for both multiplying and squaring can be constructed with a middle term(

x1 + x0)(y1 + y0). But those sums can exceed k limbs, leading to more carry handling andadditions than the form above.

Karatsuba multiplication is asymptotically an O(N 1.585) algorithm, the exponent beinglog 3

/ log 2, representing 3 multiplies each 1/2 the size of the inputs. This is a big improvementover the basecase multiply at

O(N 2) and the advantage soon overcomes the extra additionsKaratsuba performs. MUL_KARATSUBA_THRESHOLD can be as little as 10 limbs. The SQRthreshold is usually about twice the

MUL.

The basecase algorithm will take a time of the form M (N ) = aN 2 + bN + c and the Karatsubaalgorithm

K(N ) = 3M (N/2)+dN +e, which expands to K(N ) = 34 aN 2+ 32 bN +3c+dN +e. The

Chapter 16: Algorithms 91 factor 34 for a means per-crossproduct speedups in the basecase code will increase the thresholdsince they benefit

M (N ) more than K(N ). And conversely the 32 for b means linear stylespeedups of b will increase the threshold since they benefit K(N ) more than M (N ). The lattercan be seen for instance when adding an optimized

mpn_sqr_diagonal to mpn_sqr_basecase.Of course all speedups reduce total time, and in that sense the algorithm thresholds are merely

of academic interest.

16.1.3 Toom 3-Way Multiplication The Karatsuba formula is the simplest case of a general approach to splitting inputs that leadsto both Toom and FFT algorithms. A description of Toom can be found in Knuth section 4.3.3,

with an example 3-way calculation after Theorem A. The 3-way form used in GMP is describedhere.

The operands are each considered split into 3 pieces of equal length (or the most significant part1 or 2 limbs shorter than the other two).

high low

x2 x1 x0

y2 y1 y0

These parts are treated as the coefficients of two polynomials

X(t) = x2t2 + x1t + x0 Y (t) = y2t2 + y1t + y0

Let b equal the power of 2 which is the size of the x0, x1, y0 and y1 pieces, ie. if they're k limbs each then b = 2k*mp bits per limb. With this x = X(b) and y = Y (b).

Let a polynomial W (t) = X(t)Y (t) and suppose its coefficients are

W (t) = w4t4 + w3t3 + w2t2 + w1t + w0 The wi are going to be determined, and when they are they'll give the final result using w = W (b),since

xy = X(b)Y (b). The coefficients will be roughly b2 each, and the final W (b) will be anaddition like,

high low

w4

w3

w2

w1

w0

The wi coefficients could be formed by a simple set of cross products, like w4 = x2y2, w3 = x2y1 + x1y2, w2 = x2y0 + x1y1 + x0y2 etc, but this would need all nine xiyj for i, j = 0, 1, 2, andwould be equivalent merely to a basecase multiply. Instead the following approach is used.

X(t) and Y (t) are evaluated and multiplied at 5 points, giving values of W (t) at those points.In GMP the following points are used,

Point Value t = 0 x0y0, which gives w0 immediately t = 1 (x2 + x1 + x0)(y2 + y1 + y0)

92 GNU MP 4.2.3

t = -1 (x2 - x1 + x0)(y2 - y1 + y0) t = 2 (4x2 + 2x1 + x0)(4y2 + 2y1 + y0) t = 1 x2y2, which gives w4 immediately

At t = -1 the values can be negative and that's handled using the absolute values and trackingthe sign separately. At

t = 1 the value is actually limt!1 X(t)Y (t)t4 , but it's much easier to thinkof as simply x2y2 giving w4 immediately (much like x0y0 at t = 0 gives w0 immediately).

Each of the points substituted into W (t) = w4t4 + * * * + w0 gives a linear combination of the wicoefficients, and the value of those combinations has just been calculated.

W (0) = w0 W (1) = w4 + w3 + w2 + w1 + w0 W (-1) = w4 - w3 + w2 - w1 + w0

W (2) = 16w4 + 8w3 + 4w2 + 2w1 + w0 W (1) = w4

This is a set of five equations in five unknowns, and some elementary linear algebra quicklyisolates each

wi. This involves adding or subtracting one W (t) value from another, and a coupleof divisions by powers of 2 and one division by 3, the latter using the special

mpn_divexact_by3(see Section 16.2.4 [Exact Division], page 96).

The conversion of W (t) values to the coefficients is interpolation. A polynomial of degree 4 like W (t) is uniquely determined by values known at 5 different points. The points are arbitrary andcan be chosen to make the linear equations come out with a convenient set of steps for quickly

isolating the wi. Squaring follows the same procedure as multiplication, but there's only one X(t) and it's evalu-ated at the 5 points, and those values squared to give values of

W (t). The interpolation is thenidentical, and in fact the same toom3_interpolate subroutine is used for both squaring andmultiplying.

Toom-3 is asymptotically O(N 1.465), the exponent being log 5/ log 3, representing 5 recursivemultiplies of 1/3 the original size each. This is an improvement over Karatsuba at

O(N 1.585),though Toom does more work in the evaluation and interpolation and so it only realizes its

advantage above a certain size. Near the crossover between Toom-3 and Karatsuba there's generally a range of sizes where thedifference between the two is small.

MUL_TOOM3_THRESHOLD is a somewhat arbitrary point in thatrange and successive runs of the tune program can give different values due to small variations

in measuring. A graph of time versus size for the two shows the effect, see `tune/README'. At the fairly small sizes where the Toom-3 thresholds occur it's worth remembering that theasymptotic behaviour for Karatsuba and Toom-3 can't be expected to make accurate predictions,

due of course to the big influence of all sorts of overheads, and the fact that only a few recursionsof each are being performed. Even at large sizes there's a good chance machine dependent effects like cache architecture will mean actual performance deviates from what might be predicted. The formula given for the Karatsuba algorithm (see Section 16.1.2 [Karatsuba Multiplication],page 90) has an equivalent for Toom-3 involving only five multiplies, but this would be complicated and unenlightening. An alternate view of Toom-3 can be found in Zuras (see Appendix B [References], page 119),using a vector to represent the

x and y splits and a matrix multiplication for the evaluationand interpolation stages. The matrix inverses are not meant to be actually used, and they have

elements with values much greater than in fact arise in the interpolation steps. The diagram

Chapter 16: Algorithms 93 shown for the 3-way is attractive, but again doesn't have to be implemented that way and forexample with a bit of rearrangement just one division by 6 can be done. 16.1.4 FFT Multiplication At large to very large sizes a Fermat style FFT multiplication is used, following Sch"onhage andStrassen (see Appendix B [References], page 119). Descriptions of FFTs in various forms can

be found in many textbooks, for instance Knuth section 4.3.3 part C or Lipson chapter IX. Abrief description of the form used in GMP is given here.

The multiplication done is xy mod 2N + 1, for a given N . A full product xy is obtained bychoosing

N >= bits(x) + bits(y) and padding x and y with high zero limbs. The modular productis the native form for the algorithm, so padding to get a full product is unavoidable.

The algorithm follows a split, evaluate, pointwise multiply, interpolate and combine similar tothat described above for Karatsuba and Toom-3. A

k parameter controls the split, with an FFTk splitting into 2k pieces of M = N/2k bits each. N must be a multiple of 2k *mp bits per limbso the split falls on limb boundaries, avoiding bit shifts in the split and combine stages.

The evaluations, pointwise multiplications, and interpolation, are all done modulo 2N0 + 1 where N 0 is 2M + k + 3 rounded up to a multiple of 2k and of mp_bits_per_limb. The results ofinterpolation will be the following negacyclic convolution of the input pieces, and the choice of

N 0 ensures these sums aren't truncated.

wn = X

i+j=b2k+n

b=0,1

(-1)bxiyj

The points used for the evaluation are gi for i = 0 to 2k - 1 where g = 22N0/2

k. g is a 2kth root

of unity mod 2N0 + 1, which produces necessary cancellations at the interpolation stage, and it'salso a power of 2 so the fast fourier transforms used for the evaluation and interpolation do only

shifts, adds and negations. The pointwise multiplications are done modulo 2N0 + 1 and either recurse into a further FFTor use a plain multiplication (Toom-3, Karatsuba or basecase), whichever is optimal at the size

N 0. The interpolation is an inverse fast fourier transform. The resulting set of sums of xiyj areadded at appropriate offsets to give the final result.

Squaring is the same, but x is the only input so it's one transform at the evaluate stage and thepointwise multiplies are squares. The interpolation is the same. For a mod 2N + 1 product, an FFT-k is an O(N k/(k-1)) algorithm, the exponent representing2

k recursed modular multiplies each 1/2k-1 the size of the original. Each successive k is an

asymptotic improvement, but overheads mean each is only faster at bigger and bigger sizes. Inthe code,

MUL_FFT_TABLE and SQR_FFT_TABLE are the thresholds where each k is used. Eachnew k effectively swaps some multiplying for some shifts, adds and overheads.

A mod 2N +1 product can be formed with a normal N *N ! 2N bit multiply plus a subtraction,so an FFT and Toom-3 etc can be compared directly. A

k = 4 FFT at O(N 1.333) can be expectedto be the first faster than Toom-3 at O(N 1.465). In practice this is what's found, with MUL_FFT_ MODF_THRESHOLD and SQR_FFT_MODF_THRESHOLD being between 300 and 1000 limbs, dependingon the CPU. So far it's been found that only very large FFTs recurse into pointwise multiplies

above these sizes. When an FFT is to give a full product, the change of N to 2N doesn't alter the theoreticalcomplexity for a given

k, but for the purposes of considering where an FFT might be first usedit can be assumed that the FFT is recursing into a normal multiply and that on that basis it's

doing 2k recursed multiplies each 1/2k-2 the size of the inputs, making it O(N k/(k-2)). This

94 GNU MP 4.2.3 would mean k = 7 at O(N 1.4) would be the first FFT faster than Toom-3. In practice MUL_ FFT_THRESHOLD and SQR_FFT_THRESHOLD have been found to be in the k = 8 range, somewherebetween 3000 and 10000 limbs.

The way N is split into 2k pieces and then 2M + k + 3 is rounded up to a multiple of 2k and mp_bits_per_limb means that when 2k >= mp bits per limb the effective N is a multiple of2

2k-1 bits. The +k + 3 means some values of N just under such a multiple will be rounded

to the next. The complexity calculations above assume that a favourable size is used, meaningone which isn't padded through rounding, and it's also assumed that the extra +

k + 3 bits arenegligible at typical FFT sizes.

The practical effect of the 22k-1 constraint is to introduce a step-effect into measured speeds.For example

k = 8 will round N up to a multiple of 32768 bits, so for a 32-bit limb there'll be512 limb groups of sizes for which

mpn_mul_n runs at the same speed. Or for k = 9 groups of2048 limbs, k = 10 groups of 8192 limbs, etc. In practice it's been found each k is used at quitesmall multiples of its size constraint and so the step effect is quite noticeable in a time versus

size graph. The threshold determinations currently measure at the mid-points of size steps, but this is sub-optimal since at the start of a new step it can happen that it's better to go back to the previous

k for a while. Something more sophisticated for MUL_FFT_TABLE and SQR_FFT_TABLE will beneeded.

16.1.5 Other Multiplication The 3-way Toom algorithm described above (see Section 16.1.3 [Toom 3-Way Multiplication],page 91) generalizes to split into an arbitrary number of pieces, as per Knuth section 4.3.3

algorithm C. This is not currently used, though it's possible a Toom-4 might fit in betweenToom-3 and the FFTs. The notes here are merely for interest.

In general a split into r + 1 pieces is made, and evaluations and pointwise multiplications doneat 2

r + 1 points. A 4-way split does 7 pointwise multiplies, 5-way does 9, etc. Asymptotically an( r + 1)-way algorithm is O(N log(2r+1)/log(r+1). Only the pointwise multiplications count towardsbigO complexity, but the time spent in the evaluate and interpolate stages grows with r and hasa significant practical impact, with the asymptotic advantage of each

r realized only at biggerand bigger sizes. The overheads grow as O(N r), whereas in an r = 2k FFT they grow only as O(N log r).

Knuth algorithm C evaluates at points 0,1,2,. . . ,2r, but exercise 4 uses -r,. . . ,0,. . . ,r and thelatter saves some small multiplies in the evaluate stage (or rather trades them for additions),

and has a further saving of nearly half the interpolate steps. The idea is to separate odd andeven final coefficients and then perform algorithm C steps C7 and C8 on them separately. The divisors at step C7 become j2 and the multipliers at C8 become 2tj - j2. Splitting odd and even parts through positive and negative points can be thought of as using -1as a square root of unity. If a 4th root of unity was available then a further split and speedup

would be possible, but no such root exists for plain integers. Going to complex integers with i = p-1 doesn't help, essentially because in cartesian form it takes three real multiplies to doa complex multiply. The existence of 2

kth roots of unity in a suitable ring or field lets the fast

fourier transform keep splitting and get to O(N log r).

Floating point FFTs use complex numbers approximating Nth roots of unity. Some processorshave special support for such FFTs. But these are not used in GMP since it's very difficult to

guarantee an exact result (to some number of bits). An occasional difference of 1 in the last bitmight not matter to a typical signal processing algorithm, but is of course of vital importance to GMP.

Chapter 16: Algorithms 95 16.2 Division Algorithms 16.2.1 Single Limb Division N*1 division is implemented using repeated 2*1 divisions from high to low, either with ahardware divide instruction or a multiplication by inverse, whichever is best on a given CPU.

The multiply by inverse follows section 8 of "Division by Invariant Integers using Multiplication"by Granlund and Montgomery (see Appendix B [References], page 119) and is implemented as udiv_qrnnd_preinv in `gmp-impl.h'. The idea is to have a fixed-point approximation to 1/d(see

invert_limb) and then multiply by the high limb (plus one bit) of the dividend to get aquotient

q. With d normalized (high bit set), q is no more than 1 too small. Subtracting qdfrom the dividend gives a remainder, and reveals whether

q or q - 1 is correct.

The result is a division done with two multiplications and four or five arithmetic operations. OnCPUs with low latency multipliers this can be much faster than a hardware divide, though the

cost of calculating the inverse at the start may mean it's only better on inputs bigger than say4 or 5 limbs.

When a divisor must be normalized, either for the generic C __udiv_qrnnd_c or the multiplyby inverse, the division performed is actually

a2k by d2k where a is the dividend and k is thepower necessary to have the high bit of d2k set. The bit shifts for the dividend are usuallyaccomplished "on the fly" meaning by extracting the appropriate bits at each step. Done this

way the quotient limbs come out aligned ready to store. When only the remainder is wanted,an alternative is to take the dividend limbs unshifted and calculate

r = a mod d2k followed byan extra final step r2k mod d2k. This can help on CPUs with poor bit shifts or few registers.

The multiply by inverse can be done two limbs at a time. The calculation is basically the same,but the inverse is two limbs and the divisor treated as if padded with a low zero limb. This

means more work, since the inverse will need a 2*2 multiply, but the four 1*1s to do thatare independent and can therefore be done partly or wholly in parallel. Likewise for a 2*1 calculating qd. The net effect is to process two limbs with roughly the same two multipliesworth of latency that one limb at a time gives. This extends to 3 or 4 limbs at a time, though the extra work to apply the inverse will almost certainly soon reach the limits of multiplierthroughput.

A similar approach in reverse can be taken to process just half a limb at a time if the divisor isonly a half limb. In this case the 1*1 multiply for the inverse effectively becomes two

1 2 * 1 foreach limb, which can be a saving on CPUs with a fast half limb multiply, or in fact if the only

multiply is a half limb, and especially if it's not pipelined.

16.2.2 Basecase Division Basecase N*M division is like long division done by hand, but in base 2mp bits per limb. SeeKnuth section 4.3.1 algorithm D, and `

mpn/generic/sb_divrem_mn.c'.

Briefly stated, while the dividend remains larger than the divisor, a high quotient limb is formedand the N*1 product

qd subtracted at the top end of the dividend. With a normalized divisor(most significant bit set), each quotient limb can be formed with a 2*1 division and a 1*1

multiplication plus some subtractions. The 2*1 division is by the high limb of the divisor andis done either with a hardware divide or a multiply by inverse (the same as in Section 16.2.1 [Single Limb Division], page 95) whichever is faster. Such a quotient is sometimes one too big,requiring an addback of the divisor, but that happens rarely.

With Q=N-M being the number of quotient limbs, this is an O(QM ) algorithm and will runat a speed similar to a basecase Q*M multiplication, differing in fact only in the extra multiply and divide for each of the Q quotient limbs.

96 GNU MP 4.2.3 16.2.3 Divide and Conquer Division For divisors larger than DIV_DC_THRESHOLD, division is done by dividing. Or to be precise by arecursive divide and conquer algorithm based on work by Moenck and Borodin, Jebelean, and

Burnikel and Ziegler (see Appendix B [References], page 119). The algorithm consists essentially of recognising that a 2N*N division can be done with thebasecase division algorithm (see Section 16.2.2 [Basecase Division], page 95), but using N/2

limbs as a base, not just a single limb. This way the multiplications that arise are (N/2)*(N/2)and can take advantage of Karatsuba and higher multiplication algorithms (see Section 16.1 [Multiplication Algorithms], page 89). The two "digits" of the quotient are formed by recursiveN*(N/2) divisions.

If the (N/2)*(N/2) multiplies are done with a basecase multiplication then the work is about thesame as a basecase division, but with more function call overheads and with some subtractions separated from the multiplies. These overheads mean that it's only when N/2 is above MUL_ KARATSUBA_THRESHOLD that divide and conquer is of use.

DIV_DC_THRESHOLD is based on the divisor size N, so it will be somewhere above twice MUL_ KARATSUBA_THRESHOLD, but how much above depends on the CPU. An optimized mpn_mul_ basecase can lower DIV_DC_THRESHOLD a little by offering a ready-made advantage over repeated mpn_submul_1 calls.

Divide and conquer is asymptotically O(M (N ) log N ) where M (N ) is the time for an N*Nmultiplication done with FFTs. The actual time is a sum over multiplications of the recursed

sizes, as can be seen near the end of section 2.2 of Burnikel and Ziegler. For example, withinthe Toom-3 range, divide and conquer is 2

.63M (N ). With higher algorithms the M (N ) termimproves and the multiplier tends to log N . In practice, at moderate to large sizes, a 2N*Ndivision is about 2 to 4 times slower than an N*N multiplication.

Newton's method used for division is asymptotically O(M (N )) and should therefore be superiorto divide and conquer, but it's believed this would only be for large to very large N.

16.2.4 Exact Division A so-called exact division is when the dividend is known to be an exact multiple of the divisor.Jebelean's exact division algorithm uses this knowledge to make some significant optimizations

(see Appendix B [References], page 119). The idea can be illustrated in decimal for example with 368154 divided by 543. Because thelow digit of the dividend is 4, the low digit of the quotient must be 8. This is arrived at from

4*7 mod 10, using the fact 7 is the modular inverse of 3 (the low digit of the divisor), since3*7 j 1 mod 10. So 8*543 = 4344 can be subtracted from the dividend leaving 363810. Notice the low digit has become zero. The procedure is repeated at the second digit, with the next quotient digit 7 (1*7 mod 10),subtracting 7*543 = 3801, leaving 325800. And finally at the third digit with quotient digit 6

(8*7 mod 10), subtracting 6*543 = 3258 leaving 0. So the quotient is 678. Notice however that the multiplies and subtractions don't need to extend past the low threedigits of the dividend, since that's enough to determine the three quotient digits. For the last

quotient digit no subtraction is needed at all. On a 2N*N division like this one, only about halfthe work of a normal basecase division is necessary.

For an N*M exact division producing Q=N-M quotient limbs, the saving over a normal basecasedivision is in two parts. Firstly, each of the Q quotient limbs needs only one multiply, not a 2*1 divide and multiply. Secondly, the crossproducts are reduced when Q > M to QM -M (M +1)/2,

Chapter 16: Algorithms 97 or when Q <= M to Q(Q - 1)/2. Notice the savings are complementary. If Q is big then manydivisions are saved, or if Q is small then the crossproducts reduce to a small number. The modular inverse used is calculated efficiently by modlimb_invert in `gmp-impl.h'. Thisdoes four multiplies for a 32-bit limb, or six for a 64-bit limb. `

tune/modlinv.c' has somealternate implementations that might suit processors better at bit twiddling than multiplying.

The sub-quadratic exact division described by Jebelean in "Exact Division with KaratsubaComplexity" is not currently implemented. It uses a rearrangement similar to the divide and conquer for normal division (see Section 16.2.3 [Divide and Conquer Division], page 96), butoperating from low to high. A further possibility not currently implemented is "Bidirectional Exact Integer Division" by Krandick and Jebelean which forms quotient limbs from both thehigh and low ends of the dividend, and can halve once more the number of crossproducts needed in a 2N*N division. A special case exact division by 3 exists in mpn_divexact_by3, supporting Toom-3 multiplicationand

mpq canonicalizations. It forms quotient digits with a multiply by the modular inverse of 3(which is

0xAA..AAB) and uses two comparisons to determine a borrow for the next limb. Themultiplications don't need to be on the dependent chain, as long as the effect of the borrows is

applied, which can help chips with pipelined multipliers. 16.2.5 Exact Remainder If the exact division algorithm is done with a full subtraction at each stage and the dividendisn't a multiple of the divisor, then low zero limbs are produced but with a remainder in the

high limbs. For dividend a, divisor d, quotient q, and b = 2mp bits per limb, this remainder r is of the form

a = qd + rbn

n represents the number of zero limbs produced by the subtractions, that being the number oflimbs produced for

q. r will be in the range 0 <= r < d and can be viewed as a remainder, butone shifted up by a factor of

bn.

Carrying out full subtractions at each stage means the same number of cross products must bedone as a normal division, but there's still some single limb divisions saved. When

d is a singlelimb some simplifications arise, providing good speedups on a number of processors.

mpn_bdivmod, mpn_divexact_by3, mpn_modexact_1_odd and the redc function in mpz_powmdiffer subtly in how they return

r, leading to some negations in the above formula, but all areessentially the same.

Clearly r is zero when a is a multiple of d, and this leads to divisibility or congruence tests whichare potentially more efficient than a normal division. The factor of bn on r can be ignored in a GCD when d is odd, hence the use of mpn_bdivmod in mpn_gcd, and the use of mpn_modexact_1_odd by mpn_gcd_1 and mpz_kronecker_ui etc (seeSection 16.3 [Greatest Common Divisor Algorithms], page 98).

Montgomery's REDC method for modular multiplications uses operands of the form of xb-nand

yb-n and on calculating (xb-n)(yb-n) uses the factor of bn in the exact remainder to reach aproduct in the same form (

xy)b-n (see Section 16.4.2 [Modular Powering Algorithm], page 100).

Notice that r generally gives no useful information about the ordinary remainder a mod d since bn mod d could be anything. If however bn j 1 mod d, then r is the negative of the ordinaryremainder. This occurs whenever

d is a factor of bn - 1, as for example with 3 in mpn_divexact_ by3. For a 32 or 64 bit limb other such factors include 5, 17 and 257, but no particular use hasbeen found for this.

98 GNU MP 4.2.3 16.2.6 Small Quotient Division An N*M division where the number of quotient limbs Q=N-M is small can be optimizedsomewhat.

An ordinary basecase division normalizes the divisor by shifting it to make the high bit set,shifting the dividend accordingly, and shifting the remainder back down at the end of the calculation. This is wasteful if only a few quotient limbs are to be formed. Instead a divisionof just the top 2Q limbs of the dividend by the top Q limbs of the divisor can be used to form a trial quotient. This requires only those limbs normalized, not the whole of the divisor anddividend.

A multiply and subtract then applies the trial quotient to the M-Q unused limbs of the divisorand N-Q dividend limbs (which includes Q limbs remaining from the trial quotient division). The starting trial quotient can be 1 or 2 too big, but all cases of 2 too big and most cases of1 too big are detected by first comparing the most significant limbs that will arise from the subtraction. An addback is done if the quotient still turns out to be 1 too big. This whole procedure is essentially the same as one step of the basecase algorithm done in a Qlimb base, though with the trial quotient test done only with the high limbs, not an entire Q

limb "digit" product. The correctness of this weaker test can be established by following theargument of Knuth section 4.3.1 exercise 20 but with the

v2^q > b^r + u2 condition appropriatelyrelaxed.

16.3 Greatest Common Divisor 16.3.1 Binary GCD At small sizes GMP uses an O(N 2) binary style GCD. This is described in many textbooks,for example Knuth section 4.5.2 algorithm B. It simply consists of successively reducing odd

operands a and b using

a, b = abs (a - b), min (a, b)strip factors of 2 from

a

The Euclidean GCD algorithm, as per Knuth algorithms E and A, reduces using a mod b butthis has so far been found to be slower everywhere. One reason the binary method does well

is that the implied quotient at each step is usually small, so often only one or two subtractionsare needed to get the same effect as a division. Quotients 1, 2 and 3 for example occur 67.7% of the time, see Knuth section 4.5.3 Theorem E. When the implied quotient is large, meaning b is much smaller than a, then a division is worth-while. This is the basis for the initial

a mod b reductions in mpn_gcd and mpn_gcd_1 (the latterfor both N*1 and 1*1 cases). But after that initial reduction, big quotients occur too rarely to

make it worth checking for them.

The final 1 * 1 GCD in mpn_gcd_1 is done in the generic C code as described above. For twoN-bit operands, the algorithm takes about 0.68 iterations per bit. For optimum performance some attention needs to be paid to the way the factors of 2 are stripped from a. Firstly it may be noted that in twos complement the number of low zero bits on a - b is thesame as

b - a, so counting or testing can begin on a - b without waiting for abs (a - b) to bedetermined.

A loop stripping low zero bits tends not to branch predict well, since the condition is datadependent. But on average there's only a few low zeros, so an option is to strip one or two bits arithmetically then loop for more (as done for AMD K6). Or use a lookup table to get a count

Chapter 16: Algorithms 99 for several bits then loop for more (as done for AMD K7). An alternative approach is to keepjust one of

a or b odd and iterate

a, b = abs (a - b), min (a, b) a = a/2 if even b = b/2 if even

This requires about 1.25 iterations per bit, but stripping of a single bit at each step avoidsany branching. Repeating the bit strip reduces to about 0.9 iterations per bit, which may be a

worthwhile tradeoff. Generally with the above approaches a speed of perhaps 6 cycles per bit can be achieved, whichis still not terribly fast with for instance a 64-bit GCD taking nearly 400 cycles. It's this sort

of time which means it's not usually advantageous to combine a set of divisibility tests into aGCD.

16.3.2 Accelerated GCD For sizes above GCD_ACCEL_THRESHOLD, GMP uses the Accelerated GCD algorithm describedindependently by Weber and Jebelean (the latter as the "Generalized Binary" algorithm), see

Appendix B [References], page 119. This algorithm is still O(N 2), but is much faster than thebinary algorithm since it does fewer multi-precision operations. It consists of alternating the k-ary reduction by Sorenson, and a "dmod" exact remainder reduction. For operands u and v the k-ary reduction replaces u with nv - du where n and d are singlelimb values chosen to give two trailing zero limbs on that value, which can be stripped.

nand d are calculated using an algorithm similar to half of a two limb GCD (see find_a in` mpn/generic/gcd.c').

When u and v differ in size by more than a certain number of bits, a dmod is performed to zeroout bits at the low end of the larger. It consists of an exact remainder style division applied to an

appropriate number of bits (see Section 16.2.4 [Exact Division], page 96, and see Section 16.2.5[Exact Remainder], page 97). This is faster than a

k-ary reduction but useful only when theoperands differ in size. There's a dmod after each k-ary reduction, and if the dmod leaves theoperands still differing in size then it's repeated.

The k-ary reduction step can introduce spurious factors into the GCD calculated, and theseare eliminated at the end by taking GCDs with the original inputs gcd (

u, gcd (v, g)) using thebinary algorithm. Since g is almost always small this takes very little time.

At small sizes the algorithm needs a good implementation of find_a. At larger sizes it's domi-nated by

mpn_addmul_1 applying n and d.

16.3.3 Extended GCD The extended GCD calculates gcd (a, b) and also cofactors x and y satisfying ax + by = gcd(a,b).Lehmer's multi-step improvement of the extended Euclidean algorithm is used. See Knuth

section 4.5.2 algorithm L, and `mpn/generic/gcdext.c'. This is an O(N 2) algorithm. The multipliers at each step are found using single limb calculations for sizes up to GCDEXT_ THRESHOLD, or double limb calculations above that. The single limb code is faster but doesn'tproduce full-limb multipliers, hence not making full use of the

mpn_addmul_1 calls.

When a CPU has a data-dependent multiplier, meaning one which is faster on operands withfewer bits, the extra work in the double-limb calculation might only save some looping overheads,

leading to a large GCDEXT_THRESHOLD.

100 GNU MP 4.2.3 Currently the single limb calculation doesn't optimize for the small quotients that often occur,and this can lead to unusually low values of

GCDEXT_THRESHOLD, depending on the CPU.

An analysis of double-limb calculations can be found in "A Double-Digit Lehmer-Euclid Algo-rithm" by Jebelean (see Appendix B [References], page 119). The code in GMP was developed

independently. It should be noted that when a double limb calculation is used, it's used for the whole of thatGCD, it doesn't fall back to single limb part way through. This is because as the algorithm

proceeds, the inputs a and b are reduced, but the cofactors x and y grow, so the multipliers ateach step are applied to a roughly constant total number of limbs.

16.3.4 Jacobi Symbol mpz_jacobi and mpz_kronecker are currently implemented with a simple binary algorithmsimilar to that described for the GCDs (see Section 16.3.1 [Binary GCD], page 98). They're

not very fast when both inputs are large. Lehmer's multi-step improvement or a binary basedmulti-step algorithm is likely to be better.

When one operand fits a single limb, and that includes mpz_kronecker_ui and friends, aninitial reduction is done with either

mpn_mod_1 or mpn_modexact_1_odd, followed by the binaryalgorithm on a single limb. The binary algorithm is well suited to a single limb, and the whole

calculation in this case is quite efficient. In all the routines sign changes for the result are accumulated using some bit twiddling, avoidingtable lookups or conditional jumps.

16.4 Powering Algorithms 16.4.1 Normal Powering Normal mpz or mpf powering uses a simple binary algorithm, successively squaring and thenmultiplying by the base when a 1 bit is seen in the exponent, as per Knuth section 4.6.3. The

"left to right" variant described there is used rather than algorithm A, since it's just as easyand can be done with somewhat less temporary memory.

16.4.2 Modular Powering Modular powering is implemented using a 2k-ary sliding window algorithm, as per "Handbookof Applied Cryptography" algorithm 14.85 (see Appendix B [References], page 119).

k is chosenaccording to the size of the exponent. Larger exponents use larger values of k, the choice beingmade to minimize the average number of multiplications that must supplement the squaring.

The modular multiplies and squares use either a simple division or the REDC method by Mont-gomery (see Appendix B [References], page 119). REDC is a little faster, essentially saving N single limb divisions in a fashion similar to an exact remainder (see Section 16.2.5 [ExactRemainder], page 97). The current REDC has some limitations. It's only

O(N 2) so above POWM_THRESHOLD division becomes faster and is used. It doesn't attempt to detect small bases,but rather always uses a REDC form, which is usually a full size operand. And lastly it's only

applied to odd moduli.

16.5 Root Extraction Algorithms 16.5.1 Square Root Square roots are taken using the "Karatsuba Square Root" algorithm by Paul Zimmermann (seeAppendix B [References], page 119).

Chapter 16: Algorithms 101 An input n is split into four parts of k bits each, so with b = 2k we have n = a3b3 +a2b2 +a1b+a0.Part

a3 must be "normalized" so that either the high or second highest bit is set. In GMP, k iskept on a limb boundary and the input is left shifted (by an even number of bits) to normalize.

The square root of the high two parts is taken, by recursive application of the algorithm (bot-toming out in a one-limb Newton's method),

s0, r0 = sqrtrem (a3b + a2) This is an approximation to the desired root and is extended by a division to give s,r,

q, u = divrem (r0b + a1, 2s0)

s = s0b + q r = ub + a0 - q2

The normalization requirement on a3 means at this point s is either correct or 1 too big. r isnegative in the latter case, so

if r < 0 then

r  r + 2s - 1

s  s - 1

The algorithm is expressed in a divide and conquer form, but as noted in the paper it can alsobe viewed as a discrete variant of Newton's method, or as a variation on the schoolboy method

(no longer taught) for square roots two digits at a time. If the remainder r is not required then usually only a few high limbs of r and u need to be cal-culated to determine whether an adjustment to

s is required. This optimization is not currentlyimplemented.

In the Karatsuba multiplication range this algorithm is O( 32 M (N/2)), where M (n) is the timeto multiply two numbers of

n limbs. In the FFT multiplication range this grows to a bound of O(6M (N/2)). In practice a factor of about 1.5 to 1.8 is found in the Karatsuba and Toom-3ranges, growing to 2 or 3 in the FFT range.

The algorithm does all its calculations in integers and the resulting mpn_sqrtrem is used forboth

mpz_sqrt and mpf_sqrt. The extended precision given by mpf_sqrt_ui is obtained bypadding with zero limbs.

16.5.2 Nth Root Integer Nth roots are taken using Newton's method with the following iteration, where A is theinput and

n is the root to be taken.

ai+1 = 1n ` Aan-1

i + (n - 1)a

i'

The initial approximation a1 is generated bitwise by successively powering a trial root with orwithout new 1 bits, aiming to be just above the true root. The iteration converges quadratically when started from a good approximation. When n is large more initial bits are needed to getgood convergence. The current implementation is not particularly well optimized.

16.5.3 Perfect Square A significant fraction of non-squares can be quickly identified by checking whether the input isa quadratic residue modulo small integers.

102 GNU MP 4.2.3 mpz_perfect_square_p first tests the input mod 256, which means just examining the lowbyte. Only 44 different values occur for squares mod 256, so 82.8% of inputs can be immediately identified as non-squares. On a 32-bit system similar tests are done mod 9, 5, 7, 13 and 17, for a total 99.25% of inputsidentified as non-squares. On a 64-bit system 97 is tested too, for a total 99.62%.

These moduli are chosen because they're factors of 224 - 1 (or 248 - 1 for 64-bits), and such aremainder can be quickly taken just using additions (see

mpn_mod_34lsub1).

When nails are in use moduli are instead selected by the `gen-psqr.c' program and appliedwith an

mpn_mod_1. The same 224 - 1 or 248 - 1 could be done with nails using some extra bitshifts, but this is not currently implemented.

In any case each modulus is applied to the mpn_mod_34lsub1 or mpn_mod_1 remainder anda table lookup identifies non-squares. By using a "modexact" style calculation, and suitably permuted tables, just one multiply each is required, see the code for details. Moduli are alsocombined to save operations, so long as the lookup tables don't become too big. `

gen-psqr.c'does all the pre-calculations.

A square root must still be taken for any value that passes these tests, to verify it's really asquare and not one of the small fraction of non-squares that get through (ie. a pseudo-square to all the tested bases). Clearly more residue tests could be done, mpz_perfect_square_p only uses a compact andefficient set. Big inputs would probably benefit from more residue testing, small inputs might

be better off with less. The assumed distribution of squares versus non-squares in the inputwould affect such considerations.

16.5.4 Perfect Power Detecting perfect powers is required by some factorization algorithms. Currently mpz_perfect_ power_p is implemented using repeated Nth root extractions, though naturally only prime rootsneed to be considered. (See Section 16.5.2 [Nth Root Algorithm], page 101.)

If a prime divisor p with multiplicity e can be found, then only roots which are divisors of eneed to be considered, much reducing the work necessary. To this end divisibility by a set of small primes is checked.

16.6 Radix Conversion Radix conversions are less important than other algorithms. A program dominated by conver-sions should probably use a different data representation.

16.6.1 Binary to Radix Conversions from binary to a power-of-2 radix use a simple and fast O(N ) bit extraction algo-rithm.

Conversions from binary to other radices use one of two algorithms. Sizes below GET_STR_ PRECOMPUTE_THRESHOLD use a basic O(N 2) method. Repeated divisions by bn are made, where b is the radix and n is the biggest power that fits in a limb. But instead of simply using theremainder

r from such divisions, an extra divide step is done to give a fractional limb representing r/bn. The digits of r can then be extracted using multiplications by b rather than divisions.Special case code is provided for decimal, allowing multiplications by 10 to optimize to shifts

and adds.

Chapter 16: Algorithms 103 Above GET_STR_PRECOMPUTE_THRESHOLD a sub-quadratic algorithm is used. For an input t,powers

bn2

i of the radix are calculated, until a power between t and pt is reached. t is then

divided by that largest power, giving a quotient which is the digits above that power, and aremainder which is those below. These two parts are in turn divided by the second highest power,

and so on recursively. When a piece has been divided down to less than GET_STR_DC_THRESHOLDlimbs, the basecase algorithm described above is used.

The advantage of this algorithm is that big divisions can make use of the sub-quadratic divide andconquer division (see Section 16.2.3 [Divide and Conquer Division], page 96), and big divisions tend to have less overheads than lots of separate single limb divisions anyway. But in any casethe cost of calculating the powers

bn2

i must first be overcome.

GET_STR_PRECOMPUTE_THRESHOLD and GET_STR_DC_THRESHOLD represent the same basic thing,the point where it becomes worth doing a big division to cut the input in half.

GET_STR_ PRECOMPUTE_THRESHOLD includes the cost of calculating the radix power required, whereas GET_ STR_DC_THRESHOLD assumes that's already available, which is the case when recursing.

Since the base case produces digits from least to most significant but they want to be storedfrom most to least, it's necessary to calculate in advance how many digits there will be, or at

least be sure not to underestimate that. For GMP the number of input bits is multiplied by chars_per_bit_exactly from mp_bases, rounding up. The result is either correct or one toobig.

Examining some of the high bits of the input could increase the chance of getting the exactnumber of digits, but an exact result every time would not be practical, since in general the difference between numbers 100. . . and 99. . . is only in the last few bits and the work to identify99. . . might well be almost as much as a full conversion.

mpf_get_str doesn't currently use the algorithm described here, it multiplies or divides by apower of

b to move the radix point to the just above the highest non-zero digit (or at worst oneabove that location), then multiplies by

bn to bring out digits. This is O(N 2) and is certainlynot optimal.

The r/bn scheme described above for using multiplications to bring out digits might be usefulfor more than a single limb. Some brief experiments with it on the base case when recursing didn't give a noticeable improvement, but perhaps that was only due to the implementation.Something similar would work for the sub-quadratic divisions too, though there would be the cost of calculating a bigger radix power. Another possible improvement for the sub-quadratic part would be to arrange for radix powersthat balanced the sizes of quotient and remainder produced, ie. the highest power would be an

bnk approximately equal to pt, not restricted to a 2i factor. That ought to smooth out a graphof times against sizes, but may or may not be a net speedup.

16.6.2 Radix to Binary Conversions from a power-of-2 radix into binary use a simple and fast O(N ) bitwise concatena-tion algorithm.

Conversions from other radices use one of two algorithms. Sizes below SET_STR_THRESHOLD usea basic

O(N 2) method. Groups of n digits are converted to limbs, where n is the biggest powerof the base

b which will fit in a limb, then those groups are accumulated into the result bymultiplying by

bn and adding. This saves multi-precision operations, as per Knuth section 4.4part E (see Appendix B [References], page 119). Some special case code is provided for decimal,

giving the compiler a chance to optimize multiplications by 10.

104 GNU MP 4.2.3 Above SET_STR_THRESHOLD a sub-quadratic algorithm is used. First groups of n digits areconverted into limbs. Then adjacent limbs are combined into limb pairs with

xbn + y, where xand y are the limbs. Adjacent limb pairs are combined into quads similarly with xb2n + y. Thiscontinues until a single block remains, that being the result.

The advantage of this method is that the multiplications for each x are big blocks, allowingKaratsuba and higher algorithms to be used. But the cost of calculating the powers

bn2

i must

be overcome. SET_STR_THRESHOLD usually ends up quite big, around 5000 digits, and on someprocessors much bigger still.

SET_STR_THRESHOLD is based on the input digits (and tuned for decimal), though it might bebetter based on a limb count, so as to be independent of the base. But that sort of count isn't used by the base case and so would need some sort of initial calculation or estimate. The main reason SET_STR_THRESHOLD is so much bigger than the corresponding GET_STR_ PRECOMPUTE_THRESHOLD is that mpn_mul_1 is much faster than mpn_divrem_1 (often by a factorof 10, or more).

16.7 Other Algorithms 16.7.1 Prime Testing The primality testing in mpz_probab_prime_p (see Section 5.9 [Number Theoretic Functions],page 35) first does some trial division by small factors and then uses the Miller-Rabin probabilistic primality testing algorithm, as described in Knuth section 4.5.4 algorithm P (see Appendix B[References], page 119).

For an odd input n, and with n = q2k + 1 where q is odd, this algorithm selects a random base x and tests whether xq mod n is 1 or -1, or an xq2

j mod n is 1, for 1 <= j <= k. If so then n is

probably prime, if not then n is definitely composite. Any prime n will pass the test, but some composites do too. Such composites are known asstrong pseudoprimes to base

x. No n is a strong pseudoprime to more than 1/4 of all bases(see Knuth exercise 22), hence with

x chosen at random there's no more than a 1/4 chance a"probable prime" will in fact be composite.

In fact strong pseudoprimes are quite rare, making the test much more powerful than thisanalysis would suggest, but 1

/4 is all that's proven for an arbitrary n.

16.7.2 Factorial Factorials are calculated by a combination of removal of twos, powering, and binary splitting.The procedure can be best illustrated with an example,

23! = 1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23 has factors of two removed,

23! = 219.1.1.3.1.5.3.7.1.9.5.11.3.13.7.15.1.17.9.19.5.21.11.23 and the resulting terms collected up according to their multiplicity,

23! = 219.(3.5)3.(7.9.11)2.(13.15.17.19.21.23) Each sequence such as 13.15.17.19.21.23 is evaluated by splitting into every second term, asfor instance (13

.17.21).(15.19.23), and the same recursively on each half. This is implementediteratively using some bit twiddling.

Chapter 16: Algorithms 105 Such splitting is more efficient than repeated N*1 multiplies since it forms big multiplies, al-lowing Karatsuba and higher algorithms to be used. And even below the Karatsuba threshold a big block of work can be more efficient for the basecase algorithm. Splitting into subsequences of every second term keeps the resulting products more nearly equalin size than would the simpler approach of say taking the first half and second half of the

sequence. Nearly equal products are more efficient for the current multiply implementation. 16.7.3 Binomial Coefficients Binomial coefficients \Gamma  nk \Delta  are calculated by first arranging k <= n/2 using \Gamma  nk \Delta  = i nn-k j if necessary, and then evaluating the following product simply from i = 2 to i = k.`

n

k ' = (n - k + 1)

kY

i=2

n - k + i

i

It's easy to show that each denominator i will divide the product so far, so the exact divisionalgorithm is used (see Section 16.2.4 [Exact Division], page 96).

The numerators n - k + i and denominators i are first accumulated into as many fit a limb, tosave multi-precision operations, though for

mpz_bin_ui this applies only to the divisors, since n is an mpz_t and n - k + i in general won't fit in a limb at all.

16.7.4 Fibonacci Numbers The Fibonacci functions mpz_fib_ui and mpz_fib2_ui are designed for calculating isolated Fnor

Fn,Fn-1 values efficiently.

For small n, a table of single limb values in __gmp_fib_table is used. On a 32-bit limb thisgoes up to

F47, or on a 64-bit limb up to F93. For convenience the table starts at F-1.

Beyond the table, values are generated with a binary powering algorithm, calculating a pair Fnand

Fn-1 working from high to low across the bits of n. The formulas used are

F2k+1 = 4F 2k - F 2k-1 + 2(-1)k F2k-1 = F 2k + F 2k-1

F2k = F2k+1 - F2k-1

At each step, k is the high b bits of n. If the next bit of n is 0 then F2k,F2k-1 is used, or if it'sa 1 then

F2k+1,F2k is used, and the process repeated until all bits of n are incorporated. Noticethese formulas require just two squares per bit of

n.

It'd be possible to handle the first few n above the single limb table with simple additions, usingthe defining Fibonacci recurrence

Fk+1 = Fk + Fk-1, but this is not done since it usually turnsout to be faster for only about 10 or 20 values of

n, and including a block of code for just thosedoesn't seem worthwhile. If they really mattered it'd be better to extend the data table.

Using a table avoids lots of calculations on small numbers, and makes small n go fast. A biggertable would make more small

n go fast, it's just a question of balancing size against desiredspeed. For GMP the code is kept compact, with the emphasis primarily on a good powering

algorithm. mpz_fib2_ui returns both Fn and Fn-1, but mpz_fib_ui is only interested in Fn. In this casethe last step of the algorithm can become one multiply instead of two squares. One of the

following two formulas is used, according as n is odd or even.

F2k = Fk(Fk + 2Fk-1) F2k+1 = (2Fk + Fk-1)(2Fk - Fk-1) + 2(-1)k

106 GNU MP 4.2.3 F2k+1 here is the same as above, just rearranged to be a multiply. For interest, the 2(-1)k termboth here and above can be applied just to the low limb of the calculation, without a carry or borrow into further limbs, which saves some code size. See comments with mpz_fib_ui and theinternal

mpn_fib2_ui for how this is done.

16.7.5 Lucas Numbers mpz_lucnum2_ui derives a pair of Lucas numbers from a pair of Fibonacci numbers with thefollowing simple formulas.

Lk = Fk + 2Fk-1 Lk-1 = 2Fk - Fk-1 mpz_lucnum_ui is only interested in Ln, and some work can be saved. Trailing zero bits on ncan be handled with a single square each.

L2k = L2k - 2(-1)k And the lowest 1 bit can be handled with one multiply of a pair of Fibonacci numbers, similarto what

mpz_fib_ui does.

L2k+1 = 5Fk-1(2Fk + Fk-1) - 4(-1)k 16.7.6 Random Numbers For the urandomb functions, random numbers are generated simply by concatenating bits pro-duced by the generator. As long as the generator has good randomness properties this will

produce well-distributed N bit numbers. For the urandomm functions, random numbers in a range 0 <= R < N are generated by takingvalues

R of dlog2 N e bits each until one satisfies R < N . This will normally require only oneor two attempts, but the attempts are limited in case the generator is somehow degenerate and

produces only 1 bits or similar. The Mersenne Twister generator is by Matsumoto and Nishimura (see Appendix B [References],page 119). It has a non-repeating period of 2

19937 -1, which is a Mersenne prime, hence the name

of the generator. The state is 624 words of 32-bits each, which is iterated with one XOR andshift for each 32-bit word generated, making the algorithm very fast. Randomness properties

are also very good and this is the default algorithm used by GMP. Linear congruential generators are described in many text books, for instance Knuth volume2 (see Appendix B [References], page 119). With a modulus

M and parameters A and C, ainteger state S is iterated by the formula S  AS + C mod M . At each step the new state is alinear function of the previous, mod

M , hence the name of the generator.

In GMP only moduli of the form 2N are supported, and the current implementation is not as welloptimized as it could be. Overheads are significant when

N is small, and when N is large clearlythe multiply at each step will become slow. This is not a big concern, since the Mersenne Twister

generator is better in every respect and is therefore recommended for all normal applications. For both generators the current state can be deduced by observing enough output and applyingsome linear algebra (over GF(2) in the case of the Mersenne Twister). This generally means

raw output is unsuitable for cryptographic applications without further hashing or the like. 16.8 Assembly Coding The assembly subroutines in GMP are the most significant source of speed at small to moderatesizes. At larger sizes algorithm selection becomes more important, but of course speedups in

low level routines will still speed up everything proportionally.

Chapter 16: Algorithms 107 Carry handling and widening multiplies that are important for GMP can't be easily expressedin C. GCC

asm blocks help a lot and are provided in `longlong.h', but hand coding low levelroutines invariably offers a speedup over generic C by a factor of anything from 2 to 10.

16.8.1 Code Organisation The various `mpn' subdirectories contain machine-dependent code, written in C or assembly.The `

mpn/generic' subdirectory contains default code, used when there's no machine-specificversion of a particular file.

Each `mpn' subdirectory is for an ISA family. Generally 32-bit and 64-bit variants in a familycannot share code and have separate directories. Within a family further subdirectories may exist for CPU variants. In each directory a `nails' subdirectory may exist, holding code with nails support for that CPUvariant. A

NAILS_SUPPORT directive in each file indicates the nails values the code handles. Nailscode only exists where it's faster, or promises to be faster, than plain code. There's no effort

put into nails if they're not going to enhance a given CPU. 16.8.2 Assembly Basics mpn_addmul_1 and mpn_submul_1 are the most important routines for overall GMP performance.All multiplications and divisions come down to repeated calls to these.

mpn_add_n, mpn_sub_n, mpn_lshift and mpn_rshift are next most important.

On some CPUs assembly versions of the internal functions mpn_mul_basecase and mpn_sqr_ basecase give significant speedups, mainly through avoiding function call overheads. They canalso potentially make better use of a wide superscalar processor, as can bigger primitives like

mpn_addmul_2 or mpn_addmul_4. The restrictions on overlaps between sources and destinations (see Chapter 8 [Low-level Func-tions], page 56) are designed to facilitate a variety of implementations. For example, knowing

mpn_add_n won't have partly overlapping sources and destination means reading can be done farahead of writing on superscalar processors, and loops can be vectorized on a vector processor, depending on the carry handling. 16.8.3 Carry Propagation The problem that presents most challenges in GMP is propagating carries from one limb to thenext. In functions like

mpn_addmul_1 and mpn_add_n, carries are the only dependencies betweenlimb operations.

On processors with carry flags, a straightforward CISC style adc is generally best. AMD K6 mpn_addmul_1 however is an example of an unusual set of circumstances where a branch worksout better.

On RISC processors generally an add and compare for overflow is used. This sort of thing canbe seen in `

mpn/generic/aors_n.c'. Some carry propagation schemes require 4 instructions,meaning at least 4 cycles per limb, but other schemes may use just 1 or 2. On wide superscalar

processors performance may be completely determined by the number of dependent instructionsbetween carry-in and carry-out for each limb.

On vector processors good use can be made of the fact that a carry bit only very rarely propagatesmore than one limb. When adding a single bit to a limb, there's only a carry out if that limb was 0xFF...FF which on random data will be only 1 in 2mp bits per limb. `mpn/cray/add_n.c'is an example of this, it adds all limbs in parallel, adds one set of carry bits in parallel and then only rarely needs to fall through to a loop propagating further carries.

108 GNU MP 4.2.3 On the x86s, GCC (as of version 2.95.2) doesn't generate particularly good code for the RISCstyle idioms that are necessary to handle carry bits in C. Often conditional jumps are generated where adc or sbb forms would be better. And so unfortunately almost any loop involving carrybits needs to be coded in assembly for best results.

16.8.4 Cache Handling GMP aims to perform well both on operands that fit entirely in L1 cache and those which don't.

Basic routines like mpn_add_n or mpn_lshift are often used on large operands, so L2 and mainmemory performance is important for them.

mpn_mul_1 and mpn_addmul_1 are mostly usedfor multiply and square basecases, so L1 performance matters most for them, unless assembly

versions of mpn_mul_basecase and mpn_sqr_basecase exist, in which case the remaining usesare mostly for larger operands.

For L2 or main memory operands, memory access times will almost certainly be more thanthe calculation time. The aim therefore is to maximize memory throughput, by starting a load of the next cache line while processing the contents of the previous one. Clearly this is onlypossible if the chip has a lock-up free cache or some sort of prefetch instruction. Most current chips have both these features. Prefetching sources combines well with loop unrolling, since a prefetch can be initiated once perunrolled loop (or more than once if the loop covers more than one cache line).

On CPUs without write-allocate caches, prefetching destinations will ensure individual storesdon't go further down the cache hierarchy, limiting bandwidth. Of course for calculations which are slow anyway, like mpn_divrem_1, write-throughs might be fine. The distance ahead to prefetch will be determined by memory latency versus throughput. Theaim of course is to have data arriving continuously, at peak throughput. Some CPUs have limits

on the number of fetches or prefetches in progress. If a special prefetch instruction doesn't exist then a plain load can be used, but in that case caremust be taken not to attempt to read past the end of an operand, since that might produce a

segmentation violation. Some CPUs or systems have hardware that detects sequential memory accesses and initiatessuitable cache movements automatically, making life easy.

16.8.5 Functional Units When choosing an approach for an assembly loop, consideration is given to what operationscan execute simultaneously and what throughput can thereby be achieved. In some cases an

algorithm can be tweaked to accommodate available resources. Loop control will generally require a counter and pointer updates, costing as much as 5 in-structions, plus any delays a branch introduces. CPU addressing modes might reduce pointer

updates, perhaps by allowing just one updating pointer and others expressed as offsets from it,or on CISC chips with all addressing done with the loop counter as a scaled index.

The final loop control cost can be amortised by processing several limbs in each iteration (seeSection 16.8.9 [Assembly Loop Unrolling], page 110). This at least ensures loop control isn't a big fraction the work done. Memory throughput is always a limit. If perhaps only one load or one store can be done percycle then 3 cycles/limb will the top speed for "binary" operations like

mpn_add_n, and anycode achieving that is optimal.

Chapter 16: Algorithms 109 Integer resources can be freed up by having the loop counter in a float register, or by pressingthe float units into use for some multiplying, perhaps doing every second limb on the float side (see Section 16.8.6 [Assembly Floating Point], page 109). Float resources can be freed up by doing carry propagation on the integer side, or even by doinginteger to float conversions in integers using bit twiddling.

16.8.6 Floating Point Floating point arithmetic is used in GMP for multiplications on CPUs with poor integer multi-pliers. It's mostly useful for

mpn_mul_1, mpn_addmul_1 and mpn_submul_1 on 64-bit machines,and mpn_mul_basecase on both 32-bit and 64-bit machines.

With IEEE 53-bit double precision floats, integer multiplications producing up to 53 bits will giveexact results. Breaking a 64*64 multiplication into eight 16*32 ! 48 bit pieces is convenient.

With some care though six 21*32 ! 53 bit products can be used, if one of the lower two 21-bitpieces also uses the sign bit.

For the mpn_mul_1 family of functions on a 64-bit machine, the invariant single limb is splitat the start, into 3 or 4 pieces. Inside the loop, the bignum operand is split into 32-bit pieces. Fast conversion of these unsigned 32-bit pieces to floating point is highly machine-dependent. Insome cases, reading the data into the integer unit, zero-extending to 64-bits, then transferring to the floating point unit back via memory is the only option. Converting partial products back to 64-bit limbs is usually best done as a signed conversion.Since all values are smaller than 2

53, signed and unsigned are the same, but most processors

lack unsigned conversions.

Here is a diagram showing 16*32 bit products for an mpn_mul_1 or mpn_addmul_1 with a 64-bitlimb. The single limb operand V is split into four 16-bit parts. The multi-limb operand U is split in the loop into two 32-bit parts.

v48 v32 v16 v00 V Operand*

u32 u00 U Operand (one limb)

u00 * v00 p00 48-bit products u00 * v16 p16 u00 * v32 p32 u00 * v48 p48

u32 * v00 r32 u32 * v16 r48 u32 * v32 r64 u32 * v48 r80

p32 and r32 can be summed using floating-point addition, and likewise p48 and r48. p00 and p16 can be summed with r64 and r80 from the previous iteration.

For each loop then, four 49-bit quantities are transfered to the integer unit, aligned as follows,

110 GNU MP 4.2.3

64 bits 64 bits

p00 + r640 i00 p16 + r800 i16 p32 + r32 i32 p48 + r48 i48

The challenge then is to sum these efficiently and add in a carry limb, generating a low 64-bitresult limb and a high 33-bit carry limb (

i48 extends 33 bits into the high half).

16.8.7 SIMD Instructions The single-instruction multiple-data support in current microprocessors is aimed at signal pro-cessing algorithms where each data point can be treated more or less independently. There's

generally not much support for propagating the sort of carries that arise in GMP. SIMD multiplications of say four 16*16 bit multiplies only do as much work as one 32*32 fromGMP's point of view, and need some shifts and adds besides. But of course if say the SIMD

form is fully pipelined and uses less instruction decoding then it may still be worthwhile. On the x86 chips, MMX has so far found a use in mpn_rshift and mpn_lshift, and is used in aspecial case for 16-bit multipliers in the P55

mpn_mul_1. SSE2 is used for Pentium 4 mpn_mul_1, mpn_addmul_1, and mpn_submul_1.

16.8.8 Software Pipelining Software pipelining consists of scheduling instructions around the branch point in a loop. Forexample a loop might issue a load not for use in the present iteration but the next, thereby

allowing extra cycles for the data to arrive from memory. Naturally this is wanted only when doing things like loads or multiplies that take several cyclesto complete, and only where a CPU has multiple functional units so that other work can be

done in the meantime. A pipeline with several stages will have a data value in progress at each stage and each loopiteration moves them along one stage. This is like juggling.

If the latency of some instruction is greater than the loop time then it will be necessary to unroll,so one register has a result ready to use while another (or multiple others) are still in progress. (see Section 16.8.9 [Assembly Loop Unrolling], page 110). 16.8.9 Loop Unrolling Loop unrolling consists of replicating code so that several limbs are processed in each loop.At a minimum this reduces loop overheads by a corresponding factor, but it can also allow

better register usage, for example alternately using one register combination and then another.Judicious use of

m4 macros can help avoid lots of duplication in the source code.

Any amount of unrolling can be handled with a loop counter that's decremented by N eachtime, stopping when the remaining count is less than the further

N the loop will process. Or bysubtracting N at the start, the termination condition becomes when the counter C is less than0 (and the count of remaining limbs is

C + N ).

Alternately for a power of 2 unroll the loop count and remainder can be established with a shiftand mask. This is convenient if also making a computed jump into the middle of a large loop.

The limbs not a multiple of the unrolling can be handled in various ways, for example

* A simple loop at the end (or the start) to process the excess. Care will be wanted that itisn't too much slower than the unrolled part.

Chapter 16: Algorithms 111

* A set of binary tests, for example after an 8-limb unrolling, test for 4 more limbs to process,then a further 2 more or not, and finally 1 more or not. This will probably take more code

space than a simple loop.* A switch statement, providing separate code for each possible excess, for example an 8-limbunrolling would have separate code for 0 remaining, 1 remaining, etc, up to 7 remaining.

This might take a lot of code, but may be the best way to optimize all cases in combinationwith a deep pipelined loop.

* A computed jump into the middle of the loop, thus making the first iteration handle theexcess. This should make times smoothly increase with size, which is attractive, but setups

for the jump and adjustments for pointers can be tricky and could become quite difficult incombination with deep pipelining.

16.8.10 Writing Guide This is a guide to writing software pipelined loops for processing limb vectors in assembly.

First determine the algorithm and which instructions are needed. Code it without unrolling orscheduling, to make sure it works. On a 3-operand CPU try to write each new value to a new

register, this will greatly simplify later steps. Then note for each instruction the functional unit and/or issue port requirements. If an instruc-tion can use either of two units, like U0 or U1 then make a category "U0/U1". Count the total

using each unit (or combined unit), and count all instructions. Figure out from those counts the best possible loop time. The goal will be to find a perfectschedule where instruction latencies are completely hidden. The total instruction count might

be the limiting factor, or perhaps a particular functional unit. It might be possible to tweak theinstructions to help the limiting factor.

Suppose the loop time is N , then make N issue buckets, with the final loop branch at the end ofthe last. Now fill the buckets with dummy instructions using the functional units desired. Run this to make sure the intended speed is reached. Now replace the dummy instructions with the real instructions from the slow but correct loopyou started with. The first will typically be a load instruction. Then the instruction using that

value is placed in a bucket an appropriate distance down. Run the loop again, to check it stillruns at target speed.

Keep placing instructions, frequently measuring the loop. After a few you will need to wraparound from the last bucket back to the top of the loop. If you used the new-register for newvalue strategy above then there will be no register conflicts. If not then take care not to clobbersomething already in use. Changing registers at this time is very error prone.

The loop will overlap two or more of the original loop iterations, and the computation of onevector element result will be started in one iteration of the new loop, and completed one or several iterations later. The final step is to create feed-in and wind-down code for the loop. A good way to do this isto make a copy (or copies) of the loop at the start and delete those instructions which don't

have valid antecedents, and at the end replicate and delete those whose results are unwanted(including any further loads).

The loop will have a minimum number of limbs loaded and processed, so the feed-in code musttest if the request size is smaller and skip either to a suitable part of the wind-down or to special code for small sizes.

112 GNU MP 4.2.3 17 Internals This chapter is provided only for informational purposes and the various internals described here may change in future GMP releases. Applications expecting to be compatible with future releases should use only the documented interfaces described in previous chapters.

17.1 Integer Internals mpz_t variables represent integers using sign and magnitude, in space dynamically allocated andreallocated. The fields are as follows.

_mp_size The number of limbs, or the negative of that when representing a negative integer.Zero is represented by

_mp_size set to zero, in which case the _mp_d data is unused.

_mp_d A pointer to an array of limbs which is the magnitude. These are stored "littleendian" as per the

mpn functions, so _mp_d[0] is the least significant limb and _mp_ d[ABS(_mp_size)-1] is the most significant. Whenever _mp_size is non-zero, themost significant limb is non-zero.

Currently there's always at least one limb allocated, so for instance mpz_set_uinever needs to reallocate, and

mpz_get_ui can fetch _mp_d[0] unconditionally(though its value is then only wanted if

_mp_size is non-zero).

_mp_alloc

_mp_alloc is the number of limbs currently allocated at _mp_d, and naturally _mp_ alloc >= ABS(_mp_size). When an mpz routine is about to (or might be about to)increase

_mp_size, it checks _mp_alloc to see whether there's enough space, andreallocates if not.

MPZ_REALLOC is generally used for this.

The various bitwise logical functions like mpz_and behave as if negative values were twos com-plement. But sign and magnitude is always used internally, and necessary adjustments are made

during the calculations. Sometimes this isn't pretty, but sign and magnitude are best for otherroutines.

Some internal temporary variables are setup with MPZ_TMP_INIT and these have _mp_d spaceobtained from

TMP_ALLOC rather than the memory allocation functions. Care is taken to ensurethat these are big enough that no reallocation is necessary (since it would have unpredictable

consequences). _mp_size and _mp_alloc are int, although mp_size_t is usually a long. This is done to makethe fields just 32 bits on some 64 bits systems, thereby saving a few bytes of data space but still

providing plenty of range. 17.2 Rational Internals mpq_t variables represent rationals using an mpz_t numerator and denominator (see Section 17.1[Integer Internals], page 112).

The canonical form adopted is denominator positive (and non-zero), no common factors betweennumerator and denominator, and zero uniquely represented as 0/1. It's believed that casting out common factors at each stage of a calculation is best in general. AGCD is an

O(N 2) operation so it's better to do a few small ones immediately than to delay andhave to do a big one later. Knowing the numerator and denominator have no common factors

can be used for example in mpq_mul to make only two cross GCDs necessary, not four. This general approach to common factors is badly sub-optimal in the presence of simple factor-izations or little prospect for cancellation, but GMP has no way to know when this will occur.

Chapter 17: Internals 113 As per Section 3.11 [Efficiency], page 21, that's left to applications. The mpq_t framework mightstill suit, with

mpq_numref and mpq_denref for direct access to the numerator and denominator,or of course mpz_t variables can be used directly.

17.3 Float Internals Efficient calculation is the primary aim of GMP floats and the use of whole limbs and simplerounding facilitates this.

mpf_t floats have a variable precision mantissa and a single machine word signed exponent. Themantissa is represented using sign and magnitude.

most significant limb least significant limb

mp exp ! mp d

*  radix point mp size !

The fields are as follows.

_mp_size The number of limbs currently in use, or the negative of that when representing anegative value. Zero is represented by

_mp_size and _mp_exp both set to zero, andin that case the _mp_d data is unused. (In the future _mp_exp might be undefinedwhen representing zero.)

_mp_prec The precision of the mantissa, in limbs. In any calculation the aim is to produce

_mp_prec limbs of result (the most significant being non-zero).

_mp_d A pointer to the array of limbs which is the absolute value of the mantissa. These arestored "little endian" as per the

mpn functions, so _mp_d[0] is the least significantlimb and _mp_d[ABS(_mp_size)-1] the most significant.

The most significant limb is always non-zero, but there are no other restrictions onits value, in particular the highest 1 bit can be anywhere within the limb.

_mp_prec+1 limbs are allocated to _mp_d, the extra limb being for convenience (seebelow). There are no reallocations during a calculation, only in a change of precision with mpf_set_prec. _mp_exp The exponent, in limbs, determining the location of the implied radix point. Zeromeans the radix point is just above the most significant limb. Positive values mean

a radix point offset towards the lower limbs and hence a value >= 1, as for examplein the diagram above. Negative exponents mean a radix point further above the highest limb. Naturally the exponent can be any value, it doesn't have to fall within the limbs asthe diagram shows, it can be a long way above or a long way below. Limbs other

than those included in the {_mp_d,_mp_size} data are treated as zero. The _mp_size and _mp_prec fields are int, although the mp_size_t type is usually a long.The

_mp_exp field is usually long. This is done to make some fields just 32 bits on some 64 bitssystems, thereby saving a few bytes of data space but still providing plenty of precision and a

very large range.

The following various points should be noted. Low Zeros The least significant limbs _mp_d[0] etc can be zero, though such low zeros canalways be ignored. Routines likely to produce low zeros check and avoid them to

114 GNU MP 4.2.3

save time in subsequent calculations, but for most routines they're quite unlikelyand aren't checked. Mantissa Size RangeThe

_mp_size count of limbs in use can be less than _mp_prec if the value can berepresented in less. This means low precision values or small integers stored in a

high precision mpf_t can still be operated on efficiently. _mp_size can also be greater than _mp_prec. Firstly a value is allowed to use allof the

_mp_prec+1 limbs available at _mp_d, and secondly when mpf_set_prec_rawlowers

_mp_prec it leaves _mp_size unchanged and so the size can be arbitrarilybigger than

_mp_prec.

Rounding All rounding is done on limb boundaries. Calculating _mp_prec limbs with the highnon-zero will ensure the application requested minimum precision is obtained.

The use of simple "trunc" rounding towards zero is efficient, since there's no needto examine extra limbs and increment or decrement. Bit Shifts Since the exponent is in limbs, there are no bit shifts in basic operations like mpf_

add and mpf_mul. When differing exponents are encountered all that's needed is toadjust pointers to line up the relevant limbs.

Of course mpf_mul_2exp and mpf_div_2exp will require bit shifts, but the choiceis between an exponent in limbs which requires shifts there, or one in bits which requires them almost everywhere else. Use of _mp_prec+1 LimbsThe extra limb on

_mp_d (_mp_prec+1 rather than just _mp_prec) helps when an mpf routine might get a carry from its operation. mpf_add for instance will do an mpn_add of _mp_prec limbs. If there's no carry then that's the result, but if there is acarry then it's stored in the extra limb of space and

_mp_size becomes _mp_prec+1.

Whenever _mp_prec+1 limbs are held in a variable, the low limb is not needed forthe intended precision, only the

_mp_prec high limbs. But zeroing it out or movingthe rest down is unnecessary. Subsequent routines reading the value will simply take

the high limbs they need, and this will be _mp_prec if their target has that sameprecision. This is no more than a pointer adjustment, and must be checked anyway since the destination precision can be different from the sources. Copy functions like mpf_set will retain a full _mp_prec+1 limbs if available. Thisensures that a variable which has

_mp_size equal to _mp_prec+1 will get its fullexact value copied. Strictly speaking this is unnecessary since only

_mp_prec limbsare needed for the application's requested precision, but it's considered that an

mpf_ set from one variable into another of the same precision ought to produce an exactcopy.

Application Precisions

__GMPF_BITS_TO_PREC converts an application requested precision to an _mp_prec.The value in bits is rounded up to a whole limb then an extra limb is added since

the most significant limb of _mp_d is only non-zero and therefore might contain onlyone bit.

__GMPF_PREC_TO_BITS does the reverse conversion, and removes the extra limb from _mp_prec before converting to bits. The net effect of reading back with mpf_get_ prec is simply the precision rounded up to a multiple of mp_bits_per_limb.

Note that the extra limb added here for the high only being non-zero is in additionto the extra limb allocated to

_mp_d. For example with a 32-bit limb, an applicationrequest for 250 bits will be rounded up to 8 limbs, then an extra added for the high

being only non-zero, giving an _mp_prec of 9. _mp_d then gets 10 limbs allocated.

Chapter 17: Internals 115

Reading back with mpf_get_prec will take _mp_prec subtract 1 limb and multiplyby 32, giving 256 bits. Strictly speaking, the fact the high limb has at least one bit means that a float with,say, 3 limbs of 32-bits each will be holding at least 65 bits, but for the purposes of mpf_t it's considered simply to be 64 bits, a nice multiple of the limb size.

17.4 Raw Output Internals mpz_out_raw uses the following format.

size data bytes

The size is 4 bytes written most significant byte first, being the number of subsequent databytes, or the twos complement negative of that when a negative integer is represented. The data bytes are the absolute value of the integer, written most significant byte first. The most significant data byte is always non-zero, so the output is the same on all systems,irrespective of limb size.

In GMP 1, leading zero bytes were written to pad the data bytes to a multiple of the limb size. mpz_inp_raw will still accept this, for compatibility.

The use of "big endian" for both the size and data fields is deliberate, it makes the data easy toread in a hex dump of a file. Unfortunately it also means that the limb data must be reversed

when reading or writing, so neither a big endian nor little endian system can just read and write _mp_d.

17.5 C++ Interface Internals A system of expression templates is used to ensure something like a=b+c turns into a simple callto

mpz_add etc. For mpf_class the scheme also ensures the precision of the final destinationis used for any temporaries within a statement like

f=w*x+y*z. These are important featureswhich a naive implementation cannot provide.

A simplified description of the scheme follows. The true scheme is complicated by the fact thatexpressions have different return types. For detailed information, refer to the source code. To perform an operation, say, addition, we first define a "function object" evaluating it,

struct __gmp_binary_plus {

static void eval(mpf_t f, mpf_t g, mpf_t h) { mpf_add(f, g, h); } };

And an "additive expression" object,

__gmp_expr<__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> > operator+(const mpf_class &f, const mpf_class &g) {

return __gmp_expr

<__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> >(f, g); }

The seemingly redundant __gmp_expr<__gmp_binary_expr<...>> is used to encapsulate anypossible kind of expression into a single template type. In fact even

mpf_class etc are typedefspecializations of __gmp_expr.

116 GNU MP 4.2.3 Next we define assignment of __gmp_expr to mpf_class.

template <class T> mpf_class & mpf_class::operator=(const __gmp_expr<T> &expr) {

expr.eval(this->get_mpf_t(), this->precision()); return *this; }

template <class Op> void __gmp_expr<__gmp_binary_expr<mpf_class, mpf_class, Op> >::eval (mpf_t f, unsigned long int precision) {

Op::eval(f, expr.val1.get_mpf_t(), expr.val2.get_mpf_t()); }

where expr.val1 and expr.val2 are references to the expression's operands (here expr is the __gmp_binary_expr stored within the __gmp_expr).

This way, the expression is actually evaluated only at the time of assignment, when the requiredprecision (that of

f) is known. Furthermore the target mpf_t is now available, thus we can call mpf_add directly with f as the output argument.

Compound expressions are handled by defining operators taking subexpressions as their argu-ments, like this:

template <class T, class U> __gmp_expr <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, __gmp_binary_plus> > operator+(const __gmp_expr<T> &expr1, const __gmp_expr<U> &expr2) {

return __gmp_expr

<__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, __gmp_binary_plus> > (expr1, expr2); }

And the corresponding specializations of __gmp_expr::eval:

template <class T, class U, class Op> void __gmp_expr <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, Op> >::eval (mpf_t f, unsigned long int precision) {

// declare two temporaries mpf_class temp1(expr.val1, precision), temp2(expr.val2, precision); Op::eval(f, temp1.get_mpf_t(), temp2.get_mpf_t()); }

The expression is thus recursively evaluated to any level of complexity and all subexpressionsare evaluated to the precision of

f.

Appendix A: Contributors 117 Appendix A Contributors Torbj"orn Granlund wrote the original GMP library and is still the main developer. Code notexplicitly attributed to others, was contributed by Torbj"orn. Several other individuals and organizations have contributed to code that is in version of GMP. Here is a list in chronologicalorder on first contribution:

Gunnar Sj"odin and Hans Riesel helped with mathematical problems in early versions of thelibrary. Richard Stallman helped with the interface design and revised the first version of this manual. Brian Beuning and Doug Lea helped with testing of early versions of the library and madecreative suggestions.

John Amanatides of York University in Canada contributed the function mpz_probab_prime_p. Paul Zimmermann wrote the divide and conquer division code, the REDC-based mpz powmcode, the Sch"onhage-Strassen FFT multiply code, and the Karatsuba square root code. He also

improved the Toom3 code for GMP 4.2. Paul sparked the development of GMP 2, with hiscomparisons between bignum packages. The ECMNET project Paul is organizing was a driving force behind many of the optimizations in GMP 3. Ken Weber (Kent State University, Universidade Federal do Rio Grande do Sul) contributed mpz_gcd, mpz_divexact, mpn_gcd, and mpn_bdivmod, partially supported by CNPq (Brazil)grant 301314194-2.

Per Bothner of Cygnus Support helped to set up GMP to use Cygnus' configure. He has alsomade valuable suggestions and tested numerous intermediary releases. Joachim Hollman was involved in the design of the mpf interface, and in the mpz design revisionsfor version 2. Bennet Yee contributed the initial versions of mpz_jacobi and mpz_legendre. Andreas Schwab contributed the files `mpn/m68k/lshift.S' and `mpn/m68k/rshift.S' (now in`

.asm' form).

Robert Harley of Inria, France and David Seal of ARM, England, suggested clever improve-ments for population count. Robert also wrote highly optimized Karatsuba and 3-way Toom

multiplication functions for GMP 3, and contributed the ARM assembly code. Torsten Ekedahl of the Mathematical department of Stockholm University provided significantinspiration during several phases of the GMP development. His mathematical expertise helped

improve several algorithms. Linus Nordberg wrote the new configure system based on autoconf and implemented the newrandom functions.

Kevin Ryde worked on a large number of things: optimized x86 code, m4 asm macros, parametertuning, speed measuring, the configure system, function inlining, divisibility tests, bit scanning, Jacobi symbols, Fibonacci and Lucas number functions, printf and scanf functions, perl interface,demo expression parser, the algorithms chapter in the manual, `

gmpasm-mode.el', and variousmiscellaneous improvements elsewhere.

Kent Boortz made the Mac OS 9 port. Steve Root helped write the optimized alpha 21264 assembly code.

118 GNU MP 4.2.3 Gerardo Ballabio wrote the `gmpxx.h' C++ class interface and the C++ istream input routines. Jason Moxham rewrote mpz_fac_ui. Pedro Gimeno implemented the Mersenne Twister and made other random number improve-ments.

The development of floating point functions of GNU MP 2, were supported in part by theESPRIT-BRA (Basic Research Activities) 6846 project POSSO (POlynomial System SOlving). The development of GMP 2, 3, and 4 was supported in part by the IDA Center for ComputingSciences. (This list is chronological, not ordered after significance. If you have contributed to GMP butare not listed above, please tell

tege@swox.com about the omission!)

Thanks go to Hans Thorsen for donating an SGI system for the GMP test system environment.

Appendix B: References 119 Appendix B References B.1 Books

* Jonathan M. Borwein and Peter B. Borwein, "Pi and the AGM: A Study in AnalyticNumber Theory and Computational Complexity", Wiley, 1998.

* Henri Cohen, "A Course in Computational Algebraic Number Theory", Graduate Texts inMathematics number 138, Springer-Verlag, 1993.

http://www.math.u-bordeaux.fr/~cohen/* Donald E. Knuth, "The Art of Computer Programming", volume 2, "Seminumerical Algo-rithms", 3rd edition, Addison-Wesley, 1998.

http://www-cs-faculty.stanford.edu/~knuth/taocp.html* John D. Lipson, "Elements of Algebra and Algebraic Computing", The Benjamin CummingsPublishing Company Inc, 1981.

* Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone, "Handbook of AppliedCryptography",

http://www.cacr.math.uwaterloo.ca/hac/*

Richard M. Stallman, "Using and Porting GCC", Free Software Foundation, 1999,available online

http://gcc.gnu.org/onlinedocs/, and in the GCC package ftp://ftp.gnu.org/gnu/gcc/

B.2 Papers

* Yves Bertot, Nicolas Magaud and Paul Zimmermann, "A Proof of GMP Square Root",Journal of Automated Reasoning, volume 29, 2002, pp. 225-252. Also available online as

INRIA Research Report 4475, June 2001, http://www.inria.fr/rrrt/rr-4475.html* Christoph Burnikel and Joachim Ziegler, "Fast Recursive Division", Max-Planck-Institutfuer Informatik Research Report MPI-I-98-1-022,

http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022* Torbj"orn Granlund and Peter L. Montgomery, "Division by Invariant Integers using Multi-plication", in Proceedings of the SIGPLAN PLDI'94 Conference, June 1994. Also available

ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz (and .psl.gz).* Tudor Jebelean, "An algorithm for exact division", Journal of Symbolic Computation, vol-ume 15, 1993, pp. 169-180. Research report version available

ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz* Tudor Jebelean, "Exact Division with Karatsuba Complexity - Extended Abstract", RISC-Linz technical report 96-31,

ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz* Tudor Jebelean, "Practical Integer Division with Karatsuba Complexity", ISSAC 97, pp.339-341. Technical report available

ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz* Tudor Jebelean, "A Generalization of the Binary GCD Algorithm", ISSAC 93, pp. 111-116.Technical report version available

ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz* Tudor Jebelean, "A Double-Digit Lehmer-Euclid Algorithm for Finding the GCD of LongIntegers", Journal of Symbolic Computation, volume 19, 1995, pp. 145-157. Technical

report version also available

ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz*

Werner Krandick and Tudor Jebelean, "Bidirectional Exact Integer Division", Journal ofSymbolic Computation, volume 21, 1996, pp. 441-455. Early technical report version also

available ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz

120 GNU MP 4.2.3

* Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A 623-dimensionallyequidistributed uniform pseudorandom number generator", ACM Transactions on Modelling and Computer Simulation, volume 8, January 1998, pp. 3-30. Available online

http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.ps.gz (or .pdf)*

R. Moenck and A. Borodin, "Fast Modular Transforms via Division", Proceedings of the13th Annual IEEE Symposium on Switching and Automata Theory, October 1972, pp. 90-

96. Reprinted as "Fast Modular Transforms", Journal of Computer and System Sciences,volume 8, number 3, June 1974, pp. 366-386.

* Peter L. Montgomery, "Modular Multiplication Without Trial Division", in Mathematicsof Computation, volume 44, number 170, April 1985.

* Arnold Sch"onhage and Volker Strassen, "Schnelle Multiplikation grosser Zahlen", Comput-ing 7, 1971, pp. 281-292.

* Kenneth Weber, "The accelerated integer GCD algorithm", ACM Transactions on Mathe-matical Software, volume 21, number 1, March 1995, pp. 111-122.

* Paul Zimmermann, "Karatsuba Square Root", INRIA Research Report 3805, November1999,

http://www.inria.fr/rrrt/rr-3805.html*

Paul Zimmermann, "A Proof of GMP Fast Division and Square Root Implementations",

http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz*

Dan Zuras, "On Squaring and Multiplying Large Integers", ARITH-11: IEEE Symposiumon Computer Arithmetic, 1993, pp. 260 to 271. Reprinted as "More on Multiplying and

Squaring Large Integers", IEEE Transactions on Computers, volume 43, number 8, August1994, pp. 899-908.

Appendix C: GNU Free Documentation License 121 Appendix C GNU Free Documentation License

Version 1.2, November 2002 Copyright cfl 2000,2001,2002 Free Software Foundation, Inc.51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA

Everyone is permitted to copy and distribute verbatim copiesof this license document, but changing it is not allowed. 0. PREAMBLE

The purpose of this License is to make a manual, textbook, or other functional and usefuldocument

free in the sense of freedom: to assure everyone the effective freedom to copyand redistribute it, with or without modifying it, either commercially or noncommercially.

Secondarily, this License preserves for the author and publisher a way to get credit for theirwork, while not being considered responsible for modifications made by others. This License is a kind of "copyleft", which means that derivative works of the documentmust themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because freesoftware needs free documentation: a free program should come with manuals providing the

same freedoms that the software does. But this License is not limited to software manuals;it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose isinstruction or reference.

1. APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that contains a noticeplaced by the copyright holder saying it can be distributed under the terms of this License.

Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use thatwork under the conditions stated herein. The "Document", below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as "you". You acceptthe license if you copy, modify or distribute the work in a way requiring permission under copyright law. A "Modified Version" of the Document means any work containing the Document or aportion of it, either copied verbatim, or with modifications and/or translated into another

language. A "Secondary Section" is a named appendix or a front-matter section of the Documentthat deals exclusively with the relationship of the publishers or authors of the Document

to the Document's overall subject (or to related matters) and contains nothing that couldfall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationshipcould be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The "Invariant Sections" are certain Secondary Sections whose titles are designated, asbeing those of Invariant Sections, in the notice that says that the Document is released

under this License. If a section does not fit the above definition of Secondary then it is notallowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The "Cover Texts" are certain short passages of text that are listed, as Front-Cover Texts orBack-Cover Texts, in the notice that says that the Document is released under this License.

A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25words.

122 GNU MP 4.2.3

A "Transparent" copy of the Document means a machine-readable copy, represented in aformat whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels)generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formatssuitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequentmodification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not "Transparent" is called "Opaque". Examples of suitable formats for Transparent copies include plain ascii without markup,Texinfo input format, LaT

EX input format, SGML or XML using a publicly available DTD,and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formatsinclude proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available,and the machine-generated

HTML, PostScript or PDF produced by some word processorsfor output purposes only.

The "Title Page" means, for a printed book, the title page itself, plus such following pagesas are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, "Title Page" means thetext near the most prominent appearance of the work's title, preceding the beginning of the body of the text. A section "Entitled XYZ" means a named subunit of the Document whose title eitheris precisely XYZ or contains XYZ in parentheses following text that translates XYZ in

another language. (Here XYZ stands for a specific section name mentioned below, suchas "Acknowledgements", "Dedications", "Endorsements", or "History".) To "Preserve the Title" of such a section when you modify the Document means that it remains a section"Entitled XYZ" according to this definition.

The Document may include Warranty Disclaimers next to the notice which states thatthis License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any otherimplication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License. 2. VERBATIM COPYING

You may copy and distribute the Document in any medium, either commercially or noncom-mercially, provided that this License, the copyright notices, and the license notice saying

this License applies to the Document are reproduced in all copies, and that you add noother conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute.However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publiclydisplay copies.

3. COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have printed covers) of theDocument, numbering more than 100, and the Document's license notice requires Cover

Texts, you must enclose the copies in covers that carry, clearly and legibly, all these CoverTexts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The frontcover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to

Appendix C: GNU Free Documentation License 123

the covers, as long as they preserve the title of the Document and satisfy these conditions,can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put thefirst ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, youmust either include a machine-readable Transparent copy along with each Opaque copy,

or state in or with each Opaque copy a computer-network location from which the generalnetwork-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latteroption, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at thestated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well beforeredistributing any large number of copies, to give them a chance to provide you with an

updated version of the Document. 4. MODIFICATIONS

You may copy and distribute a Modified Version of the Document under the conditionsof sections 2 and 3 above, provided that you release the Modified Version under precisely

this License, with the Modified Version filling the role of the Document, thus licensingdistribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:

A. Use in the Title Page (and on the covers, if any) a title distinct from that of theDocument, and from those of previous versions (which should, if there were any, be

listed in the History section of the Document). You may use the same title as a previousversion if the original publisher of that version gives permission. B. List on the Title Page, as authors, one or more persons or entities responsible forauthorship of the modifications in the Modified Version, together with at least five of

the principal authors of the Document (all of its principal authors, if it has fewer thanfive), unless they release you from this requirement. C. State on the Title page the name of the publisher of the Modified Version, as thepublisher. D. Preserve all the copyright notices of the Document.

E. Add an appropriate copyright notice for your modifications adjacent to the other copy-right notices.

F. Include, immediately after the copyright notices, a license notice giving the publicpermission to use the Modified Version under the terms of this License, in the form

shown in the Addendum below. G. Preserve in that license notice the full lists of Invariant Sections and required CoverTexts given in the Document's license notice.

H. Include an unaltered copy of this License.

I. Preserve the section Entitled "History", Preserve its Title, and add to it an item statingat least the title, year, new authors, and publisher of the Modified Version as given

on the Title Page. If there is no section Entitled "History" in the Document, createone stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previoussentence. J. Preserve the network location, if any, given in the Document for public access to aTransparent copy of the Document, and likewise the network locations given in the

124 GNU MP 4.2.3

Document for previous versions it was based on. These may be placed in the "History"section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers togives permission.

K. For any section Entitled "Acknowledgements" or "Dedications", Preserve the Titleof the section, and preserve in the section all the substance and tone of each of the

contributor acknowledgements and/or dedications given therein. L. Preserve all the Invariant Sections of the Document, unaltered in their text and in theirtitles. Section numbers or the equivalent are not considered part of the section titles.

M. Delete any section Entitled "Endorsements". Such a section may not be included inthe Modified Version.

N. Do not retitle any existing section to be Entitled "Endorsements" or to conflict in titlewith any Invariant Section. O. Preserve any Warranty Disclaimers. If the Modified Version includes new front-matter sections or appendices that qualify asSecondary Sections and contain no material copied from the Document, you may at your

option designate some or all of these sections as invariant. To do this, add their titles tothe list of Invariant Sections in the Modified Version's license notice. These titles must be distinct from any other section titles. You may add a section Entitled "Endorsements", provided it contains nothing but endorse-ments of your Modified Version by various parties--for example, statements of peer review

or that the text has been approved by an organization as the authoritative definition of astandard.

You may add a passage of up to five words as a Front-Cover Text, and a passage of upto 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be addedby (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by thesame entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission touse their names for publicity for or to assert or imply endorsement of any Modified Version.

5. COMBINING DOCUMENTS

You may combine the Document with other documents released under this License, underthe terms defined in section 4 above for modified versions, provided that you include in the

combination all of the Invariant Sections of all of the original documents, unmodified, andlist them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identicalInvariant Sections may be replaced with a single copy. If there are multiple Invariant

Sections with the same name but different contents, make the title of each such sectionunique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment tothe section titles in the list of Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled "History" in the various originaldocuments, forming one section Entitled "History"; likewise combine any sections Entitled "Acknowledgements", and any sections Entitled "Dedications". You must delete all sectionsEntitled "Endorsements."

Appendix C: GNU Free Documentation License 125

6. COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents released underthis License, and replace the individual copies of this License in the various documents with

a single copy that is included in the collection, provided that you follow the rules of thisLicense for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individuallyunder this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document. 7. AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate and independentdocuments or works, in or on a volume of a storage or distribution medium, is called an

"aggregate" if the copyright resulting from the compilation is not used to limit the legalrights of the compilation's users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works inthe aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document,then if the Document is less than one half of the entire aggregate, the Document's Cover Texts may be placed on covers that bracket the Document within the aggregate, or theelectronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate. 8. TRANSLATION

Translation is considered a kind of modification, so you may distribute translations of theDocument under the terms of section 4. Replacing Invariant Sections with translations

requires special permission from their copyright holders, but you may include translationsof some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices inthe Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. Incase of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled "Acknowledgements", "Dedications", or "History",the requirement (section 4) to Preserve its Title (section 1) will typically require changing

the actual title. 9. TERMINATION

You may not copy, modify, sublicense, or distribute the Document except as expresslyprovided for under this License. Any other attempt to copy, modify, sublicense or distribute

the Document is void, and will automatically terminate your rights under this License.However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 10. FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions of the GNU Free Doc-umentation License from time to time. Such new versions will be similar in spirit to

the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number. If the Documentspecifies that a particular numbered version of this License "or any later version" applies

to it, you have the option of following the terms and conditions either of that specifiedversion or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you maychoose any version ever published (not as a draft) by the Free Software Foundation.

126 GNU MP 4.2.3 C.1 ADDENDUM: How to use this License for your documents To use this License in a document you have written, include a copy of the License in the documentand put the following copyright and license notices just after the title page:

Copyright (C) year your name. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled ``GNU Free Documentation License''.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the"with. . . Texts." line with this:

with the Invariant Sections being list their titles, with the Front-Cover Texts being list, and with the Back-Cover Texts being list.

If you have Invariant Sections without Cover Texts, or some other combination of the three,merge those two alternatives to suit the situation.

If your document contains nontrivial examples of program code, we recommend releasing theseexamples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.

Concept Index 127 Concept Index # #include . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

- --build. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 --disable-fft . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 --disable-shared . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 --disable-static . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 --enable-alloca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 --enable-assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 --enable-cxx . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 `--enable-fat' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 --enable-mpbsd. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 --enable-profiling . . . . . . . . . . . . . . . . . . . . . . . . . . 7, 25 --exec-prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 --host . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 --prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 -finstrument-functions . . . . . . . . . . . . . . . . . . . . . . . . 26

2 2exp functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

6 68000 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

8 80x86 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

A ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5, 8 About this manual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 AC_CHECK_LIB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 AIX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 12 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 alloca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Allocation of memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 AMD64 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Anonymous FTP of latest version . . . . . . . . . . . . . . . . . 2 Application Binary Interface. . . . . . . . . . . . . . . . . . . . . . . 8 Arithmetic functions . . . . . . . . . . . . . . . . . . . . . . 32, 45, 52 ARM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Assembly cache handling . . . . . . . . . . . . . . . . . . . . . . . . 108 Assembly carry propagation . . . . . . . . . . . . . . . . . . . . . 107 Assembly code organisation . . . . . . . . . . . . . . . . . . . . . 107 Assembly coding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 Assembly floating Point . . . . . . . . . . . . . . . . . . . . . . . . . 109 Assembly loop unrolling . . . . . . . . . . . . . . . . . . . . . . . . . 110 Assembly SIMD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110 Assembly software pipelining . . . . . . . . . . . . . . . . . . . . 110 Assembly writing guide . . . . . . . . . . . . . . . . . . . . . . . . . 111 Assertion checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7, 24 Assignment functions. . . . . . . . . . . . . . . . . . 29, 30, 44, 50 Autoconf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

B Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Berkeley MP compatible functions . . . . . . . . . . . . . 7, 83 Binomial coefficient algorithm . . . . . . . . . . . . . . . . . . . 105 Binomial coefficient functions. . . . . . . . . . . . . . . . . . . . . 37 Binutils strip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Bit manipulation functions . . . . . . . . . . . . . . . . . . . . . . . 38 Bit scanning functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 Bit shift left . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 Bit shift right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 Bits per limb. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 BSD MP compatible functions . . . . . . . . . . . . . . . . . 7, 83 Bug reporting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 Build directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Build notes for binary packaging . . . . . . . . . . . . . . . . . 11 Build notes for particular systems . . . . . . . . . . . . . . . . 12 Build options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Build problems known . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Build system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Building GMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Bus error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

C C compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 C++ compiler. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 C++ interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 C++ interface internals . . . . . . . . . . . . . . . . . . . . . . . . . . 115 C++ istream input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 C++ ostream output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 C++ support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 CC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 CC_FOR_BUILD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 CFLAGS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 Checker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 checkergcc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 Code organisation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Compaq C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Comparison functions . . . . . . . . . . . . . . . . . . . . . 37, 46, 53 Compatibility with older versions . . . . . . . . . . . . . . . . . 20 Conditions for copying GNU MP . . . . . . . . . . . . . . . . . . 1 Configuring GMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Congruence algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 Congruence functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Contributors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 Conventions for parameters . . . . . . . . . . . . . . . . . . . . . . 18 Conventions for variables . . . . . . . . . . . . . . . . . . . . . . . . . 17 Conversion functions . . . . . . . . . . . . . . . . . . . . . . 31, 45, 51 Copying conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 CPPFLAGS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 CPU types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2, 4 Cross compiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 Custom allocation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 CXX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 CXXFLAGS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Cygwin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

128 GNU MP 4.2.3 D Darwin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Demonstration programs . . . . . . . . . . . . . . . . . . . . . . . . . 20 Digits in an integer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 Divisibility algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 Divisibility functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 Divisibility testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 Division algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 Division functions. . . . . . . . . . . . . . . . . . . . . . . . . 32, 45, 52 DJGPP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12, 14 DLLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 DocBook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Documentation formats . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Documentation license . . . . . . . . . . . . . . . . . . . . . . . . . . 121 DVI. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

E Efficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Emacs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Exact division functions . . . . . . . . . . . . . . . . . . . . . . . . . . 34 Exact remainder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 Example programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Exec prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Execution profiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7, 25 Exponentiation functions . . . . . . . . . . . . . . . . . . . . . 34, 52 Export . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 Expression parsing demo . . . . . . . . . . . . . . . . . . . . . . . . . 20 Extended GCD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

F Factor removal functions . . . . . . . . . . . . . . . . . . . . . . . . . 36 Factorial algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 Factorial functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 Factorization demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Fast Fourier Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 Fat binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 FDL, GNU Free Documentation License . . . . . . . . . 121 FFT multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7, 93 Fibonacci number algorithm . . . . . . . . . . . . . . . . . . . . 105 Fibonacci sequence functions . . . . . . . . . . . . . . . . . . . . . 37 Float arithmetic functions . . . . . . . . . . . . . . . . . . . . . . . . 52 Float assignment functions . . . . . . . . . . . . . . . . . . . . . . . 50 Float comparison functions . . . . . . . . . . . . . . . . . . . . . . . 53 Float conversion functions . . . . . . . . . . . . . . . . . . . . . . . . 51 Float functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 Float initialization functions . . . . . . . . . . . . . . . . . . 48, 50 Float input and output functions . . . . . . . . . . . . . . . . . 53 Float internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113 Float miscellaneous functions. . . . . . . . . . . . . . . . . . . . . 54 Float random number functions . . . . . . . . . . . . . . . . . . 54 Float rounding functions . . . . . . . . . . . . . . . . . . . . . . . . . 54 Float sign tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 Floating point mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Floating-point functions . . . . . . . . . . . . . . . . . . . . . . . . . . 48 Floating-point number . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 fnccheck . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 Formatted input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 Formatted output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 Free Documentation License. . . . . . . . . . . . . . . . . . . . . 121 frexp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31, 51 FTP of latest version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

Function classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 FunctionCheck . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

G GCC Checker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 GCD algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 GCD extended . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 GCD functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 GDB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 Generic C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 GMP Perl module. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 GMP version number . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 `gmp.h'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 gmpxx.h. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 GNU Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 GNU Free Documentation License . . . . . . . . . . . . . . . 121 GNU strip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 gprof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 Greatest common divisor algorithms . . . . . . . . . . . . . . 98 Greatest common divisor functions . . . . . . . . . . . . . . . 35

H Hardware floating point mode . . . . . . . . . . . . . . . . . . . . 12 Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Heap problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Home page . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Host system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 HP-UX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 HPPA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

I I/O functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39, 47, 53 i386. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 IA-64 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 In-place operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 Include files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 info-lookup-symbol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Initialization functions . . . . . . . . . 29, 30, 44, 48, 50, 64 Initializing and clearing . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Input functions. . . . . . . . . . . . . . . . . . . . . . . . 39, 47, 53, 73 Install prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Installing GMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Instruction Set Architecture . . . . . . . . . . . . . . . . . . . . . . . 8 instrument-functions. . . . . . . . . . . . . . . . . . . . . . . . . . . 26 Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Integer arithmetic functions . . . . . . . . . . . . . . . . . . . . . . 32 Integer assignment functions . . . . . . . . . . . . . . . . . . 29, 30 Integer bit manipulation functions . . . . . . . . . . . . . . . . 38 Integer comparison functions . . . . . . . . . . . . . . . . . . . . . 37 Integer conversion functions . . . . . . . . . . . . . . . . . . . . . . 31 Integer division functions . . . . . . . . . . . . . . . . . . . . . . . . . 32 Integer exponentiation functions. . . . . . . . . . . . . . . . . . 34 Integer export. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 Integer functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 Integer import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 Integer initialization functions . . . . . . . . . . . . . . . . 29, 30 Integer input and output functions . . . . . . . . . . . . . . . 39 Integer internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 Integer logical functions . . . . . . . . . . . . . . . . . . . . . . . . . . 38 Integer miscellaneous functions . . . . . . . . . . . . . . . . . . . 42 Integer random number functions. . . . . . . . . . . . . . . . . 40

Concept Index 129 Integer root functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 Integer sign tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 Integer special functions. . . . . . . . . . . . . . . . . . . . . . . . . . 42 Interix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Inverse modulo functions . . . . . . . . . . . . . . . . . . . . . . . . . 36 IRIX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9, 14 ISA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 istream input. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

J Jacobi symbol algorithm . . . . . . . . . . . . . . . . . . . . . . . . 100 Jacobi symbol functions . . . . . . . . . . . . . . . . . . . . . . . . . . 36

K Karatsuba multiplication . . . . . . . . . . . . . . . . . . . . . . . . . 90 Karatsuba square root algorithm . . . . . . . . . . . . . . . . 100 Kronecker symbol functions . . . . . . . . . . . . . . . . . . . . . . 36

L Language bindings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 Latest version of GMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 LCM functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 Least common multiple functions . . . . . . . . . . . . . . . . . 36 Legendre symbol functions . . . . . . . . . . . . . . . . . . . . . . . 36 libgmp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 libgmpxx . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Libtool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Libtool versioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 License conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Limb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Limb size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Linear congruential algorithm . . . . . . . . . . . . . . . . . . . 106 Linear congruential random numbers . . . . . . . . . . . . . 64 Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Logical functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 Low-level functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 Lucas number algorithm . . . . . . . . . . . . . . . . . . . . . . . . 106 Lucas number functions . . . . . . . . . . . . . . . . . . . . . . . . . . 37

M MacOS 9. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 MacOS X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 Mailing lists. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Malloc debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Malloc problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Memory allocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 Memory management . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 Mersenne twister algorithm . . . . . . . . . . . . . . . . . . . . . 106 Mersenne twister random numbers . . . . . . . . . . . . . . . 64 MINGW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 MIPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Miscellaneous float functions . . . . . . . . . . . . . . . . . . . . . 54 Miscellaneous integer functions . . . . . . . . . . . . . . . . . . . 42 MMX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Modular inverse functions . . . . . . . . . . . . . . . . . . . . . . . . 36 Most significant bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mp.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

MPN_PATH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 MS Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12, 13 MS-DOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Multi-threading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 Multiplication algorithms . . . . . . . . . . . . . . . . . . . . . . . . 89

N Nails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 Native compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 NeXT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 Next prime function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 Nomenclature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Non-Unix systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Nth root algorithm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 Number sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Number theoretic functions. . . . . . . . . . . . . . . . . . . . . . . 35 Numerator and denominator . . . . . . . . . . . . . . . . . . . . . 46

O obstack output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 OpenBSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Optimizing performance . . . . . . . . . . . . . . . . . . . . . . . . . . 15 ostream output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 Other languages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 Output functions . . . . . . . . . . . . . . . . . . . . . . 39, 47, 53, 68

P Packaged builds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 Parameter conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 Parsing expressions demo . . . . . . . . . . . . . . . . . . . . . . . . 20 Particular systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Past GMP versions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 PDF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Perfect power algorithm . . . . . . . . . . . . . . . . . . . . . . . . . 102 Perfect power functions . . . . . . . . . . . . . . . . . . . . . . . . . . 35 Perfect square algorithm . . . . . . . . . . . . . . . . . . . . . . . . 101 Perfect square functions . . . . . . . . . . . . . . . . . . . . . . . . . . 35 perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Perl module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Postscript . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Power/PowerPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13, 15 Powering algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 Powering functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 34, 52 PowerPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Precision of floats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 Precision of hardware floating point . . . . . . . . . . . . . . 12 Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Prime testing algorithms . . . . . . . . . . . . . . . . . . . . . . . . 104 Prime testing functions. . . . . . . . . . . . . . . . . . . . . . . . . . . 35 printf formatted output . . . . . . . . . . . . . . . . . . . . . . . . . 66 Probable prime testing functions . . . . . . . . . . . . . . . . . 35 prof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 Profiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

R Radix conversion algorithms. . . . . . . . . . . . . . . . . . . . . 102 Random number algorithms . . . . . . . . . . . . . . . . . . . . . 106 Random number functions . . . . . . . . . . . . . . . . 40, 54, 64 Random number seeding . . . . . . . . . . . . . . . . . . . . . . . . . 65 Random number state. . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

130 GNU MP 4.2.3 Random state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Rational arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 Rational arithmetic functions. . . . . . . . . . . . . . . . . . . . . 45 Rational assignment functions . . . . . . . . . . . . . . . . . . . . 44 Rational comparison functions. . . . . . . . . . . . . . . . . . . . 46 Rational conversion functions. . . . . . . . . . . . . . . . . . . . . 45 Rational initialization functions . . . . . . . . . . . . . . . . . . 44 Rational input and output functions . . . . . . . . . . . . . . 47 Rational internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 Rational number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Rational number functions . . . . . . . . . . . . . . . . . . . . . . . 44 Rational numerator and denominator . . . . . . . . . . . . . 46 Rational sign tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 Raw output internals. . . . . . . . . . . . . . . . . . . . . . . . . . . . 115 Reallocations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Reentrancy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 Remove factor functions . . . . . . . . . . . . . . . . . . . . . . . . . . 36 Reporting bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 Root extraction algorithm . . . . . . . . . . . . . . . . . . . . . . . 101 Root extraction algorithms . . . . . . . . . . . . . . . . . . . . . . 100 Root extraction functions . . . . . . . . . . . . . . . . . . . . . 35, 52 Root testing functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 Rounding functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

S Sample programs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Scan bit functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 scanf formatted input . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 SCO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Seeding random numbers . . . . . . . . . . . . . . . . . . . . . . . . . 65 Segmentation violation . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Sequent Symmetry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 Services for Unix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Shared library versioning . . . . . . . . . . . . . . . . . . . . . . . . . 11 Sign tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37, 46, 53 Size in digits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 Small operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Solaris . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 15 Sparc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 Sparc V9. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Special integer functions . . . . . . . . . . . . . . . . . . . . . . . . . 42 Square root algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

SSE2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Stack backtrace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 Stack overflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7, 23 Static linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 stdarg.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 stdio.h. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Stripped libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Sun . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 SunOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 Systems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

T Temporary memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Texinfo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 Text input/output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Thread safety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 Toom multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . 91, 94 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

U ui and si functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Upward compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Useful macros and constants . . . . . . . . . . . . . . . . . . . . . 20 User-defined precision . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

V Valgrind . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 Variable conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 Version number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

W Web page . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12, 13

X x86 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 x87 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 XML. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

Function and Type Index 131 Function and Type Index __GNU_MP_VERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 __GNU_MP_VERSION_MINOR . . . . . . . . . . . . . . . . . . . . . . . . 20 __GNU_MP_VERSION_PATCHLEVEL. . . . . . . . . . . . . . . . . . . 20 _mpz_realloc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

A abs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77, 78, 80

C ceil . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 cmp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77, 78, 80

F floor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

G gcd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 gmp_asprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 gmp_errno . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 GMP_ERROR_INVALID_ARGUMENT . . . . . . . . . . . . . . . . . . . . 65 GMP_ERROR_UNSUPPORTED_ARGUMENT . . . . . . . . . . . . . . . 65 gmp_fprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_fscanf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 GMP_LIMB_BITS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 GMP_NAIL_BITS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 GMP_NAIL_MASK. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 GMP_NUMB_BITS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 GMP_NUMB_MASK. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 GMP_NUMB_MAX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 gmp_obstack_printf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 gmp_obstack_vprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 gmp_printf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 GMP_RAND_ALG_DEFAULT. . . . . . . . . . . . . . . . . . . . . . . . . . . 64 GMP_RAND_ALG_LC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 gmp_randclass. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 gmp_randclass::get_f. . . . . . . . . . . . . . . . . . . . . . . . . . . 81 gmp_randclass::get_z_bits . . . . . . . . . . . . . . . . . . . . . 81 gmp_randclass::get_z_range . . . . . . . . . . . . . . . . . . . . 81 gmp_randclass::gmp_randclass . . . . . . . . . . . . . . . . . 81 gmp_randclass::seed . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 gmp_randclear. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 gmp_randinit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 gmp_randinit_default. . . . . . . . . . . . . . . . . . . . . . . . . . . 64 gmp_randinit_lc_2exp. . . . . . . . . . . . . . . . . . . . . . . . . . . 64 gmp_randinit_lc_2exp_size . . . . . . . . . . . . . . . . . . . . . 64 gmp_randinit_mt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 gmp_randinit_set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 gmp_randseed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 gmp_randseed_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 gmp_randstate_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 gmp_scanf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 gmp_snprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_sprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_sscanf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 gmp_urandomb_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

gmp_urandomm_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 gmp_vasprintf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 gmp_version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 gmp_vfprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_vfscanf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 gmp_vprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_vscanf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 gmp_vsnprintf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_vsprintf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 gmp_vsscanf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

H hypot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

I itom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

M madd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 mcmp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 mdiv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 mfree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 min . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 MINT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 mout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 mp_bits_per_limb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 mp_exp_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 mp_get_memory_functions . . . . . . . . . . . . . . . . . . . . . . . 86 mp_limb_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 mp_set_memory_functions . . . . . . . . . . . . . . . . . . . . . . . 85 mp_size_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 mpf_abs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_add. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_add_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_ceil . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 mpf_class::fits_sint_p . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::fits_slong_p . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::fits_sshort_p . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::fits_uint_p . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::fits_ulong_p . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::fits_ushort_p . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::get_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::get_mpf_t. . . . . . . . . . . . . . . . . . . . . . . . . . . 76 mpf_class::get_prec . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::get_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::get_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::mpf_class. . . . . . . . . . . . . . . . . . . . . . . . . . . 79 mpf_class::operator=. . . . . . . . . . . . . . . . . . . . . . . . . . . 79 mpf_class::set_prec . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::set_prec_raw . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_class::set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 mpf_clear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 mpf_cmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_cmp_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

132 GNU MP 4.2.3 mpf_cmp_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_cmp_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_div. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_div_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_div_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_fits_sint_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_fits_slong_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_fits_sshort_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_fits_uint_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_fits_ulong_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_fits_ushort_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_floor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_get_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_get_d_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_get_default_prec. . . . . . . . . . . . . . . . . . . . . . . . . . . 48 mpf_get_prec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 mpf_get_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_get_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_init . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 mpf_init_set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_init_set_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_init_set_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_init_set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_init_set_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 mpf_init2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 mpf_inp_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_integer_p. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_mul. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_mul_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_mul_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_neg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_out_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_pow_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_random2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_reldiff . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_set_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_set_default_prec. . . . . . . . . . . . . . . . . . . . . . . . . . . 48 mpf_set_prec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 mpf_set_prec_raw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 mpf_set_q . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_set_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_set_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_set_z . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_sgn. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 mpf_sqrt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_sqrt_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_sub. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_sub_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_swap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 mpf_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 mpf_trunc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpf_ui_div . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_ui_sub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 mpf_urandomb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 mpn_add. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 mpn_add_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 mpn_add_n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 mpn_addmul_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_bdivmod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 mpn_cmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mpn_divexact_by3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

mpn_divexact_by3c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 mpn_divmod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 mpn_divmod_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 mpn_divrem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 mpn_divrem_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 mpn_gcd. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mpn_gcd_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mpn_gcdext . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mpn_get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_hamdist . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 mpn_lshift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 mpn_mod_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 mpn_mul. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 mpn_mul_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_mul_n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_perfect_square_p. . . . . . . . . . . . . . . . . . . . . . . . . . . 62 mpn_popcount . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_random2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_rshift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mpn_scan0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_scan1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 mpn_sqrtrem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 mpn_sub. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_sub_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_sub_n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_submul_1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 mpn_tdiv_qr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 mpq_abs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_add. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_canonicalize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 mpq_class::canonicalize . . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::get_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::get_den . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::get_den_mpz_t . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::get_mpq_t. . . . . . . . . . . . . . . . . . . . . . . . . . . 76 mpq_class::get_num . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::get_num_mpz_t . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 mpq_class::mpq_class . . . . . . . . . . . . . . . . . . . . . . . 77, 78 mpq_class::set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 mpq_clear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_cmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_cmp_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_cmp_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_denref . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_div. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_div_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_equal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_get_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_get_den . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_get_num . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_init . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_inp_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 mpq_inv. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_mul. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_mul_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_neg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_numref . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_out_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 mpq_set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_set_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

Function and Type Index 133 mpq_set_den . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_set_f . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_set_num . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_set_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_set_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_set_z . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 mpq_sgn. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 mpq_sub. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_swap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 mpq_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 mpz_abs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_add. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_add_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_addmul . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_addmul_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_and. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_array_init . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_bin_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_bin_uiui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cdiv_q . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_q_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_q_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_qr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_qr_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_r . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_r_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_r_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_cdiv_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 mpz_class::fits_sint_p . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::fits_slong_p . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::fits_sshort_p . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::fits_uint_p . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::fits_ulong_p . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::fits_ushort_p . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::get_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::get_mpz_t. . . . . . . . . . . . . . . . . . . . . . . . . . . 76 mpz_class::get_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::get_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_class::mpz_class. . . . . . . . . . . . . . . . . . . . . . . . . . . 76 mpz_class::set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 mpz_clear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_clrbit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_cmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cmp_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cmp_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cmp_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cmpabs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cmpabs_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_cmpabs_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_com. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_combit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_congruent_2exp_p. . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_congruent_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_congruent_ui_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_divexact . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_divexact_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_divisible_2exp_p. . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_divisible_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_divisible_ui_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_even_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_export . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 mpz_fac_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

mpz_fdiv_q . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_q_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_q_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_qr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_qr_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_r . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_r_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_r_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fdiv_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_fib_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_fib2_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_fits_sint_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_fits_slong_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_fits_sshort_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_fits_uint_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_fits_ulong_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_fits_ushort_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_gcd. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_gcd_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_gcdext . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_get_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 mpz_get_d_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 mpz_get_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 mpz_get_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 mpz_get_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 mpz_getlimbn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 mpz_hamdist . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 mpz_init . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_init_set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_init_set_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_init_set_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_init_set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_init_set_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_init2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_inp_raw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 mpz_inp_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 mpz_invert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_ior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_jacobi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_kronecker. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_kronecker_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_kronecker_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_lcm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_lcm_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_legendre . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_lucnum_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_lucnum2_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_mod. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_mod_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_mul. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_mul_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_mul_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_mul_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_neg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_nextprime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_odd_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_out_raw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 mpz_out_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 mpz_perfect_power_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_perfect_square_p. . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_popcount . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_pow_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_powm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_powm_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

134 GNU MP 4.2.3 mpz_probab_prime_p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 mpz_random2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 mpz_realloc2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_remove . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_rootrem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_rrandomb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 mpz_scan0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_scan1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_set_d . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_set_f . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_set_q . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_set_si . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_set_str . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_set_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 mpz_setbit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 mpz_sgn. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 mpz_si_kronecker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 mpz_sizeinbase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 mpz_sqrt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_sqrtrem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 mpz_sub. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_sub_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_submul . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_submul_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_swap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 mpz_t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 mpz_tdiv_q . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_q_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_q_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_qr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_qr_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_r . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_r_2exp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_r_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tdiv_ui . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 mpz_tstbit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

mpz_ui_kronecker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 mpz_ui_pow_ui. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 mpz_ui_sub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 mpz_urandomb . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 mpz_urandomm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 mpz_xor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 msqrt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 msub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 mtox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 mult . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

O operator% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 operator/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 operator<< . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 operator>> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73, 74, 79

P pow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

R rpow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

S sdiv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 sgn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77, 78, 80 sqrt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77, 80

T trunc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

X xtom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83