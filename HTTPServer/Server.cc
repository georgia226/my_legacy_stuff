/////////////////////////////////////////////////
//////// ********************************////////
///// **************************************/////
//// ****  HTTP  ****************************////
/// ***********  Server  *********************///
// ***********************  in C++  ***********//
// ********************************************//
/// **### StudentSoft copyleft@ ###***********///
//// *************   BSD License   **********////
///// **************************************/////
//////// ********************************////////
/////////////////////////////////////////////////
#include "XServerMain.hh"
#include "XGetOptions.hh"
#include "Common.hh"
#include <signal.h>
XServerMain* server=NULL;

////
//	Display help about the server
////
void DisplayHelp()
{
 printf("WWWserver, options are:\n");
 printf("\t-c PORT_NUM (client port number)\n");
 printf("\t-a PORT_NUM (administrative port number)\n");
 printf("\t-n MAX_CLINETS (maximum clients server can handle)\n");
 printf("\t-l LOG_FILE (log file name)\n");
 printf("\t-d (daemon mode)\n");
 printf("Server can read commands from admin_port, case is ignored\n");
 printf("Commands are:\n");
 printf("\tSUSPEND (stops all children, and logger)\n");
 printf("\tRESUME (resumes ----||----)\n");
 printf("\tRESET (kicks all children, closes all connections)\n");
 printf("\tHALT (acts like CTRL+C, halts server)\n");
 printf("\tTO GET filesystem root '/' instead of index.html\n");
 printf("\tUSE // as a file You want to get: http://server://\n");
 printf("Use './terminal' application to control server.\n");
 printf("\n");
}

////
//	react to all defined signals, mainly terminate client
//	server or logger cleanly
////
void AbortHandler(int signo)
{
 if (signo==SIGABRT) 	//generated by assert failure
   {
    printf("\nAssertions failed, this is fatal error\n"); //parent will reach delete class stage
    if ( server && server->IsChild()) 
      {						//assert in child
       int sock = server->GetSocketByPID(getpid());
       if (sock>0) close(sock);			//close its socket
       kill(getppid(), SIGINT);			//kill parent, it will stop the rest
       exit(0);					//leave
      }
   }
 if (signo==SIGUSR2 && server && server->IsChild()) //this signal stops the logger
   {
    Debug("Shutting down logger...\n");
    server->CloseLogFile();			//close log file
    exit(0);
   }
 if (signo==SIGINT)  					//interrup or send manually
   {							//by admin, admincmd, child assertion, interrupt etc.
    if (server && server->IsChild()) return;  //child ignores CTRL+C
    printf("\nUser Interrupt!, exiting...\n");		//children exit on SIGUSR1
   }
 if (signo==SIGUSR1) 					//exit request from parent
   {
    if (server && !(server->IsChild())) 	//if we aren't child
      {
       Debug("Parent Got SIGUSR1, this shouldn't happen, exiting...\n");
       exit(2);
      }
    Debug("Client PID: %d, got HALT request.\n", getpid());	//child
    if (!server) exit(2);
    //FIXME finalize some stuff here
    int sock = server->GetSocketByPID(getpid());
    if (sock>0) close(sock);				//close own socket
    exit(1);
   }
 if (server && !(server->IsChild())) 
 {
  Debug("Destroying resources...\n");
  delete server;					//here only parent
 }
 Debug("Server exiting on signal %d...\n", signo);	//destroy main class which will destroy the rest
 exit(1);						//goodbye
}

////
//	Setup all signal handlers, it will be inherited by
//	logger and client-handlers, through fork()
//	NOTE: there is one line which is NONPORTABLE
//	but You can change it as COMMENTS says
////
void SetupAbortHandler()
{
 server = NULL;
 static struct sigaction act;
 static struct sigaction chldact;
 act.sa_handler = AbortHandler;
 sigfillset(&(act.sa_mask));
 act.sa_handler = AbortHandler;
 sigfillset(&(act.sa_mask));
 chldact.sa_handler = SIG_IGN;		//FIXME NOT PORTABLE
 //chldact.sa_flags = SA_NOCLDWAIT;	//BSD USE ON *BSD systems
 chldact.sa_flags = SA_NOCLDSTOP;	//WINNT USE on M$ systems
 sigfillset(&(act.sa_mask));		//ONLY ONE OF ^ THESE OPTIONS SHOULD BE SELECTED
 sigfillset(&(chldact.sa_mask));
 sigaction(SIGABRT, &act, NULL);
 sigaction(SIGINT, &act, NULL);
 sigaction(SIGUSR1, &act, NULL);
 sigaction(SIGUSR2, &act, NULL);
 sigaction(SIGCHLD, &chldact, NULL);
}

////
//	Every C/C++ programmer knows what does this function
//	if not ... (?)
////
int main(int argc, char** argv)
{
 DisplayHelp();
 SetupAbortHandler();
 XGetOptions *xgo = new XGetOptions(argc, argv);
 assert(xgo);
 server = new XServerMain();
 assert(server);
 server->SetMaxClients(xgo->GetMaxClients());
 server->SetClientPort(xgo->GetClientPort());
 server->SetAdminPort(xgo->GetAdminPort());
 server->SetDaemon(xgo->GetDaemon());
 server->SetLogFile(xgo->GetLogFile());
 delete xgo;
 server->Run();
 delete server;
 return 0;
}

